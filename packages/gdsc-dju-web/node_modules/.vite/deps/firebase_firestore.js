import {
  ErrorCode,
  Event,
  EventType,
  FetchXmlHttpFactory,
  Stat,
  WebChannel,
  XhrIo,
  createWebChannelTransport,
  getStatEventTarget
} from "./chunk-5CM6PZP4.js";
import {
  Component,
  FirebaseError,
  LogLevel,
  Logger,
  SDK_VERSION,
  _getProvider,
  _registerComponent,
  _removeServiceInstance,
  createMockUserToken,
  deepEqual,
  getApp,
  getModularInstance,
  getUA,
  isBrowserExtension,
  isElectron,
  isIE,
  isIndexedDBAvailable,
  isMobileCordova,
  isReactNative,
  isSafari,
  isUWP,
  registerVersion
} from "./chunk-IUGO55XA.js";
import "./chunk-ACCAMVX6.js";

// ../../.yarn/__virtual__/@firebase-firestore-virtual-ee2f0f5284/0/cache/@firebase-firestore-npm-3.4.12-55de955672-b8bb44b7f3.zip/node_modules/@firebase/firestore/dist/index.esm2017.js
var D = "@firebase/firestore";
var C = class {
  constructor(t) {
    this.uid = t;
  }
  isAuthenticated() {
    return null != this.uid;
  }
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(t) {
    return t.uid === this.uid;
  }
};
C.UNAUTHENTICATED = new C(null), C.GOOGLE_CREDENTIALS = new C("google-credentials-uid"), C.FIRST_PARTY = new C("first-party-uid"), C.MOCK_USER = new C("mock-user");
var x = "9.9.0";
var N = new Logger("@firebase/firestore");
function k() {
  return N.logLevel;
}
function O(t) {
  N.setLogLevel(t);
}
function M(t, ...e) {
  if (N.logLevel <= LogLevel.DEBUG) {
    const n = e.map(B);
    N.debug(`Firestore (${x}): ${t}`, ...n);
  }
}
function F(t, ...e) {
  if (N.logLevel <= LogLevel.ERROR) {
    const n = e.map(B);
    N.error(`Firestore (${x}): ${t}`, ...n);
  }
}
function $(t, ...e) {
  if (N.logLevel <= LogLevel.WARN) {
    const n = e.map(B);
    N.warn(`Firestore (${x}): ${t}`, ...n);
  }
}
function B(t) {
  if ("string" == typeof t)
    return t;
  try {
    return e = t, JSON.stringify(e);
  } catch (e2) {
    return t;
  }
  var e;
}
function L(t = "Unexpected state") {
  const e = `FIRESTORE (${x}) INTERNAL ASSERTION FAILED: ` + t;
  throw F(e), new Error(e);
}
function U(t, e) {
  t || L();
}
function q(t, e) {
  t || L();
}
function K(t, e) {
  return t;
}
var G = {
  OK: "ok",
  CANCELLED: "cancelled",
  UNKNOWN: "unknown",
  INVALID_ARGUMENT: "invalid-argument",
  DEADLINE_EXCEEDED: "deadline-exceeded",
  NOT_FOUND: "not-found",
  ALREADY_EXISTS: "already-exists",
  PERMISSION_DENIED: "permission-denied",
  UNAUTHENTICATED: "unauthenticated",
  RESOURCE_EXHAUSTED: "resource-exhausted",
  FAILED_PRECONDITION: "failed-precondition",
  ABORTED: "aborted",
  OUT_OF_RANGE: "out-of-range",
  UNIMPLEMENTED: "unimplemented",
  INTERNAL: "internal",
  UNAVAILABLE: "unavailable",
  DATA_LOSS: "data-loss"
};
var Q = class extends FirebaseError {
  constructor(t, e) {
    super(t, e), this.code = t, this.message = e, this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
};
var j = class {
  constructor() {
    this.promise = new Promise((t, e) => {
      this.resolve = t, this.reject = e;
    });
  }
};
var W = class {
  constructor(t, e) {
    this.user = e, this.type = "OAuth", this.headers = /* @__PURE__ */ new Map(), this.headers.set("Authorization", `Bearer ${t}`);
  }
};
var z = class {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(t, e) {
    t.enqueueRetryable(() => e(C.UNAUTHENTICATED));
  }
  shutdown() {
  }
};
var H = class {
  constructor(t) {
    this.token = t, this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  start(t, e) {
    this.changeListener = e, t.enqueueRetryable(() => e(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
};
var J = class {
  constructor(t) {
    this.t = t, this.currentUser = C.UNAUTHENTICATED, this.i = 0, this.forceRefresh = false, this.auth = null;
  }
  start(t, e) {
    let n = this.i;
    const s = (t2) => this.i !== n ? (n = this.i, e(t2)) : Promise.resolve();
    let i = new j();
    this.o = () => {
      this.i++, this.currentUser = this.u(), i.resolve(), i = new j(), t.enqueueRetryable(() => s(this.currentUser));
    };
    const r = () => {
      const e2 = i;
      t.enqueueRetryable(async () => {
        await e2.promise, await s(this.currentUser);
      });
    }, o = (t2) => {
      M("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = t2, this.auth.addAuthTokenListener(this.o), r();
    };
    this.t.onInit((t2) => o(t2)), setTimeout(() => {
      if (!this.auth) {
        const t2 = this.t.getImmediate({
          optional: true
        });
        t2 ? o(t2) : (M("FirebaseAuthCredentialsProvider", "Auth not yet detected"), i.resolve(), i = new j());
      }
    }, 0), r();
  }
  getToken() {
    const t = this.i, e = this.forceRefresh;
    return this.forceRefresh = false, this.auth ? this.auth.getToken(e).then((e2) => this.i !== t ? (M("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : e2 ? (U("string" == typeof e2.accessToken), new W(e2.accessToken, this.currentUser)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.auth && this.auth.removeAuthTokenListener(this.o);
  }
  u() {
    const t = this.auth && this.auth.getUid();
    return U(null === t || "string" == typeof t), new C(t);
  }
};
var Y = class {
  constructor(t, e, n) {
    this.type = "FirstParty", this.user = C.FIRST_PARTY, this.headers = /* @__PURE__ */ new Map(), this.headers.set("X-Goog-AuthUser", e);
    const s = t.auth.getAuthHeaderValueForFirstParty([]);
    s && this.headers.set("Authorization", s), n && this.headers.set("X-Goog-Iam-Authorization-Token", n);
  }
};
var X = class {
  constructor(t, e, n) {
    this.h = t, this.l = e, this.m = n;
  }
  getToken() {
    return Promise.resolve(new Y(this.h, this.l, this.m));
  }
  start(t, e) {
    t.enqueueRetryable(() => e(C.FIRST_PARTY));
  }
  shutdown() {
  }
  invalidateToken() {
  }
};
var Z = class {
  constructor(t) {
    this.value = t, this.type = "AppCheck", this.headers = /* @__PURE__ */ new Map(), t && t.length > 0 && this.headers.set("x-firebase-appcheck", this.value);
  }
};
var tt = class {
  constructor(t) {
    this.g = t, this.forceRefresh = false, this.appCheck = null, this.p = null;
  }
  start(t, e) {
    const n = (t2) => {
      null != t2.error && M("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${t2.error.message}`);
      const n2 = t2.token !== this.p;
      return this.p = t2.token, M("FirebaseAppCheckTokenProvider", `Received ${n2 ? "new" : "existing"} token.`), n2 ? e(t2.token) : Promise.resolve();
    };
    this.o = (e2) => {
      t.enqueueRetryable(() => n(e2));
    };
    const s = (t2) => {
      M("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = t2, this.appCheck.addTokenListener(this.o);
    };
    this.g.onInit((t2) => s(t2)), setTimeout(() => {
      if (!this.appCheck) {
        const t2 = this.g.getImmediate({
          optional: true
        });
        t2 ? s(t2) : M("FirebaseAppCheckTokenProvider", "AppCheck not yet detected");
      }
    }, 0);
  }
  getToken() {
    const t = this.forceRefresh;
    return this.forceRefresh = false, this.appCheck ? this.appCheck.getToken(t).then((t2) => t2 ? (U("string" == typeof t2.token), this.p = t2.token, new Z(t2.token)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.appCheck && this.appCheck.removeTokenListener(this.o);
  }
};
var et = class {
  getToken() {
    return Promise.resolve(new Z(""));
  }
  invalidateToken() {
  }
  start(t, e) {
  }
  shutdown() {
  }
};
function nt(t) {
  const e = "undefined" != typeof self && (self.crypto || self.msCrypto), n = new Uint8Array(t);
  if (e && "function" == typeof e.getRandomValues)
    e.getRandomValues(n);
  else
    for (let e2 = 0; e2 < t; e2++)
      n[e2] = Math.floor(256 * Math.random());
  return n;
}
var st = class {
  static I() {
    const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", e = Math.floor(256 / t.length) * t.length;
    let n = "";
    for (; n.length < 20; ) {
      const s = nt(40);
      for (let i = 0; i < s.length; ++i)
        n.length < 20 && s[i] < e && (n += t.charAt(s[i] % t.length));
    }
    return n;
  }
};
function it(t, e) {
  return t < e ? -1 : t > e ? 1 : 0;
}
function rt(t, e, n) {
  return t.length === e.length && t.every((t2, s) => n(t2, e[s]));
}
function ot(t) {
  return t + "\0";
}
var ut = class {
  constructor(t, e) {
    if (this.seconds = t, this.nanoseconds = e, e < 0)
      throw new Q(G.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (e >= 1e9)
      throw new Q(G.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (t < -62135596800)
      throw new Q(G.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t);
    if (t >= 253402300800)
      throw new Q(G.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t);
  }
  static now() {
    return ut.fromMillis(Date.now());
  }
  static fromDate(t) {
    return ut.fromMillis(t.getTime());
  }
  static fromMillis(t) {
    const e = Math.floor(t / 1e3), n = Math.floor(1e6 * (t - 1e3 * e));
    return new ut(e, n);
  }
  toDate() {
    return new Date(this.toMillis());
  }
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(t) {
    return this.seconds === t.seconds ? it(this.nanoseconds, t.nanoseconds) : it(this.seconds, t.seconds);
  }
  isEqual(t) {
    return t.seconds === this.seconds && t.nanoseconds === this.nanoseconds;
  }
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds
    };
  }
  valueOf() {
    const t = this.seconds - -62135596800;
    return String(t).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
  }
};
var ct = class {
  constructor(t) {
    this.timestamp = t;
  }
  static fromTimestamp(t) {
    return new ct(t);
  }
  static min() {
    return new ct(new ut(0, 0));
  }
  static max() {
    return new ct(new ut(253402300799, 999999999));
  }
  compareTo(t) {
    return this.timestamp._compareTo(t.timestamp);
  }
  isEqual(t) {
    return this.timestamp.isEqual(t.timestamp);
  }
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
};
var at = class {
  constructor(t, e, n) {
    void 0 === e ? e = 0 : e > t.length && L(), void 0 === n ? n = t.length - e : n > t.length - e && L(), this.segments = t, this.offset = e, this.len = n;
  }
  get length() {
    return this.len;
  }
  isEqual(t) {
    return 0 === at.comparator(this, t);
  }
  child(t) {
    const e = this.segments.slice(this.offset, this.limit());
    return t instanceof at ? t.forEach((t2) => {
      e.push(t2);
    }) : e.push(t), this.construct(e);
  }
  limit() {
    return this.offset + this.length;
  }
  popFirst(t) {
    return t = void 0 === t ? 1 : t, this.construct(this.segments, this.offset + t, this.length - t);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(t) {
    return this.segments[this.offset + t];
  }
  isEmpty() {
    return 0 === this.length;
  }
  isPrefixOf(t) {
    if (t.length < this.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t.get(e))
        return false;
    return true;
  }
  isImmediateParentOf(t) {
    if (this.length + 1 !== t.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t.get(e))
        return false;
    return true;
  }
  forEach(t) {
    for (let e = this.offset, n = this.limit(); e < n; e++)
      t(this.segments[e]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(t, e) {
    const n = Math.min(t.length, e.length);
    for (let s = 0; s < n; s++) {
      const n2 = t.get(s), i = e.get(s);
      if (n2 < i)
        return -1;
      if (n2 > i)
        return 1;
    }
    return t.length < e.length ? -1 : t.length > e.length ? 1 : 0;
  }
};
var ht = class extends at {
  construct(t, e, n) {
    return new ht(t, e, n);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  static fromString(...t) {
    const e = [];
    for (const n of t) {
      if (n.indexOf("//") >= 0)
        throw new Q(G.INVALID_ARGUMENT, `Invalid segment (${n}). Paths must not contain // in them.`);
      e.push(...n.split("/").filter((t2) => t2.length > 0));
    }
    return new ht(e);
  }
  static emptyPath() {
    return new ht([]);
  }
};
var lt = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
var ft = class extends at {
  construct(t, e, n) {
    return new ft(t, e, n);
  }
  static isValidIdentifier(t) {
    return lt.test(t);
  }
  canonicalString() {
    return this.toArray().map((t) => (t = t.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), ft.isValidIdentifier(t) || (t = "`" + t + "`"), t)).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  isKeyField() {
    return 1 === this.length && "__name__" === this.get(0);
  }
  static keyField() {
    return new ft(["__name__"]);
  }
  static fromServerFormat(t) {
    const e = [];
    let n = "", s = 0;
    const i = () => {
      if (0 === n.length)
        throw new Q(G.INVALID_ARGUMENT, `Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      e.push(n), n = "";
    };
    let r = false;
    for (; s < t.length; ) {
      const e2 = t[s];
      if ("\\" === e2) {
        if (s + 1 === t.length)
          throw new Q(G.INVALID_ARGUMENT, "Path has trailing escape character: " + t);
        const e3 = t[s + 1];
        if ("\\" !== e3 && "." !== e3 && "`" !== e3)
          throw new Q(G.INVALID_ARGUMENT, "Path has invalid escape sequence: " + t);
        n += e3, s += 2;
      } else
        "`" === e2 ? (r = !r, s++) : "." !== e2 || r ? (n += e2, s++) : (i(), s++);
    }
    if (i(), r)
      throw new Q(G.INVALID_ARGUMENT, "Unterminated ` in path: " + t);
    return new ft(e);
  }
  static emptyPath() {
    return new ft([]);
  }
};
var dt = class {
  constructor(t) {
    this.path = t;
  }
  static fromPath(t) {
    return new dt(ht.fromString(t));
  }
  static fromName(t) {
    return new dt(ht.fromString(t).popFirst(5));
  }
  static empty() {
    return new dt(ht.emptyPath());
  }
  get collectionGroup() {
    return this.path.popLast().lastSegment();
  }
  hasCollectionId(t) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === t;
  }
  getCollectionGroup() {
    return this.path.get(this.path.length - 2);
  }
  getCollectionPath() {
    return this.path.popLast();
  }
  isEqual(t) {
    return null !== t && 0 === ht.comparator(this.path, t.path);
  }
  toString() {
    return this.path.toString();
  }
  static comparator(t, e) {
    return ht.comparator(t.path, e.path);
  }
  static isDocumentKey(t) {
    return t.length % 2 == 0;
  }
  static fromSegments(t) {
    return new dt(new ht(t.slice()));
  }
};
var _t = class {
  constructor(t, e, n, s) {
    this.indexId = t, this.collectionGroup = e, this.fields = n, this.indexState = s;
  }
};
function wt(t) {
  return t.fields.find((t2) => 2 === t2.kind);
}
function mt(t) {
  return t.fields.filter((t2) => 2 !== t2.kind);
}
_t.UNKNOWN_ID = -1;
var gt = class {
  constructor(t, e) {
    this.fieldPath = t, this.kind = e;
  }
};
var yt = class {
  constructor(t, e) {
    this.sequenceNumber = t, this.offset = e;
  }
  static empty() {
    return new yt(0, Tt.min());
  }
};
function pt(t, e) {
  const n = t.toTimestamp().seconds, s = t.toTimestamp().nanoseconds + 1, i = ct.fromTimestamp(1e9 === s ? new ut(n + 1, 0) : new ut(n, s));
  return new Tt(i, dt.empty(), e);
}
function It(t) {
  return new Tt(t.readTime, t.key, -1);
}
var Tt = class {
  constructor(t, e, n) {
    this.readTime = t, this.documentKey = e, this.largestBatchId = n;
  }
  static min() {
    return new Tt(ct.min(), dt.empty(), -1);
  }
  static max() {
    return new Tt(ct.max(), dt.empty(), -1);
  }
};
function Et(t, e) {
  let n = t.readTime.compareTo(e.readTime);
  return 0 !== n ? n : (n = dt.comparator(t.documentKey, e.documentKey), 0 !== n ? n : it(t.largestBatchId, e.largestBatchId));
}
var At = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
var Rt = class {
  constructor() {
    this.onCommittedListeners = [];
  }
  addOnCommittedListener(t) {
    this.onCommittedListeners.push(t);
  }
  raiseOnCommittedEvent() {
    this.onCommittedListeners.forEach((t) => t());
  }
};
async function bt(t) {
  if (t.code !== G.FAILED_PRECONDITION || t.message !== At)
    throw t;
  M("LocalStore", "Unexpectedly lost primary lease");
}
var Pt = class {
  constructor(t) {
    this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = false, this.callbackAttached = false, t((t2) => {
      this.isDone = true, this.result = t2, this.nextCallback && this.nextCallback(t2);
    }, (t2) => {
      this.isDone = true, this.error = t2, this.catchCallback && this.catchCallback(t2);
    });
  }
  catch(t) {
    return this.next(void 0, t);
  }
  next(t, e) {
    return this.callbackAttached && L(), this.callbackAttached = true, this.isDone ? this.error ? this.wrapFailure(e, this.error) : this.wrapSuccess(t, this.result) : new Pt((n, s) => {
      this.nextCallback = (e2) => {
        this.wrapSuccess(t, e2).next(n, s);
      }, this.catchCallback = (t2) => {
        this.wrapFailure(e, t2).next(n, s);
      };
    });
  }
  toPromise() {
    return new Promise((t, e) => {
      this.next(t, e);
    });
  }
  wrapUserFunction(t) {
    try {
      const e = t();
      return e instanceof Pt ? e : Pt.resolve(e);
    } catch (t2) {
      return Pt.reject(t2);
    }
  }
  wrapSuccess(t, e) {
    return t ? this.wrapUserFunction(() => t(e)) : Pt.resolve(e);
  }
  wrapFailure(t, e) {
    return t ? this.wrapUserFunction(() => t(e)) : Pt.reject(e);
  }
  static resolve(t) {
    return new Pt((e, n) => {
      e(t);
    });
  }
  static reject(t) {
    return new Pt((e, n) => {
      n(t);
    });
  }
  static waitFor(t) {
    return new Pt((e, n) => {
      let s = 0, i = 0, r = false;
      t.forEach((t2) => {
        ++s, t2.next(() => {
          ++i, r && i === s && e();
        }, (t3) => n(t3));
      }), r = true, i === s && e();
    });
  }
  static or(t) {
    let e = Pt.resolve(false);
    for (const n of t)
      e = e.next((t2) => t2 ? Pt.resolve(t2) : n());
    return e;
  }
  static forEach(t, e) {
    const n = [];
    return t.forEach((t2, s) => {
      n.push(e.call(this, t2, s));
    }), this.waitFor(n);
  }
  static mapArray(t, e) {
    return new Pt((n, s) => {
      const i = t.length, r = new Array(i);
      let o = 0;
      for (let u = 0; u < i; u++) {
        const c = u;
        e(t[c]).next((t2) => {
          r[c] = t2, ++o, o === i && n(r);
        }, (t2) => s(t2));
      }
    });
  }
  static doWhile(t, e) {
    return new Pt((n, s) => {
      const i = () => {
        true === t() ? e().next(() => {
          i();
        }, s) : n();
      };
      i();
    });
  }
};
var vt = class {
  constructor(t, e) {
    this.action = t, this.transaction = e, this.aborted = false, this.T = new j(), this.transaction.oncomplete = () => {
      this.T.resolve();
    }, this.transaction.onabort = () => {
      e.error ? this.T.reject(new Dt(t, e.error)) : this.T.resolve();
    }, this.transaction.onerror = (e2) => {
      const n = Ot(e2.target.error);
      this.T.reject(new Dt(t, n));
    };
  }
  static open(t, e, n, s) {
    try {
      return new vt(e, t.transaction(s, n));
    } catch (t2) {
      throw new Dt(e, t2);
    }
  }
  get A() {
    return this.T.promise;
  }
  abort(t) {
    t && this.T.reject(t), this.aborted || (M("SimpleDb", "Aborting transaction:", t ? t.message : "Client-initiated abort"), this.aborted = true, this.transaction.abort());
  }
  R() {
    const t = this.transaction;
    this.aborted || "function" != typeof t.commit || t.commit();
  }
  store(t) {
    const e = this.transaction.objectStore(t);
    return new xt(e);
  }
};
var Vt = class {
  constructor(t, e, n) {
    this.name = t, this.version = e, this.P = n;
    12.2 === Vt.v(getUA()) && F("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
  }
  static delete(t) {
    return M("SimpleDb", "Removing database:", t), Nt(window.indexedDB.deleteDatabase(t)).toPromise();
  }
  static V() {
    if (!isIndexedDBAvailable())
      return false;
    if (Vt.S())
      return true;
    const t = getUA(), e = Vt.v(t), n = 0 < e && e < 10, s = Vt.D(t), i = 0 < s && s < 4.5;
    return !(t.indexOf("MSIE ") > 0 || t.indexOf("Trident/") > 0 || t.indexOf("Edge/") > 0 || n || i);
  }
  static S() {
    var t;
    return "undefined" != typeof process && "YES" === (null === (t = process.env) || void 0 === t ? void 0 : t.C);
  }
  static N(t, e) {
    return t.store(e);
  }
  static v(t) {
    const e = t.match(/i(?:phone|pad|pod) os ([\d_]+)/i), n = e ? e[1].split("_").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  static D(t) {
    const e = t.match(/Android ([\d.]+)/i), n = e ? e[1].split(".").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  async k(t) {
    return this.db || (M("SimpleDb", "Opening database:", this.name), this.db = await new Promise((e, n) => {
      const s = indexedDB.open(this.name, this.version);
      s.onsuccess = (t2) => {
        const n2 = t2.target.result;
        e(n2);
      }, s.onblocked = () => {
        n(new Dt(t, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed."));
      }, s.onerror = (e2) => {
        const s2 = e2.target.error;
        "VersionError" === s2.name ? n(new Q(G.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.")) : "InvalidStateError" === s2.name ? n(new Q(G.FAILED_PRECONDITION, "Unable to open an IndexedDB connection. This could be due to running in a private browsing session on a browser whose private browsing sessions do not support IndexedDB: " + s2)) : n(new Dt(t, s2));
      }, s.onupgradeneeded = (t2) => {
        M("SimpleDb", 'Database "' + this.name + '" requires upgrade from version:', t2.oldVersion);
        const e2 = t2.target.result;
        this.P.O(e2, s.transaction, t2.oldVersion, this.version).next(() => {
          M("SimpleDb", "Database upgrade to version " + this.version + " complete");
        });
      };
    })), this.M && (this.db.onversionchange = (t2) => this.M(t2)), this.db;
  }
  F(t) {
    this.M = t, this.db && (this.db.onversionchange = (e) => t(e));
  }
  async runTransaction(t, e, n, s) {
    const i = "readonly" === e;
    let r = 0;
    for (; ; ) {
      ++r;
      try {
        this.db = await this.k(t);
        const e2 = vt.open(this.db, t, i ? "readonly" : "readwrite", n), r2 = s(e2).next((t2) => (e2.R(), t2)).catch((t2) => (e2.abort(t2), Pt.reject(t2))).toPromise();
        return r2.catch(() => {
        }), await e2.A, r2;
      } catch (t2) {
        const e2 = t2, n2 = "FirebaseError" !== e2.name && r < 3;
        if (M("SimpleDb", "Transaction failed with error:", e2.message, "Retrying:", n2), this.close(), !n2)
          return Promise.reject(e2);
      }
    }
  }
  close() {
    this.db && this.db.close(), this.db = void 0;
  }
};
var St = class {
  constructor(t) {
    this.$ = t, this.B = false, this.L = null;
  }
  get isDone() {
    return this.B;
  }
  get U() {
    return this.L;
  }
  set cursor(t) {
    this.$ = t;
  }
  done() {
    this.B = true;
  }
  q(t) {
    this.L = t;
  }
  delete() {
    return Nt(this.$.delete());
  }
};
var Dt = class extends Q {
  constructor(t, e) {
    super(G.UNAVAILABLE, `IndexedDB transaction '${t}' failed: ${e}`), this.name = "IndexedDbTransactionError";
  }
};
function Ct(t) {
  return "IndexedDbTransactionError" === t.name;
}
var xt = class {
  constructor(t) {
    this.store = t;
  }
  put(t, e) {
    let n;
    return void 0 !== e ? (M("SimpleDb", "PUT", this.store.name, t, e), n = this.store.put(e, t)) : (M("SimpleDb", "PUT", this.store.name, "<auto-key>", t), n = this.store.put(t)), Nt(n);
  }
  add(t) {
    M("SimpleDb", "ADD", this.store.name, t, t);
    return Nt(this.store.add(t));
  }
  get(t) {
    return Nt(this.store.get(t)).next((e) => (void 0 === e && (e = null), M("SimpleDb", "GET", this.store.name, t, e), e));
  }
  delete(t) {
    M("SimpleDb", "DELETE", this.store.name, t);
    return Nt(this.store.delete(t));
  }
  count() {
    M("SimpleDb", "COUNT", this.store.name);
    return Nt(this.store.count());
  }
  K(t, e) {
    const n = this.options(t, e);
    if (n.index || "function" != typeof this.store.getAll) {
      const t2 = this.cursor(n), e2 = [];
      return this.G(t2, (t3, n2) => {
        e2.push(n2);
      }).next(() => e2);
    }
    {
      const t2 = this.store.getAll(n.range);
      return new Pt((e2, n2) => {
        t2.onerror = (t3) => {
          n2(t3.target.error);
        }, t2.onsuccess = (t3) => {
          e2(t3.target.result);
        };
      });
    }
  }
  j(t, e) {
    const n = this.store.getAll(t, null === e ? void 0 : e);
    return new Pt((t2, e2) => {
      n.onerror = (t3) => {
        e2(t3.target.error);
      }, n.onsuccess = (e3) => {
        t2(e3.target.result);
      };
    });
  }
  W(t, e) {
    M("SimpleDb", "DELETE ALL", this.store.name);
    const n = this.options(t, e);
    n.H = false;
    const s = this.cursor(n);
    return this.G(s, (t2, e2, n2) => n2.delete());
  }
  J(t, e) {
    let n;
    e ? n = t : (n = {}, e = t);
    const s = this.cursor(n);
    return this.G(s, e);
  }
  Y(t) {
    const e = this.cursor({});
    return new Pt((n, s) => {
      e.onerror = (t2) => {
        const e2 = Ot(t2.target.error);
        s(e2);
      }, e.onsuccess = (e2) => {
        const s2 = e2.target.result;
        s2 ? t(s2.primaryKey, s2.value).next((t2) => {
          t2 ? s2.continue() : n();
        }) : n();
      };
    });
  }
  G(t, e) {
    const n = [];
    return new Pt((s, i) => {
      t.onerror = (t2) => {
        i(t2.target.error);
      }, t.onsuccess = (t2) => {
        const i2 = t2.target.result;
        if (!i2)
          return void s();
        const r = new St(i2), o = e(i2.primaryKey, i2.value, r);
        if (o instanceof Pt) {
          const t3 = o.catch((t4) => (r.done(), Pt.reject(t4)));
          n.push(t3);
        }
        r.isDone ? s() : null === r.U ? i2.continue() : i2.continue(r.U);
      };
    }).next(() => Pt.waitFor(n));
  }
  options(t, e) {
    let n;
    return void 0 !== t && ("string" == typeof t ? n = t : e = t), {
      index: n,
      range: e
    };
  }
  cursor(t) {
    let e = "next";
    if (t.reverse && (e = "prev"), t.index) {
      const n = this.store.index(t.index);
      return t.H ? n.openKeyCursor(t.range, e) : n.openCursor(t.range, e);
    }
    return this.store.openCursor(t.range, e);
  }
};
function Nt(t) {
  return new Pt((e, n) => {
    t.onsuccess = (t2) => {
      const n2 = t2.target.result;
      e(n2);
    }, t.onerror = (t2) => {
      const e2 = Ot(t2.target.error);
      n(e2);
    };
  });
}
var kt = false;
function Ot(t) {
  const e = Vt.v(getUA());
  if (e >= 12.2 && e < 13) {
    const e2 = "An internal error was encountered in the Indexed Database server";
    if (t.message.indexOf(e2) >= 0) {
      const t2 = new Q("internal", `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${e2}'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.`);
      return kt || (kt = true, setTimeout(() => {
        throw t2;
      }, 0)), t2;
    }
  }
  return t;
}
var Mt = class {
  constructor(t, e) {
    this.asyncQueue = t, this.X = e, this.task = null;
  }
  start() {
  }
  stop() {
    this.task && (this.task.cancel(), this.task = null);
  }
  get started() {
    return null !== this.task;
  }
  Z(t) {
    M("IndexBackiller", `Scheduled in ${t}ms`), this.task = this.asyncQueue.enqueueAfterDelay("index_backfill", t, async () => {
      this.task = null;
      try {
        M("IndexBackiller", `Documents written: ${await this.X.tt()}`);
      } catch (t2) {
        Ct(t2) ? M("IndexBackiller", "Ignoring IndexedDB error during index backfill: ", t2) : await bt(t2);
      }
      await this.Z(1);
    });
  }
};
var Ft = class {
  constructor(t, e) {
    this.localStore = t, this.persistence = e;
  }
  async tt(t = 50) {
    return this.persistence.runTransaction("Backfill Indexes", "readwrite-primary", (e) => this.et(e, t));
  }
  et(t, e) {
    const n = /* @__PURE__ */ new Set();
    let s = e, i = true;
    return Pt.doWhile(() => true === i && s > 0, () => this.localStore.indexManager.getNextCollectionGroupToUpdate(t).next((e2) => {
      if (null !== e2 && !n.has(e2))
        return M("IndexBackiller", `Processing collection: ${e2}`), this.nt(t, e2, s).next((t2) => {
          s -= t2, n.add(e2);
        });
      i = false;
    })).next(() => e - s);
  }
  nt(t, e, n) {
    return this.localStore.indexManager.getMinOffsetFromCollectionGroup(t, e).next((s) => this.localStore.localDocuments.getNextDocuments(t, e, s, n).next((n2) => {
      const i = n2.changes;
      return this.localStore.indexManager.updateIndexEntries(t, i).next(() => this.st(s, n2)).next((n3) => (M("IndexBackiller", `Updating offset: ${n3}`), this.localStore.indexManager.updateCollectionGroup(t, e, n3))).next(() => i.size);
    }));
  }
  st(t, e) {
    let n = t;
    return e.changes.forEach((t2, e2) => {
      const s = It(e2);
      Et(s, n) > 0 && (n = s);
    }), new Tt(n.readTime, n.documentKey, Math.max(e.batchId, t.largestBatchId));
  }
};
var $t = class {
  constructor(t, e) {
    this.previousValue = t, e && (e.sequenceNumberHandler = (t2) => this.it(t2), this.rt = (t2) => e.writeSequenceNumber(t2));
  }
  it(t) {
    return this.previousValue = Math.max(t, this.previousValue), this.previousValue;
  }
  next() {
    const t = ++this.previousValue;
    return this.rt && this.rt(t), t;
  }
};
function Bt(t) {
  let e = 0;
  for (const n in t)
    Object.prototype.hasOwnProperty.call(t, n) && e++;
  return e;
}
function Lt(t, e) {
  for (const n in t)
    Object.prototype.hasOwnProperty.call(t, n) && e(n, t[n]);
}
function Ut(t) {
  for (const e in t)
    if (Object.prototype.hasOwnProperty.call(t, e))
      return false;
  return true;
}
$t.ot = -1;
var qt = class {
  constructor(t, e) {
    this.comparator = t, this.root = e || Gt.EMPTY;
  }
  insert(t, e) {
    return new qt(this.comparator, this.root.insert(t, e, this.comparator).copy(null, null, Gt.BLACK, null, null));
  }
  remove(t) {
    return new qt(this.comparator, this.root.remove(t, this.comparator).copy(null, null, Gt.BLACK, null, null));
  }
  get(t) {
    let e = this.root;
    for (; !e.isEmpty(); ) {
      const n = this.comparator(t, e.key);
      if (0 === n)
        return e.value;
      n < 0 ? e = e.left : n > 0 && (e = e.right);
    }
    return null;
  }
  indexOf(t) {
    let e = 0, n = this.root;
    for (; !n.isEmpty(); ) {
      const s = this.comparator(t, n.key);
      if (0 === s)
        return e + n.left.size;
      s < 0 ? n = n.left : (e += n.left.size + 1, n = n.right);
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  get size() {
    return this.root.size;
  }
  minKey() {
    return this.root.minKey();
  }
  maxKey() {
    return this.root.maxKey();
  }
  inorderTraversal(t) {
    return this.root.inorderTraversal(t);
  }
  forEach(t) {
    this.inorderTraversal((e, n) => (t(e, n), false));
  }
  toString() {
    const t = [];
    return this.inorderTraversal((e, n) => (t.push(`${e}:${n}`), false)), `{${t.join(", ")}}`;
  }
  reverseTraversal(t) {
    return this.root.reverseTraversal(t);
  }
  getIterator() {
    return new Kt(this.root, null, this.comparator, false);
  }
  getIteratorFrom(t) {
    return new Kt(this.root, t, this.comparator, false);
  }
  getReverseIterator() {
    return new Kt(this.root, null, this.comparator, true);
  }
  getReverseIteratorFrom(t) {
    return new Kt(this.root, t, this.comparator, true);
  }
};
var Kt = class {
  constructor(t, e, n, s) {
    this.isReverse = s, this.nodeStack = [];
    let i = 1;
    for (; !t.isEmpty(); )
      if (i = e ? n(t.key, e) : 1, e && s && (i *= -1), i < 0)
        t = this.isReverse ? t.left : t.right;
      else {
        if (0 === i) {
          this.nodeStack.push(t);
          break;
        }
        this.nodeStack.push(t), t = this.isReverse ? t.right : t.left;
      }
  }
  getNext() {
    let t = this.nodeStack.pop();
    const e = {
      key: t.key,
      value: t.value
    };
    if (this.isReverse)
      for (t = t.left; !t.isEmpty(); )
        this.nodeStack.push(t), t = t.right;
    else
      for (t = t.right; !t.isEmpty(); )
        this.nodeStack.push(t), t = t.left;
    return e;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (0 === this.nodeStack.length)
      return null;
    const t = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: t.key,
      value: t.value
    };
  }
};
var Gt = class {
  constructor(t, e, n, s, i) {
    this.key = t, this.value = e, this.color = null != n ? n : Gt.RED, this.left = null != s ? s : Gt.EMPTY, this.right = null != i ? i : Gt.EMPTY, this.size = this.left.size + 1 + this.right.size;
  }
  copy(t, e, n, s, i) {
    return new Gt(null != t ? t : this.key, null != e ? e : this.value, null != n ? n : this.color, null != s ? s : this.left, null != i ? i : this.right);
  }
  isEmpty() {
    return false;
  }
  inorderTraversal(t) {
    return this.left.inorderTraversal(t) || t(this.key, this.value) || this.right.inorderTraversal(t);
  }
  reverseTraversal(t) {
    return this.right.reverseTraversal(t) || t(this.key, this.value) || this.left.reverseTraversal(t);
  }
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  minKey() {
    return this.min().key;
  }
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  insert(t, e, n) {
    let s = this;
    const i = n(t, s.key);
    return s = i < 0 ? s.copy(null, null, null, s.left.insert(t, e, n), null) : 0 === i ? s.copy(null, e, null, null, null) : s.copy(null, null, null, null, s.right.insert(t, e, n)), s.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty())
      return Gt.EMPTY;
    let t = this;
    return t.left.isRed() || t.left.left.isRed() || (t = t.moveRedLeft()), t = t.copy(null, null, null, t.left.removeMin(), null), t.fixUp();
  }
  remove(t, e) {
    let n, s = this;
    if (e(t, s.key) < 0)
      s.left.isEmpty() || s.left.isRed() || s.left.left.isRed() || (s = s.moveRedLeft()), s = s.copy(null, null, null, s.left.remove(t, e), null);
    else {
      if (s.left.isRed() && (s = s.rotateRight()), s.right.isEmpty() || s.right.isRed() || s.right.left.isRed() || (s = s.moveRedRight()), 0 === e(t, s.key)) {
        if (s.right.isEmpty())
          return Gt.EMPTY;
        n = s.right.min(), s = s.copy(n.key, n.value, null, null, s.right.removeMin());
      }
      s = s.copy(null, null, null, null, s.right.remove(t, e));
    }
    return s.fixUp();
  }
  isRed() {
    return this.color;
  }
  fixUp() {
    let t = this;
    return t.right.isRed() && !t.left.isRed() && (t = t.rotateLeft()), t.left.isRed() && t.left.left.isRed() && (t = t.rotateRight()), t.left.isRed() && t.right.isRed() && (t = t.colorFlip()), t;
  }
  moveRedLeft() {
    let t = this.colorFlip();
    return t.right.left.isRed() && (t = t.copy(null, null, null, null, t.right.rotateRight()), t = t.rotateLeft(), t = t.colorFlip()), t;
  }
  moveRedRight() {
    let t = this.colorFlip();
    return t.left.left.isRed() && (t = t.rotateRight(), t = t.colorFlip()), t;
  }
  rotateLeft() {
    const t = this.copy(null, null, Gt.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, t, null);
  }
  rotateRight() {
    const t = this.copy(null, null, Gt.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, t);
  }
  colorFlip() {
    const t = this.left.copy(null, null, !this.left.color, null, null), e = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, t, e);
  }
  checkMaxDepth() {
    const t = this.check();
    return Math.pow(2, t) <= this.size + 1;
  }
  check() {
    if (this.isRed() && this.left.isRed())
      throw L();
    if (this.right.isRed())
      throw L();
    const t = this.left.check();
    if (t !== this.right.check())
      throw L();
    return t + (this.isRed() ? 0 : 1);
  }
};
Gt.EMPTY = null, Gt.RED = true, Gt.BLACK = false;
Gt.EMPTY = new class {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw L();
  }
  get value() {
    throw L();
  }
  get color() {
    throw L();
  }
  get left() {
    throw L();
  }
  get right() {
    throw L();
  }
  copy(t, e, n, s, i) {
    return this;
  }
  insert(t, e, n) {
    return new Gt(t, e);
  }
  remove(t, e) {
    return this;
  }
  isEmpty() {
    return true;
  }
  inorderTraversal(t) {
    return false;
  }
  reverseTraversal(t) {
    return false;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return false;
  }
  checkMaxDepth() {
    return true;
  }
  check() {
    return 0;
  }
}();
var Qt = class {
  constructor(t) {
    this.comparator = t, this.data = new qt(this.comparator);
  }
  has(t) {
    return null !== this.data.get(t);
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(t) {
    return this.data.indexOf(t);
  }
  forEach(t) {
    this.data.inorderTraversal((e, n) => (t(e), false));
  }
  forEachInRange(t, e) {
    const n = this.data.getIteratorFrom(t[0]);
    for (; n.hasNext(); ) {
      const s = n.getNext();
      if (this.comparator(s.key, t[1]) >= 0)
        return;
      e(s.key);
    }
  }
  forEachWhile(t, e) {
    let n;
    for (n = void 0 !== e ? this.data.getIteratorFrom(e) : this.data.getIterator(); n.hasNext(); ) {
      if (!t(n.getNext().key))
        return;
    }
  }
  firstAfterOrEqual(t) {
    const e = this.data.getIteratorFrom(t);
    return e.hasNext() ? e.getNext().key : null;
  }
  getIterator() {
    return new jt(this.data.getIterator());
  }
  getIteratorFrom(t) {
    return new jt(this.data.getIteratorFrom(t));
  }
  add(t) {
    return this.copy(this.data.remove(t).insert(t, true));
  }
  delete(t) {
    return this.has(t) ? this.copy(this.data.remove(t)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(t) {
    let e = this;
    return e.size < t.size && (e = t, t = this), t.forEach((t2) => {
      e = e.add(t2);
    }), e;
  }
  isEqual(t) {
    if (!(t instanceof Qt))
      return false;
    if (this.size !== t.size)
      return false;
    const e = this.data.getIterator(), n = t.data.getIterator();
    for (; e.hasNext(); ) {
      const t2 = e.getNext().key, s = n.getNext().key;
      if (0 !== this.comparator(t2, s))
        return false;
    }
    return true;
  }
  toArray() {
    const t = [];
    return this.forEach((e) => {
      t.push(e);
    }), t;
  }
  toString() {
    const t = [];
    return this.forEach((e) => t.push(e)), "SortedSet(" + t.toString() + ")";
  }
  copy(t) {
    const e = new Qt(this.comparator);
    return e.data = t, e;
  }
};
var jt = class {
  constructor(t) {
    this.iter = t;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
};
function Wt(t) {
  return t.hasNext() ? t.getNext() : void 0;
}
var zt = class {
  constructor(t) {
    this.fields = t, t.sort(ft.comparator);
  }
  static empty() {
    return new zt([]);
  }
  unionWith(t) {
    let e = new Qt(ft.comparator);
    for (const t2 of this.fields)
      e = e.add(t2);
    for (const n of t)
      e = e.add(n);
    return new zt(e.toArray());
  }
  covers(t) {
    for (const e of this.fields)
      if (e.isPrefixOf(t))
        return true;
    return false;
  }
  isEqual(t) {
    return rt(this.fields, t.fields, (t2, e) => t2.isEqual(e));
  }
};
function Ht() {
  return "undefined" != typeof atob;
}
var Jt = class {
  constructor(t) {
    this.binaryString = t;
  }
  static fromBase64String(t) {
    const e = atob(t);
    return new Jt(e);
  }
  static fromUint8Array(t) {
    const e = function(t2) {
      let e2 = "";
      for (let n = 0; n < t2.length; ++n)
        e2 += String.fromCharCode(t2[n]);
      return e2;
    }(t);
    return new Jt(e);
  }
  [Symbol.iterator]() {
    let t = 0;
    return {
      next: () => t < this.binaryString.length ? {
        value: this.binaryString.charCodeAt(t++),
        done: false
      } : {
        value: void 0,
        done: true
      }
    };
  }
  toBase64() {
    return t = this.binaryString, btoa(t);
    var t;
  }
  toUint8Array() {
    return function(t) {
      const e = new Uint8Array(t.length);
      for (let n = 0; n < t.length; n++)
        e[n] = t.charCodeAt(n);
      return e;
    }(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(t) {
    return it(this.binaryString, t.binaryString);
  }
  isEqual(t) {
    return this.binaryString === t.binaryString;
  }
};
Jt.EMPTY_BYTE_STRING = new Jt("");
var Yt = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function Xt(t) {
  if (U(!!t), "string" == typeof t) {
    let e = 0;
    const n = Yt.exec(t);
    if (U(!!n), n[1]) {
      let t2 = n[1];
      t2 = (t2 + "000000000").substr(0, 9), e = Number(t2);
    }
    const s = new Date(t);
    return {
      seconds: Math.floor(s.getTime() / 1e3),
      nanos: e
    };
  }
  return {
    seconds: Zt(t.seconds),
    nanos: Zt(t.nanos)
  };
}
function Zt(t) {
  return "number" == typeof t ? t : "string" == typeof t ? Number(t) : 0;
}
function te(t) {
  return "string" == typeof t ? Jt.fromBase64String(t) : Jt.fromUint8Array(t);
}
function ee(t) {
  var e, n;
  return "server_timestamp" === (null === (n = ((null === (e = null == t ? void 0 : t.mapValue) || void 0 === e ? void 0 : e.fields) || {}).__type__) || void 0 === n ? void 0 : n.stringValue);
}
function ne(t) {
  const e = t.mapValue.fields.__previous_value__;
  return ee(e) ? ne(e) : e;
}
function se(t) {
  const e = Xt(t.mapValue.fields.__local_write_time__.timestampValue);
  return new ut(e.seconds, e.nanos);
}
var ie = class {
  constructor(t, e, n, s, i, r, o, u) {
    this.databaseId = t, this.appId = e, this.persistenceKey = n, this.host = s, this.ssl = i, this.forceLongPolling = r, this.autoDetectLongPolling = o, this.useFetchStreams = u;
  }
};
var re = class {
  constructor(t, e) {
    this.projectId = t, this.database = e || "(default)";
  }
  static empty() {
    return new re("", "");
  }
  get isDefaultDatabase() {
    return "(default)" === this.database;
  }
  isEqual(t) {
    return t instanceof re && t.projectId === this.projectId && t.database === this.database;
  }
};
function oe(t) {
  return null == t;
}
function ue(t) {
  return 0 === t && 1 / t == -1 / 0;
}
function ce(t) {
  return "number" == typeof t && Number.isInteger(t) && !ue(t) && t <= Number.MAX_SAFE_INTEGER && t >= Number.MIN_SAFE_INTEGER;
}
var ae = {
  mapValue: {
    fields: {
      __type__: {
        stringValue: "__max__"
      }
    }
  }
};
var he = {
  nullValue: "NULL_VALUE"
};
function le(t) {
  return "nullValue" in t ? 0 : "booleanValue" in t ? 1 : "integerValue" in t || "doubleValue" in t ? 2 : "timestampValue" in t ? 3 : "stringValue" in t ? 5 : "bytesValue" in t ? 6 : "referenceValue" in t ? 7 : "geoPointValue" in t ? 8 : "arrayValue" in t ? 9 : "mapValue" in t ? ee(t) ? 4 : be(t) ? 9007199254740991 : 10 : L();
}
function fe(t, e) {
  if (t === e)
    return true;
  const n = le(t);
  if (n !== le(e))
    return false;
  switch (n) {
    case 0:
    case 9007199254740991:
      return true;
    case 1:
      return t.booleanValue === e.booleanValue;
    case 4:
      return se(t).isEqual(se(e));
    case 3:
      return function(t2, e2) {
        if ("string" == typeof t2.timestampValue && "string" == typeof e2.timestampValue && t2.timestampValue.length === e2.timestampValue.length)
          return t2.timestampValue === e2.timestampValue;
        const n2 = Xt(t2.timestampValue), s = Xt(e2.timestampValue);
        return n2.seconds === s.seconds && n2.nanos === s.nanos;
      }(t, e);
    case 5:
      return t.stringValue === e.stringValue;
    case 6:
      return function(t2, e2) {
        return te(t2.bytesValue).isEqual(te(e2.bytesValue));
      }(t, e);
    case 7:
      return t.referenceValue === e.referenceValue;
    case 8:
      return function(t2, e2) {
        return Zt(t2.geoPointValue.latitude) === Zt(e2.geoPointValue.latitude) && Zt(t2.geoPointValue.longitude) === Zt(e2.geoPointValue.longitude);
      }(t, e);
    case 2:
      return function(t2, e2) {
        if ("integerValue" in t2 && "integerValue" in e2)
          return Zt(t2.integerValue) === Zt(e2.integerValue);
        if ("doubleValue" in t2 && "doubleValue" in e2) {
          const n2 = Zt(t2.doubleValue), s = Zt(e2.doubleValue);
          return n2 === s ? ue(n2) === ue(s) : isNaN(n2) && isNaN(s);
        }
        return false;
      }(t, e);
    case 9:
      return rt(t.arrayValue.values || [], e.arrayValue.values || [], fe);
    case 10:
      return function(t2, e2) {
        const n2 = t2.mapValue.fields || {}, s = e2.mapValue.fields || {};
        if (Bt(n2) !== Bt(s))
          return false;
        for (const t3 in n2)
          if (n2.hasOwnProperty(t3) && (void 0 === s[t3] || !fe(n2[t3], s[t3])))
            return false;
        return true;
      }(t, e);
    default:
      return L();
  }
}
function de(t, e) {
  return void 0 !== (t.values || []).find((t2) => fe(t2, e));
}
function _e(t, e) {
  if (t === e)
    return 0;
  const n = le(t), s = le(e);
  if (n !== s)
    return it(n, s);
  switch (n) {
    case 0:
    case 9007199254740991:
      return 0;
    case 1:
      return it(t.booleanValue, e.booleanValue);
    case 2:
      return function(t2, e2) {
        const n2 = Zt(t2.integerValue || t2.doubleValue), s2 = Zt(e2.integerValue || e2.doubleValue);
        return n2 < s2 ? -1 : n2 > s2 ? 1 : n2 === s2 ? 0 : isNaN(n2) ? isNaN(s2) ? 0 : -1 : 1;
      }(t, e);
    case 3:
      return we(t.timestampValue, e.timestampValue);
    case 4:
      return we(se(t), se(e));
    case 5:
      return it(t.stringValue, e.stringValue);
    case 6:
      return function(t2, e2) {
        const n2 = te(t2), s2 = te(e2);
        return n2.compareTo(s2);
      }(t.bytesValue, e.bytesValue);
    case 7:
      return function(t2, e2) {
        const n2 = t2.split("/"), s2 = e2.split("/");
        for (let t3 = 0; t3 < n2.length && t3 < s2.length; t3++) {
          const e3 = it(n2[t3], s2[t3]);
          if (0 !== e3)
            return e3;
        }
        return it(n2.length, s2.length);
      }(t.referenceValue, e.referenceValue);
    case 8:
      return function(t2, e2) {
        const n2 = it(Zt(t2.latitude), Zt(e2.latitude));
        if (0 !== n2)
          return n2;
        return it(Zt(t2.longitude), Zt(e2.longitude));
      }(t.geoPointValue, e.geoPointValue);
    case 9:
      return function(t2, e2) {
        const n2 = t2.values || [], s2 = e2.values || [];
        for (let t3 = 0; t3 < n2.length && t3 < s2.length; ++t3) {
          const e3 = _e(n2[t3], s2[t3]);
          if (e3)
            return e3;
        }
        return it(n2.length, s2.length);
      }(t.arrayValue, e.arrayValue);
    case 10:
      return function(t2, e2) {
        if (t2 === ae.mapValue && e2 === ae.mapValue)
          return 0;
        if (t2 === ae.mapValue)
          return 1;
        if (e2 === ae.mapValue)
          return -1;
        const n2 = t2.fields || {}, s2 = Object.keys(n2), i = e2.fields || {}, r = Object.keys(i);
        s2.sort(), r.sort();
        for (let t3 = 0; t3 < s2.length && t3 < r.length; ++t3) {
          const e3 = it(s2[t3], r[t3]);
          if (0 !== e3)
            return e3;
          const o = _e(n2[s2[t3]], i[r[t3]]);
          if (0 !== o)
            return o;
        }
        return it(s2.length, r.length);
      }(t.mapValue, e.mapValue);
    default:
      throw L();
  }
}
function we(t, e) {
  if ("string" == typeof t && "string" == typeof e && t.length === e.length)
    return it(t, e);
  const n = Xt(t), s = Xt(e), i = it(n.seconds, s.seconds);
  return 0 !== i ? i : it(n.nanos, s.nanos);
}
function me(t) {
  return ge(t);
}
function ge(t) {
  return "nullValue" in t ? "null" : "booleanValue" in t ? "" + t.booleanValue : "integerValue" in t ? "" + t.integerValue : "doubleValue" in t ? "" + t.doubleValue : "timestampValue" in t ? function(t2) {
    const e2 = Xt(t2);
    return `time(${e2.seconds},${e2.nanos})`;
  }(t.timestampValue) : "stringValue" in t ? t.stringValue : "bytesValue" in t ? te(t.bytesValue).toBase64() : "referenceValue" in t ? (n = t.referenceValue, dt.fromName(n).toString()) : "geoPointValue" in t ? `geo(${(e = t.geoPointValue).latitude},${e.longitude})` : "arrayValue" in t ? function(t2) {
    let e2 = "[", n2 = true;
    for (const s of t2.values || [])
      n2 ? n2 = false : e2 += ",", e2 += ge(s);
    return e2 + "]";
  }(t.arrayValue) : "mapValue" in t ? function(t2) {
    const e2 = Object.keys(t2.fields || {}).sort();
    let n2 = "{", s = true;
    for (const i of e2)
      s ? s = false : n2 += ",", n2 += `${i}:${ge(t2.fields[i])}`;
    return n2 + "}";
  }(t.mapValue) : L();
  var e, n;
}
function ye(t, e) {
  return {
    referenceValue: `projects/${t.projectId}/databases/${t.database}/documents/${e.path.canonicalString()}`
  };
}
function pe(t) {
  return !!t && "integerValue" in t;
}
function Ie(t) {
  return !!t && "arrayValue" in t;
}
function Te(t) {
  return !!t && "nullValue" in t;
}
function Ee(t) {
  return !!t && "doubleValue" in t && isNaN(Number(t.doubleValue));
}
function Ae(t) {
  return !!t && "mapValue" in t;
}
function Re(t) {
  if (t.geoPointValue)
    return {
      geoPointValue: Object.assign({}, t.geoPointValue)
    };
  if (t.timestampValue && "object" == typeof t.timestampValue)
    return {
      timestampValue: Object.assign({}, t.timestampValue)
    };
  if (t.mapValue) {
    const e = {
      mapValue: {
        fields: {}
      }
    };
    return Lt(t.mapValue.fields, (t2, n) => e.mapValue.fields[t2] = Re(n)), e;
  }
  if (t.arrayValue) {
    const e = {
      arrayValue: {
        values: []
      }
    };
    for (let n = 0; n < (t.arrayValue.values || []).length; ++n)
      e.arrayValue.values[n] = Re(t.arrayValue.values[n]);
    return e;
  }
  return Object.assign({}, t);
}
function be(t) {
  return "__max__" === (((t.mapValue || {}).fields || {}).__type__ || {}).stringValue;
}
function Pe(t) {
  return "nullValue" in t ? he : "booleanValue" in t ? {
    booleanValue: false
  } : "integerValue" in t || "doubleValue" in t ? {
    doubleValue: NaN
  } : "timestampValue" in t ? {
    timestampValue: {
      seconds: Number.MIN_SAFE_INTEGER
    }
  } : "stringValue" in t ? {
    stringValue: ""
  } : "bytesValue" in t ? {
    bytesValue: ""
  } : "referenceValue" in t ? ye(re.empty(), dt.empty()) : "geoPointValue" in t ? {
    geoPointValue: {
      latitude: -90,
      longitude: -180
    }
  } : "arrayValue" in t ? {
    arrayValue: {}
  } : "mapValue" in t ? {
    mapValue: {}
  } : L();
}
function ve(t) {
  return "nullValue" in t ? {
    booleanValue: false
  } : "booleanValue" in t ? {
    doubleValue: NaN
  } : "integerValue" in t || "doubleValue" in t ? {
    timestampValue: {
      seconds: Number.MIN_SAFE_INTEGER
    }
  } : "timestampValue" in t ? {
    stringValue: ""
  } : "stringValue" in t ? {
    bytesValue: ""
  } : "bytesValue" in t ? ye(re.empty(), dt.empty()) : "referenceValue" in t ? {
    geoPointValue: {
      latitude: -90,
      longitude: -180
    }
  } : "geoPointValue" in t ? {
    arrayValue: {}
  } : "arrayValue" in t ? {
    mapValue: {}
  } : "mapValue" in t ? ae : L();
}
function Ve(t, e) {
  const n = _e(t.value, e.value);
  return 0 !== n ? n : t.inclusive && !e.inclusive ? -1 : !t.inclusive && e.inclusive ? 1 : 0;
}
function Se(t, e) {
  const n = _e(t.value, e.value);
  return 0 !== n ? n : t.inclusive && !e.inclusive ? 1 : !t.inclusive && e.inclusive ? -1 : 0;
}
var De = class {
  constructor(t) {
    this.value = t;
  }
  static empty() {
    return new De({
      mapValue: {}
    });
  }
  field(t) {
    if (t.isEmpty())
      return this.value;
    {
      let e = this.value;
      for (let n = 0; n < t.length - 1; ++n)
        if (e = (e.mapValue.fields || {})[t.get(n)], !Ae(e))
          return null;
      return e = (e.mapValue.fields || {})[t.lastSegment()], e || null;
    }
  }
  set(t, e) {
    this.getFieldsMap(t.popLast())[t.lastSegment()] = Re(e);
  }
  setAll(t) {
    let e = ft.emptyPath(), n = {}, s = [];
    t.forEach((t2, i2) => {
      if (!e.isImmediateParentOf(i2)) {
        const t3 = this.getFieldsMap(e);
        this.applyChanges(t3, n, s), n = {}, s = [], e = i2.popLast();
      }
      t2 ? n[i2.lastSegment()] = Re(t2) : s.push(i2.lastSegment());
    });
    const i = this.getFieldsMap(e);
    this.applyChanges(i, n, s);
  }
  delete(t) {
    const e = this.field(t.popLast());
    Ae(e) && e.mapValue.fields && delete e.mapValue.fields[t.lastSegment()];
  }
  isEqual(t) {
    return fe(this.value, t.value);
  }
  getFieldsMap(t) {
    let e = this.value;
    e.mapValue.fields || (e.mapValue = {
      fields: {}
    });
    for (let n = 0; n < t.length; ++n) {
      let s = e.mapValue.fields[t.get(n)];
      Ae(s) && s.mapValue.fields || (s = {
        mapValue: {
          fields: {}
        }
      }, e.mapValue.fields[t.get(n)] = s), e = s;
    }
    return e.mapValue.fields;
  }
  applyChanges(t, e, n) {
    Lt(e, (e2, n2) => t[e2] = n2);
    for (const e2 of n)
      delete t[e2];
  }
  clone() {
    return new De(Re(this.value));
  }
};
function Ce(t) {
  const e = [];
  return Lt(t.fields, (t2, n) => {
    const s = new ft([t2]);
    if (Ae(n)) {
      const t3 = Ce(n.mapValue).fields;
      if (0 === t3.length)
        e.push(s);
      else
        for (const n2 of t3)
          e.push(s.child(n2));
    } else
      e.push(s);
  }), new zt(e);
}
var xe = class {
  constructor(t, e, n, s, i, r) {
    this.key = t, this.documentType = e, this.version = n, this.readTime = s, this.data = i, this.documentState = r;
  }
  static newInvalidDocument(t) {
    return new xe(t, 0, ct.min(), ct.min(), De.empty(), 0);
  }
  static newFoundDocument(t, e, n) {
    return new xe(t, 1, e, ct.min(), n, 0);
  }
  static newNoDocument(t, e) {
    return new xe(t, 2, e, ct.min(), De.empty(), 0);
  }
  static newUnknownDocument(t, e) {
    return new xe(t, 3, e, ct.min(), De.empty(), 2);
  }
  convertToFoundDocument(t, e) {
    return this.version = t, this.documentType = 1, this.data = e, this.documentState = 0, this;
  }
  convertToNoDocument(t) {
    return this.version = t, this.documentType = 2, this.data = De.empty(), this.documentState = 0, this;
  }
  convertToUnknownDocument(t) {
    return this.version = t, this.documentType = 3, this.data = De.empty(), this.documentState = 2, this;
  }
  setHasCommittedMutations() {
    return this.documentState = 2, this;
  }
  setHasLocalMutations() {
    return this.documentState = 1, this.version = ct.min(), this;
  }
  setReadTime(t) {
    return this.readTime = t, this;
  }
  get hasLocalMutations() {
    return 1 === this.documentState;
  }
  get hasCommittedMutations() {
    return 2 === this.documentState;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return 0 !== this.documentType;
  }
  isFoundDocument() {
    return 1 === this.documentType;
  }
  isNoDocument() {
    return 2 === this.documentType;
  }
  isUnknownDocument() {
    return 3 === this.documentType;
  }
  isEqual(t) {
    return t instanceof xe && this.key.isEqual(t.key) && this.version.isEqual(t.version) && this.documentType === t.documentType && this.documentState === t.documentState && this.data.isEqual(t.data);
  }
  mutableCopy() {
    return new xe(this.key, this.documentType, this.version, this.readTime, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
};
var Ne = class {
  constructor(t, e = null, n = [], s = [], i = null, r = null, o = null) {
    this.path = t, this.collectionGroup = e, this.orderBy = n, this.filters = s, this.limit = i, this.startAt = r, this.endAt = o, this.ut = null;
  }
};
function ke(t, e = null, n = [], s = [], i = null, r = null, o = null) {
  return new Ne(t, e, n, s, i, r, o);
}
function Oe(t) {
  const e = K(t);
  if (null === e.ut) {
    let t2 = e.path.canonicalString();
    null !== e.collectionGroup && (t2 += "|cg:" + e.collectionGroup), t2 += "|f:", t2 += e.filters.map((t3) => {
      return (e2 = t3).field.canonicalString() + e2.op.toString() + me(e2.value);
      var e2;
    }).join(","), t2 += "|ob:", t2 += e.orderBy.map((t3) => function(t4) {
      return t4.field.canonicalString() + t4.dir;
    }(t3)).join(","), oe(e.limit) || (t2 += "|l:", t2 += e.limit), e.startAt && (t2 += "|lb:", t2 += e.startAt.inclusive ? "b:" : "a:", t2 += e.startAt.position.map((t3) => me(t3)).join(",")), e.endAt && (t2 += "|ub:", t2 += e.endAt.inclusive ? "a:" : "b:", t2 += e.endAt.position.map((t3) => me(t3)).join(",")), e.ut = t2;
  }
  return e.ut;
}
function Me(t) {
  let e = t.path.canonicalString();
  return null !== t.collectionGroup && (e += " collectionGroup=" + t.collectionGroup), t.filters.length > 0 && (e += `, filters: [${t.filters.map((t2) => {
    return `${(e2 = t2).field.canonicalString()} ${e2.op} ${me(e2.value)}`;
    var e2;
  }).join(", ")}]`), oe(t.limit) || (e += ", limit: " + t.limit), t.orderBy.length > 0 && (e += `, orderBy: [${t.orderBy.map((t2) => function(t3) {
    return `${t3.field.canonicalString()} (${t3.dir})`;
  }(t2)).join(", ")}]`), t.startAt && (e += ", startAt: ", e += t.startAt.inclusive ? "b:" : "a:", e += t.startAt.position.map((t2) => me(t2)).join(",")), t.endAt && (e += ", endAt: ", e += t.endAt.inclusive ? "a:" : "b:", e += t.endAt.position.map((t2) => me(t2)).join(",")), `Target(${e})`;
}
function Fe(t, e) {
  if (t.limit !== e.limit)
    return false;
  if (t.orderBy.length !== e.orderBy.length)
    return false;
  for (let n2 = 0; n2 < t.orderBy.length; n2++)
    if (!Ze(t.orderBy[n2], e.orderBy[n2]))
      return false;
  if (t.filters.length !== e.filters.length)
    return false;
  for (let i = 0; i < t.filters.length; i++)
    if (n = t.filters[i], s = e.filters[i], n.op !== s.op || !n.field.isEqual(s.field) || !fe(n.value, s.value))
      return false;
  var n, s;
  return t.collectionGroup === e.collectionGroup && (!!t.path.isEqual(e.path) && (!!en(t.startAt, e.startAt) && en(t.endAt, e.endAt)));
}
function $e(t) {
  return dt.isDocumentKey(t.path) && null === t.collectionGroup && 0 === t.filters.length;
}
function Be(t, e) {
  return t.filters.filter((t2) => t2 instanceof qe && t2.field.isEqual(e));
}
function Le(t, e, n) {
  let s = he, i = true;
  for (const n2 of Be(t, e)) {
    let t2 = he, e2 = true;
    switch (n2.op) {
      case "<":
      case "<=":
        t2 = Pe(n2.value);
        break;
      case "==":
      case "in":
      case ">=":
        t2 = n2.value;
        break;
      case ">":
        t2 = n2.value, e2 = false;
        break;
      case "!=":
      case "not-in":
        t2 = he;
    }
    Ve({
      value: s,
      inclusive: i
    }, {
      value: t2,
      inclusive: e2
    }) < 0 && (s = t2, i = e2);
  }
  if (null !== n)
    for (let r = 0; r < t.orderBy.length; ++r) {
      if (t.orderBy[r].field.isEqual(e)) {
        const t2 = n.position[r];
        Ve({
          value: s,
          inclusive: i
        }, {
          value: t2,
          inclusive: n.inclusive
        }) < 0 && (s = t2, i = n.inclusive);
        break;
      }
    }
  return {
    value: s,
    inclusive: i
  };
}
function Ue(t, e, n) {
  let s = ae, i = true;
  for (const n2 of Be(t, e)) {
    let t2 = ae, e2 = true;
    switch (n2.op) {
      case ">=":
      case ">":
        t2 = ve(n2.value), e2 = false;
        break;
      case "==":
      case "in":
      case "<=":
        t2 = n2.value;
        break;
      case "<":
        t2 = n2.value, e2 = false;
        break;
      case "!=":
      case "not-in":
        t2 = ae;
    }
    Se({
      value: s,
      inclusive: i
    }, {
      value: t2,
      inclusive: e2
    }) > 0 && (s = t2, i = e2);
  }
  if (null !== n)
    for (let r = 0; r < t.orderBy.length; ++r) {
      if (t.orderBy[r].field.isEqual(e)) {
        const t2 = n.position[r];
        Se({
          value: s,
          inclusive: i
        }, {
          value: t2,
          inclusive: n.inclusive
        }) > 0 && (s = t2, i = n.inclusive);
        break;
      }
    }
  return {
    value: s,
    inclusive: i
  };
}
var qe = class extends class {
} {
  constructor(t, e, n) {
    super(), this.field = t, this.op = e, this.value = n;
  }
  static create(t, e, n) {
    return t.isKeyField() ? "in" === e || "not-in" === e ? this.ct(t, e, n) : new Ke(t, e, n) : "array-contains" === e ? new We(t, n) : "in" === e ? new ze(t, n) : "not-in" === e ? new He(t, n) : "array-contains-any" === e ? new Je(t, n) : new qe(t, e, n);
  }
  static ct(t, e, n) {
    return "in" === e ? new Ge(t, n) : new Qe(t, n);
  }
  matches(t) {
    const e = t.data.field(this.field);
    return "!=" === this.op ? null !== e && this.at(_e(e, this.value)) : null !== e && le(this.value) === le(e) && this.at(_e(e, this.value));
  }
  at(t) {
    switch (this.op) {
      case "<":
        return t < 0;
      case "<=":
        return t <= 0;
      case "==":
        return 0 === t;
      case "!=":
        return 0 !== t;
      case ">":
        return t > 0;
      case ">=":
        return t >= 0;
      default:
        return L();
    }
  }
  ht() {
    return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0;
  }
};
var Ke = class extends qe {
  constructor(t, e, n) {
    super(t, e, n), this.key = dt.fromName(n.referenceValue);
  }
  matches(t) {
    const e = dt.comparator(t.key, this.key);
    return this.at(e);
  }
};
var Ge = class extends qe {
  constructor(t, e) {
    super(t, "in", e), this.keys = je("in", e);
  }
  matches(t) {
    return this.keys.some((e) => e.isEqual(t.key));
  }
};
var Qe = class extends qe {
  constructor(t, e) {
    super(t, "not-in", e), this.keys = je("not-in", e);
  }
  matches(t) {
    return !this.keys.some((e) => e.isEqual(t.key));
  }
};
function je(t, e) {
  var n;
  return ((null === (n = e.arrayValue) || void 0 === n ? void 0 : n.values) || []).map((t2) => dt.fromName(t2.referenceValue));
}
var We = class extends qe {
  constructor(t, e) {
    super(t, "array-contains", e);
  }
  matches(t) {
    const e = t.data.field(this.field);
    return Ie(e) && de(e.arrayValue, this.value);
  }
};
var ze = class extends qe {
  constructor(t, e) {
    super(t, "in", e);
  }
  matches(t) {
    const e = t.data.field(this.field);
    return null !== e && de(this.value.arrayValue, e);
  }
};
var He = class extends qe {
  constructor(t, e) {
    super(t, "not-in", e);
  }
  matches(t) {
    if (de(this.value.arrayValue, {
      nullValue: "NULL_VALUE"
    }))
      return false;
    const e = t.data.field(this.field);
    return null !== e && !de(this.value.arrayValue, e);
  }
};
var Je = class extends qe {
  constructor(t, e) {
    super(t, "array-contains-any", e);
  }
  matches(t) {
    const e = t.data.field(this.field);
    return !(!Ie(e) || !e.arrayValue.values) && e.arrayValue.values.some((t2) => de(this.value.arrayValue, t2));
  }
};
var Ye = class {
  constructor(t, e) {
    this.position = t, this.inclusive = e;
  }
};
var Xe = class {
  constructor(t, e = "asc") {
    this.field = t, this.dir = e;
  }
};
function Ze(t, e) {
  return t.dir === e.dir && t.field.isEqual(e.field);
}
function tn(t, e, n) {
  let s = 0;
  for (let i = 0; i < t.position.length; i++) {
    const r = e[i], o = t.position[i];
    if (r.field.isKeyField())
      s = dt.comparator(dt.fromName(o.referenceValue), n.key);
    else {
      s = _e(o, n.data.field(r.field));
    }
    if ("desc" === r.dir && (s *= -1), 0 !== s)
      break;
  }
  return s;
}
function en(t, e) {
  if (null === t)
    return null === e;
  if (null === e)
    return false;
  if (t.inclusive !== e.inclusive || t.position.length !== e.position.length)
    return false;
  for (let n = 0; n < t.position.length; n++) {
    if (!fe(t.position[n], e.position[n]))
      return false;
  }
  return true;
}
var nn = class {
  constructor(t, e = null, n = [], s = [], i = null, r = "F", o = null, u = null) {
    this.path = t, this.collectionGroup = e, this.explicitOrderBy = n, this.filters = s, this.limit = i, this.limitType = r, this.startAt = o, this.endAt = u, this.lt = null, this.ft = null, this.startAt, this.endAt;
  }
};
function sn(t, e, n, s, i, r, o, u) {
  return new nn(t, e, n, s, i, r, o, u);
}
function rn(t) {
  return new nn(t);
}
function on(t) {
  return 0 === t.filters.length && null === t.limit && null == t.startAt && null == t.endAt && (0 === t.explicitOrderBy.length || 1 === t.explicitOrderBy.length && t.explicitOrderBy[0].field.isKeyField());
}
function un(t) {
  return t.explicitOrderBy.length > 0 ? t.explicitOrderBy[0].field : null;
}
function cn(t) {
  for (const e of t.filters)
    if (e.ht())
      return e.field;
  return null;
}
function an(t) {
  return null !== t.collectionGroup;
}
function hn(t) {
  const e = K(t);
  if (null === e.lt) {
    e.lt = [];
    const t2 = cn(e), n = un(e);
    if (null !== t2 && null === n)
      t2.isKeyField() || e.lt.push(new Xe(t2)), e.lt.push(new Xe(ft.keyField(), "asc"));
    else {
      let t3 = false;
      for (const n2 of e.explicitOrderBy)
        e.lt.push(n2), n2.field.isKeyField() && (t3 = true);
      if (!t3) {
        const t4 = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
        e.lt.push(new Xe(ft.keyField(), t4));
      }
    }
  }
  return e.lt;
}
function ln(t) {
  const e = K(t);
  if (!e.ft)
    if ("F" === e.limitType)
      e.ft = ke(e.path, e.collectionGroup, hn(e), e.filters, e.limit, e.startAt, e.endAt);
    else {
      const t2 = [];
      for (const n2 of hn(e)) {
        const e2 = "desc" === n2.dir ? "asc" : "desc";
        t2.push(new Xe(n2.field, e2));
      }
      const n = e.endAt ? new Ye(e.endAt.position, e.endAt.inclusive) : null, s = e.startAt ? new Ye(e.startAt.position, e.startAt.inclusive) : null;
      e.ft = ke(e.path, e.collectionGroup, t2, e.filters, e.limit, n, s);
    }
  return e.ft;
}
function fn(t, e, n) {
  return new nn(t.path, t.collectionGroup, t.explicitOrderBy.slice(), t.filters.slice(), e, n, t.startAt, t.endAt);
}
function dn(t, e) {
  return Fe(ln(t), ln(e)) && t.limitType === e.limitType;
}
function _n(t) {
  return `${Oe(ln(t))}|lt:${t.limitType}`;
}
function wn(t) {
  return `Query(target=${Me(ln(t))}; limitType=${t.limitType})`;
}
function mn(t, e) {
  return e.isFoundDocument() && function(t2, e2) {
    const n = e2.key.path;
    return null !== t2.collectionGroup ? e2.key.hasCollectionId(t2.collectionGroup) && t2.path.isPrefixOf(n) : dt.isDocumentKey(t2.path) ? t2.path.isEqual(n) : t2.path.isImmediateParentOf(n);
  }(t, e) && function(t2, e2) {
    for (const n of t2.explicitOrderBy)
      if (!n.field.isKeyField() && null === e2.data.field(n.field))
        return false;
    return true;
  }(t, e) && function(t2, e2) {
    for (const n of t2.filters)
      if (!n.matches(e2))
        return false;
    return true;
  }(t, e) && function(t2, e2) {
    if (t2.startAt && !function(t3, e3, n) {
      const s = tn(t3, e3, n);
      return t3.inclusive ? s <= 0 : s < 0;
    }(t2.startAt, hn(t2), e2))
      return false;
    if (t2.endAt && !function(t3, e3, n) {
      const s = tn(t3, e3, n);
      return t3.inclusive ? s >= 0 : s > 0;
    }(t2.endAt, hn(t2), e2))
      return false;
    return true;
  }(t, e);
}
function gn(t) {
  return t.collectionGroup || (t.path.length % 2 == 1 ? t.path.lastSegment() : t.path.get(t.path.length - 2));
}
function yn(t) {
  return (e, n) => {
    let s = false;
    for (const i of hn(t)) {
      const t2 = pn(i, e, n);
      if (0 !== t2)
        return t2;
      s = s || i.field.isKeyField();
    }
    return 0;
  };
}
function pn(t, e, n) {
  const s = t.field.isKeyField() ? dt.comparator(e.key, n.key) : function(t2, e2, n2) {
    const s2 = e2.data.field(t2), i = n2.data.field(t2);
    return null !== s2 && null !== i ? _e(s2, i) : L();
  }(t.field, e, n);
  switch (t.dir) {
    case "asc":
      return s;
    case "desc":
      return -1 * s;
    default:
      return L();
  }
}
function In(t, e) {
  if (t.dt) {
    if (isNaN(e))
      return {
        doubleValue: "NaN"
      };
    if (e === 1 / 0)
      return {
        doubleValue: "Infinity"
      };
    if (e === -1 / 0)
      return {
        doubleValue: "-Infinity"
      };
  }
  return {
    doubleValue: ue(e) ? "-0" : e
  };
}
function Tn(t) {
  return {
    integerValue: "" + t
  };
}
function En(t, e) {
  return ce(e) ? Tn(e) : In(t, e);
}
var An = class {
  constructor() {
    this._ = void 0;
  }
};
function Rn(t, e, n) {
  return t instanceof vn ? function(t2, e2) {
    const n2 = {
      fields: {
        __type__: {
          stringValue: "server_timestamp"
        },
        __local_write_time__: {
          timestampValue: {
            seconds: t2.seconds,
            nanos: t2.nanoseconds
          }
        }
      }
    };
    return e2 && (n2.fields.__previous_value__ = e2), {
      mapValue: n2
    };
  }(n, e) : t instanceof Vn ? Sn(t, e) : t instanceof Dn ? Cn(t, e) : function(t2, e2) {
    const n2 = Pn(t2, e2), s = Nn(n2) + Nn(t2._t);
    return pe(n2) && pe(t2._t) ? Tn(s) : In(t2.wt, s);
  }(t, e);
}
function bn(t, e, n) {
  return t instanceof Vn ? Sn(t, e) : t instanceof Dn ? Cn(t, e) : n;
}
function Pn(t, e) {
  return t instanceof xn ? pe(n = e) || function(t2) {
    return !!t2 && "doubleValue" in t2;
  }(n) ? e : {
    integerValue: 0
  } : null;
  var n;
}
var vn = class extends An {
};
var Vn = class extends An {
  constructor(t) {
    super(), this.elements = t;
  }
};
function Sn(t, e) {
  const n = kn(e);
  for (const e2 of t.elements)
    n.some((t2) => fe(t2, e2)) || n.push(e2);
  return {
    arrayValue: {
      values: n
    }
  };
}
var Dn = class extends An {
  constructor(t) {
    super(), this.elements = t;
  }
};
function Cn(t, e) {
  let n = kn(e);
  for (const e2 of t.elements)
    n = n.filter((t2) => !fe(t2, e2));
  return {
    arrayValue: {
      values: n
    }
  };
}
var xn = class extends An {
  constructor(t, e) {
    super(), this.wt = t, this._t = e;
  }
};
function Nn(t) {
  return Zt(t.integerValue || t.doubleValue);
}
function kn(t) {
  return Ie(t) && t.arrayValue.values ? t.arrayValue.values.slice() : [];
}
var On = class {
  constructor(t, e) {
    this.field = t, this.transform = e;
  }
};
function Mn(t, e) {
  return t.field.isEqual(e.field) && function(t2, e2) {
    return t2 instanceof Vn && e2 instanceof Vn || t2 instanceof Dn && e2 instanceof Dn ? rt(t2.elements, e2.elements, fe) : t2 instanceof xn && e2 instanceof xn ? fe(t2._t, e2._t) : t2 instanceof vn && e2 instanceof vn;
  }(t.transform, e.transform);
}
var Fn = class {
  constructor(t, e) {
    this.version = t, this.transformResults = e;
  }
};
var $n = class {
  constructor(t, e) {
    this.updateTime = t, this.exists = e;
  }
  static none() {
    return new $n();
  }
  static exists(t) {
    return new $n(void 0, t);
  }
  static updateTime(t) {
    return new $n(t);
  }
  get isNone() {
    return void 0 === this.updateTime && void 0 === this.exists;
  }
  isEqual(t) {
    return this.exists === t.exists && (this.updateTime ? !!t.updateTime && this.updateTime.isEqual(t.updateTime) : !t.updateTime);
  }
};
function Bn(t, e) {
  return void 0 !== t.updateTime ? e.isFoundDocument() && e.version.isEqual(t.updateTime) : void 0 === t.exists || t.exists === e.isFoundDocument();
}
var Ln = class {
};
function Un(t, e) {
  if (!t.hasLocalMutations || e && 0 === e.fields.length)
    return null;
  if (null === e)
    return t.isNoDocument() ? new Yn(t.key, $n.none()) : new jn(t.key, t.data, $n.none());
  {
    const n = t.data, s = De.empty();
    let i = new Qt(ft.comparator);
    for (let t2 of e.fields)
      if (!i.has(t2)) {
        let e2 = n.field(t2);
        null === e2 && t2.length > 1 && (t2 = t2.popLast(), e2 = n.field(t2)), null === e2 ? s.delete(t2) : s.set(t2, e2), i = i.add(t2);
      }
    return new Wn(t.key, s, new zt(i.toArray()), $n.none());
  }
}
function qn(t, e, n) {
  t instanceof jn ? function(t2, e2, n2) {
    const s = t2.value.clone(), i = Hn(t2.fieldTransforms, e2, n2.transformResults);
    s.setAll(i), e2.convertToFoundDocument(n2.version, s).setHasCommittedMutations();
  }(t, e, n) : t instanceof Wn ? function(t2, e2, n2) {
    if (!Bn(t2.precondition, e2))
      return void e2.convertToUnknownDocument(n2.version);
    const s = Hn(t2.fieldTransforms, e2, n2.transformResults), i = e2.data;
    i.setAll(zn(t2)), i.setAll(s), e2.convertToFoundDocument(n2.version, i).setHasCommittedMutations();
  }(t, e, n) : function(t2, e2, n2) {
    e2.convertToNoDocument(n2.version).setHasCommittedMutations();
  }(0, e, n);
}
function Kn(t, e, n, s) {
  return t instanceof jn ? function(t2, e2, n2, s2) {
    if (!Bn(t2.precondition, e2))
      return n2;
    const i = t2.value.clone(), r = Jn(t2.fieldTransforms, s2, e2);
    return i.setAll(r), e2.convertToFoundDocument(e2.version, i).setHasLocalMutations(), null;
  }(t, e, n, s) : t instanceof Wn ? function(t2, e2, n2, s2) {
    if (!Bn(t2.precondition, e2))
      return n2;
    const i = Jn(t2.fieldTransforms, s2, e2), r = e2.data;
    if (r.setAll(zn(t2)), r.setAll(i), e2.convertToFoundDocument(e2.version, r).setHasLocalMutations(), null === n2)
      return null;
    return n2.unionWith(t2.fieldMask.fields).unionWith(t2.fieldTransforms.map((t3) => t3.field));
  }(t, e, n, s) : function(t2, e2, n2) {
    if (Bn(t2.precondition, e2))
      return e2.convertToNoDocument(e2.version).setHasLocalMutations(), null;
    return n2;
  }(t, e, n);
}
function Gn(t, e) {
  let n = null;
  for (const s of t.fieldTransforms) {
    const t2 = e.data.field(s.field), i = Pn(s.transform, t2 || null);
    null != i && (null === n && (n = De.empty()), n.set(s.field, i));
  }
  return n || null;
}
function Qn(t, e) {
  return t.type === e.type && (!!t.key.isEqual(e.key) && (!!t.precondition.isEqual(e.precondition) && (!!function(t2, e2) {
    return void 0 === t2 && void 0 === e2 || !(!t2 || !e2) && rt(t2, e2, (t3, e3) => Mn(t3, e3));
  }(t.fieldTransforms, e.fieldTransforms) && (0 === t.type ? t.value.isEqual(e.value) : 1 !== t.type || t.data.isEqual(e.data) && t.fieldMask.isEqual(e.fieldMask)))));
}
var jn = class extends Ln {
  constructor(t, e, n, s = []) {
    super(), this.key = t, this.value = e, this.precondition = n, this.fieldTransforms = s, this.type = 0;
  }
  getFieldMask() {
    return null;
  }
};
var Wn = class extends Ln {
  constructor(t, e, n, s, i = []) {
    super(), this.key = t, this.data = e, this.fieldMask = n, this.precondition = s, this.fieldTransforms = i, this.type = 1;
  }
  getFieldMask() {
    return this.fieldMask;
  }
};
function zn(t) {
  const e = /* @__PURE__ */ new Map();
  return t.fieldMask.fields.forEach((n) => {
    if (!n.isEmpty()) {
      const s = t.data.field(n);
      e.set(n, s);
    }
  }), e;
}
function Hn(t, e, n) {
  const s = /* @__PURE__ */ new Map();
  U(t.length === n.length);
  for (let i = 0; i < n.length; i++) {
    const r = t[i], o = r.transform, u = e.data.field(r.field);
    s.set(r.field, bn(o, u, n[i]));
  }
  return s;
}
function Jn(t, e, n) {
  const s = /* @__PURE__ */ new Map();
  for (const i of t) {
    const t2 = i.transform, r = n.data.field(i.field);
    s.set(i.field, Rn(t2, r, e));
  }
  return s;
}
var Yn = class extends Ln {
  constructor(t, e) {
    super(), this.key = t, this.precondition = e, this.type = 2, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
};
var Xn = class extends Ln {
  constructor(t, e) {
    super(), this.key = t, this.precondition = e, this.type = 3, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
};
var Zn = class {
  constructor(t) {
    this.count = t;
  }
};
var ts;
var es;
function ns(t) {
  switch (t) {
    default:
      return L();
    case G.CANCELLED:
    case G.UNKNOWN:
    case G.DEADLINE_EXCEEDED:
    case G.RESOURCE_EXHAUSTED:
    case G.INTERNAL:
    case G.UNAVAILABLE:
    case G.UNAUTHENTICATED:
      return false;
    case G.INVALID_ARGUMENT:
    case G.NOT_FOUND:
    case G.ALREADY_EXISTS:
    case G.PERMISSION_DENIED:
    case G.FAILED_PRECONDITION:
    case G.ABORTED:
    case G.OUT_OF_RANGE:
    case G.UNIMPLEMENTED:
    case G.DATA_LOSS:
      return true;
  }
}
function ss(t) {
  if (void 0 === t)
    return F("GRPC error has no .code"), G.UNKNOWN;
  switch (t) {
    case ts.OK:
      return G.OK;
    case ts.CANCELLED:
      return G.CANCELLED;
    case ts.UNKNOWN:
      return G.UNKNOWN;
    case ts.DEADLINE_EXCEEDED:
      return G.DEADLINE_EXCEEDED;
    case ts.RESOURCE_EXHAUSTED:
      return G.RESOURCE_EXHAUSTED;
    case ts.INTERNAL:
      return G.INTERNAL;
    case ts.UNAVAILABLE:
      return G.UNAVAILABLE;
    case ts.UNAUTHENTICATED:
      return G.UNAUTHENTICATED;
    case ts.INVALID_ARGUMENT:
      return G.INVALID_ARGUMENT;
    case ts.NOT_FOUND:
      return G.NOT_FOUND;
    case ts.ALREADY_EXISTS:
      return G.ALREADY_EXISTS;
    case ts.PERMISSION_DENIED:
      return G.PERMISSION_DENIED;
    case ts.FAILED_PRECONDITION:
      return G.FAILED_PRECONDITION;
    case ts.ABORTED:
      return G.ABORTED;
    case ts.OUT_OF_RANGE:
      return G.OUT_OF_RANGE;
    case ts.UNIMPLEMENTED:
      return G.UNIMPLEMENTED;
    case ts.DATA_LOSS:
      return G.DATA_LOSS;
    default:
      return L();
  }
}
(es = ts || (ts = {}))[es.OK = 0] = "OK", es[es.CANCELLED = 1] = "CANCELLED", es[es.UNKNOWN = 2] = "UNKNOWN", es[es.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", es[es.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", es[es.NOT_FOUND = 5] = "NOT_FOUND", es[es.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", es[es.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", es[es.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", es[es.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", es[es.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", es[es.ABORTED = 10] = "ABORTED", es[es.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", es[es.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", es[es.INTERNAL = 13] = "INTERNAL", es[es.UNAVAILABLE = 14] = "UNAVAILABLE", es[es.DATA_LOSS = 15] = "DATA_LOSS";
var is = class {
  constructor(t, e) {
    this.mapKeyFn = t, this.equalsFn = e, this.inner = {}, this.innerSize = 0;
  }
  get(t) {
    const e = this.mapKeyFn(t), n = this.inner[e];
    if (void 0 !== n) {
      for (const [e2, s] of n)
        if (this.equalsFn(e2, t))
          return s;
    }
  }
  has(t) {
    return void 0 !== this.get(t);
  }
  set(t, e) {
    const n = this.mapKeyFn(t), s = this.inner[n];
    if (void 0 === s)
      return this.inner[n] = [[t, e]], void this.innerSize++;
    for (let n2 = 0; n2 < s.length; n2++)
      if (this.equalsFn(s[n2][0], t))
        return void (s[n2] = [t, e]);
    s.push([t, e]), this.innerSize++;
  }
  delete(t) {
    const e = this.mapKeyFn(t), n = this.inner[e];
    if (void 0 === n)
      return false;
    for (let s = 0; s < n.length; s++)
      if (this.equalsFn(n[s][0], t))
        return 1 === n.length ? delete this.inner[e] : n.splice(s, 1), this.innerSize--, true;
    return false;
  }
  forEach(t) {
    Lt(this.inner, (e, n) => {
      for (const [e2, s] of n)
        t(e2, s);
    });
  }
  isEmpty() {
    return Ut(this.inner);
  }
  size() {
    return this.innerSize;
  }
};
var rs = new qt(dt.comparator);
function os() {
  return rs;
}
var us = new qt(dt.comparator);
function cs(...t) {
  let e = us;
  for (const n of t)
    e = e.insert(n.key, n);
  return e;
}
function as(t) {
  let e = us;
  return t.forEach((t2, n) => e = e.insert(t2, n.overlayedDocument)), e;
}
function hs() {
  return fs();
}
function ls() {
  return fs();
}
function fs() {
  return new is((t) => t.toString(), (t, e) => t.isEqual(e));
}
var ds = new qt(dt.comparator);
var _s = new Qt(dt.comparator);
function ws(...t) {
  let e = _s;
  for (const n of t)
    e = e.add(n);
  return e;
}
var ms = new Qt(it);
function gs() {
  return ms;
}
var ys = class {
  constructor(t, e, n, s, i) {
    this.snapshotVersion = t, this.targetChanges = e, this.targetMismatches = n, this.documentUpdates = s, this.resolvedLimboDocuments = i;
  }
  static createSynthesizedRemoteEventForCurrentChange(t, e) {
    const n = /* @__PURE__ */ new Map();
    return n.set(t, ps.createSynthesizedTargetChangeForCurrentChange(t, e)), new ys(ct.min(), n, gs(), os(), ws());
  }
};
var ps = class {
  constructor(t, e, n, s, i) {
    this.resumeToken = t, this.current = e, this.addedDocuments = n, this.modifiedDocuments = s, this.removedDocuments = i;
  }
  static createSynthesizedTargetChangeForCurrentChange(t, e) {
    return new ps(Jt.EMPTY_BYTE_STRING, e, ws(), ws(), ws());
  }
};
var Is = class {
  constructor(t, e, n, s) {
    this.gt = t, this.removedTargetIds = e, this.key = n, this.yt = s;
  }
};
var Ts = class {
  constructor(t, e) {
    this.targetId = t, this.It = e;
  }
};
var Es = class {
  constructor(t, e, n = Jt.EMPTY_BYTE_STRING, s = null) {
    this.state = t, this.targetIds = e, this.resumeToken = n, this.cause = s;
  }
};
var As = class {
  constructor() {
    this.Tt = 0, this.Et = Ps(), this.At = Jt.EMPTY_BYTE_STRING, this.Rt = false, this.bt = true;
  }
  get current() {
    return this.Rt;
  }
  get resumeToken() {
    return this.At;
  }
  get Pt() {
    return 0 !== this.Tt;
  }
  get vt() {
    return this.bt;
  }
  Vt(t) {
    t.approximateByteSize() > 0 && (this.bt = true, this.At = t);
  }
  St() {
    let t = ws(), e = ws(), n = ws();
    return this.Et.forEach((s, i) => {
      switch (i) {
        case 0:
          t = t.add(s);
          break;
        case 2:
          e = e.add(s);
          break;
        case 1:
          n = n.add(s);
          break;
        default:
          L();
      }
    }), new ps(this.At, this.Rt, t, e, n);
  }
  Dt() {
    this.bt = false, this.Et = Ps();
  }
  Ct(t, e) {
    this.bt = true, this.Et = this.Et.insert(t, e);
  }
  xt(t) {
    this.bt = true, this.Et = this.Et.remove(t);
  }
  Nt() {
    this.Tt += 1;
  }
  kt() {
    this.Tt -= 1;
  }
  Ot() {
    this.bt = true, this.Rt = true;
  }
};
var Rs = class {
  constructor(t) {
    this.Mt = t, this.Ft = /* @__PURE__ */ new Map(), this.$t = os(), this.Bt = bs(), this.Lt = new Qt(it);
  }
  Ut(t) {
    for (const e of t.gt)
      t.yt && t.yt.isFoundDocument() ? this.qt(e, t.yt) : this.Kt(e, t.key, t.yt);
    for (const e of t.removedTargetIds)
      this.Kt(e, t.key, t.yt);
  }
  Gt(t) {
    this.forEachTarget(t, (e) => {
      const n = this.Qt(e);
      switch (t.state) {
        case 0:
          this.jt(e) && n.Vt(t.resumeToken);
          break;
        case 1:
          n.kt(), n.Pt || n.Dt(), n.Vt(t.resumeToken);
          break;
        case 2:
          n.kt(), n.Pt || this.removeTarget(e);
          break;
        case 3:
          this.jt(e) && (n.Ot(), n.Vt(t.resumeToken));
          break;
        case 4:
          this.jt(e) && (this.Wt(e), n.Vt(t.resumeToken));
          break;
        default:
          L();
      }
    });
  }
  forEachTarget(t, e) {
    t.targetIds.length > 0 ? t.targetIds.forEach(e) : this.Ft.forEach((t2, n) => {
      this.jt(n) && e(n);
    });
  }
  zt(t) {
    const e = t.targetId, n = t.It.count, s = this.Ht(e);
    if (s) {
      const t2 = s.target;
      if ($e(t2))
        if (0 === n) {
          const n2 = new dt(t2.path);
          this.Kt(e, n2, xe.newNoDocument(n2, ct.min()));
        } else
          U(1 === n);
      else {
        this.Jt(e) !== n && (this.Wt(e), this.Lt = this.Lt.add(e));
      }
    }
  }
  Yt(t) {
    const e = /* @__PURE__ */ new Map();
    this.Ft.forEach((n2, s2) => {
      const i = this.Ht(s2);
      if (i) {
        if (n2.current && $e(i.target)) {
          const e2 = new dt(i.target.path);
          null !== this.$t.get(e2) || this.Xt(s2, e2) || this.Kt(s2, e2, xe.newNoDocument(e2, t));
        }
        n2.vt && (e.set(s2, n2.St()), n2.Dt());
      }
    });
    let n = ws();
    this.Bt.forEach((t2, e2) => {
      let s2 = true;
      e2.forEachWhile((t3) => {
        const e3 = this.Ht(t3);
        return !e3 || 2 === e3.purpose || (s2 = false, false);
      }), s2 && (n = n.add(t2));
    }), this.$t.forEach((e2, n2) => n2.setReadTime(t));
    const s = new ys(t, e, this.Lt, this.$t, n);
    return this.$t = os(), this.Bt = bs(), this.Lt = new Qt(it), s;
  }
  qt(t, e) {
    if (!this.jt(t))
      return;
    const n = this.Xt(t, e.key) ? 2 : 0;
    this.Qt(t).Ct(e.key, n), this.$t = this.$t.insert(e.key, e), this.Bt = this.Bt.insert(e.key, this.Zt(e.key).add(t));
  }
  Kt(t, e, n) {
    if (!this.jt(t))
      return;
    const s = this.Qt(t);
    this.Xt(t, e) ? s.Ct(e, 1) : s.xt(e), this.Bt = this.Bt.insert(e, this.Zt(e).delete(t)), n && (this.$t = this.$t.insert(e, n));
  }
  removeTarget(t) {
    this.Ft.delete(t);
  }
  Jt(t) {
    const e = this.Qt(t).St();
    return this.Mt.getRemoteKeysForTarget(t).size + e.addedDocuments.size - e.removedDocuments.size;
  }
  Nt(t) {
    this.Qt(t).Nt();
  }
  Qt(t) {
    let e = this.Ft.get(t);
    return e || (e = new As(), this.Ft.set(t, e)), e;
  }
  Zt(t) {
    let e = this.Bt.get(t);
    return e || (e = new Qt(it), this.Bt = this.Bt.insert(t, e)), e;
  }
  jt(t) {
    const e = null !== this.Ht(t);
    return e || M("WatchChangeAggregator", "Detected inactive target", t), e;
  }
  Ht(t) {
    const e = this.Ft.get(t);
    return e && e.Pt ? null : this.Mt.te(t);
  }
  Wt(t) {
    this.Ft.set(t, new As());
    this.Mt.getRemoteKeysForTarget(t).forEach((e) => {
      this.Kt(t, e, null);
    });
  }
  Xt(t, e) {
    return this.Mt.getRemoteKeysForTarget(t).has(e);
  }
};
function bs() {
  return new qt(dt.comparator);
}
function Ps() {
  return new qt(dt.comparator);
}
var vs = (() => {
  const t = {
    asc: "ASCENDING",
    desc: "DESCENDING"
  };
  return t;
})();
var Vs = (() => {
  const t = {
    "<": "LESS_THAN",
    "<=": "LESS_THAN_OR_EQUAL",
    ">": "GREATER_THAN",
    ">=": "GREATER_THAN_OR_EQUAL",
    "==": "EQUAL",
    "!=": "NOT_EQUAL",
    "array-contains": "ARRAY_CONTAINS",
    in: "IN",
    "not-in": "NOT_IN",
    "array-contains-any": "ARRAY_CONTAINS_ANY"
  };
  return t;
})();
var Ss = class {
  constructor(t, e) {
    this.databaseId = t, this.dt = e;
  }
};
function Ds(t, e) {
  if (t.dt) {
    return `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z`;
  }
  return {
    seconds: "" + e.seconds,
    nanos: e.nanoseconds
  };
}
function Cs(t, e) {
  return t.dt ? e.toBase64() : e.toUint8Array();
}
function xs(t, e) {
  return Ds(t, e.toTimestamp());
}
function Ns(t) {
  return U(!!t), ct.fromTimestamp(function(t2) {
    const e = Xt(t2);
    return new ut(e.seconds, e.nanos);
  }(t));
}
function ks(t, e) {
  return function(t2) {
    return new ht(["projects", t2.projectId, "databases", t2.database]);
  }(t).child("documents").child(e).canonicalString();
}
function Os(t) {
  const e = ht.fromString(t);
  return U(ui(e)), e;
}
function Ms(t, e) {
  return ks(t.databaseId, e.path);
}
function Fs(t, e) {
  const n = Os(e);
  if (n.get(1) !== t.databaseId.projectId)
    throw new Q(G.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n.get(1) + " vs " + t.databaseId.projectId);
  if (n.get(3) !== t.databaseId.database)
    throw new Q(G.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n.get(3) + " vs " + t.databaseId.database);
  return new dt(Us(n));
}
function $s(t, e) {
  return ks(t.databaseId, e);
}
function Bs(t) {
  const e = Os(t);
  return 4 === e.length ? ht.emptyPath() : Us(e);
}
function Ls(t) {
  return new ht(["projects", t.databaseId.projectId, "databases", t.databaseId.database]).canonicalString();
}
function Us(t) {
  return U(t.length > 4 && "documents" === t.get(4)), t.popFirst(5);
}
function qs(t, e, n) {
  return {
    name: Ms(t, e),
    fields: n.value.mapValue.fields
  };
}
function Ks(t, e, n) {
  const s = Fs(t, e.name), i = Ns(e.updateTime), r = new De({
    mapValue: {
      fields: e.fields
    }
  }), o = xe.newFoundDocument(s, i, r);
  return n && o.setHasCommittedMutations(), n ? o.setHasCommittedMutations() : o;
}
function Gs(t, e) {
  return "found" in e ? function(t2, e2) {
    U(!!e2.found), e2.found.name, e2.found.updateTime;
    const n = Fs(t2, e2.found.name), s = Ns(e2.found.updateTime), i = new De({
      mapValue: {
        fields: e2.found.fields
      }
    });
    return xe.newFoundDocument(n, s, i);
  }(t, e) : "missing" in e ? function(t2, e2) {
    U(!!e2.missing), U(!!e2.readTime);
    const n = Fs(t2, e2.missing), s = Ns(e2.readTime);
    return xe.newNoDocument(n, s);
  }(t, e) : L();
}
function Qs(t, e) {
  let n;
  if ("targetChange" in e) {
    e.targetChange;
    const s = function(t2) {
      return "NO_CHANGE" === t2 ? 0 : "ADD" === t2 ? 1 : "REMOVE" === t2 ? 2 : "CURRENT" === t2 ? 3 : "RESET" === t2 ? 4 : L();
    }(e.targetChange.targetChangeType || "NO_CHANGE"), i = e.targetChange.targetIds || [], r = function(t2, e2) {
      return t2.dt ? (U(void 0 === e2 || "string" == typeof e2), Jt.fromBase64String(e2 || "")) : (U(void 0 === e2 || e2 instanceof Uint8Array), Jt.fromUint8Array(e2 || new Uint8Array()));
    }(t, e.targetChange.resumeToken), o = e.targetChange.cause, u = o && function(t2) {
      const e2 = void 0 === t2.code ? G.UNKNOWN : ss(t2.code);
      return new Q(e2, t2.message || "");
    }(o);
    n = new Es(s, i, r, u || null);
  } else if ("documentChange" in e) {
    e.documentChange;
    const s = e.documentChange;
    s.document, s.document.name, s.document.updateTime;
    const i = Fs(t, s.document.name), r = Ns(s.document.updateTime), o = new De({
      mapValue: {
        fields: s.document.fields
      }
    }), u = xe.newFoundDocument(i, r, o), c = s.targetIds || [], a = s.removedTargetIds || [];
    n = new Is(c, a, u.key, u);
  } else if ("documentDelete" in e) {
    e.documentDelete;
    const s = e.documentDelete;
    s.document;
    const i = Fs(t, s.document), r = s.readTime ? Ns(s.readTime) : ct.min(), o = xe.newNoDocument(i, r), u = s.removedTargetIds || [];
    n = new Is([], u, o.key, o);
  } else if ("documentRemove" in e) {
    e.documentRemove;
    const s = e.documentRemove;
    s.document;
    const i = Fs(t, s.document), r = s.removedTargetIds || [];
    n = new Is([], r, i, null);
  } else {
    if (!("filter" in e))
      return L();
    {
      e.filter;
      const t2 = e.filter;
      t2.targetId;
      const s = t2.count || 0, i = new Zn(s), r = t2.targetId;
      n = new Ts(r, i);
    }
  }
  return n;
}
function js(t, e) {
  let n;
  if (e instanceof jn)
    n = {
      update: qs(t, e.key, e.value)
    };
  else if (e instanceof Yn)
    n = {
      delete: Ms(t, e.key)
    };
  else if (e instanceof Wn)
    n = {
      update: qs(t, e.key, e.data),
      updateMask: oi(e.fieldMask)
    };
  else {
    if (!(e instanceof Xn))
      return L();
    n = {
      verify: Ms(t, e.key)
    };
  }
  return e.fieldTransforms.length > 0 && (n.updateTransforms = e.fieldTransforms.map((t2) => function(t3, e2) {
    const n2 = e2.transform;
    if (n2 instanceof vn)
      return {
        fieldPath: e2.field.canonicalString(),
        setToServerValue: "REQUEST_TIME"
      };
    if (n2 instanceof Vn)
      return {
        fieldPath: e2.field.canonicalString(),
        appendMissingElements: {
          values: n2.elements
        }
      };
    if (n2 instanceof Dn)
      return {
        fieldPath: e2.field.canonicalString(),
        removeAllFromArray: {
          values: n2.elements
        }
      };
    if (n2 instanceof xn)
      return {
        fieldPath: e2.field.canonicalString(),
        increment: n2._t
      };
    throw L();
  }(0, t2))), e.precondition.isNone || (n.currentDocument = function(t2, e2) {
    return void 0 !== e2.updateTime ? {
      updateTime: xs(t2, e2.updateTime)
    } : void 0 !== e2.exists ? {
      exists: e2.exists
    } : L();
  }(t, e.precondition)), n;
}
function Ws(t, e) {
  const n = e.currentDocument ? function(t2) {
    return void 0 !== t2.updateTime ? $n.updateTime(Ns(t2.updateTime)) : void 0 !== t2.exists ? $n.exists(t2.exists) : $n.none();
  }(e.currentDocument) : $n.none(), s = e.updateTransforms ? e.updateTransforms.map((e2) => function(t2, e3) {
    let n2 = null;
    if ("setToServerValue" in e3)
      U("REQUEST_TIME" === e3.setToServerValue), n2 = new vn();
    else if ("appendMissingElements" in e3) {
      const t3 = e3.appendMissingElements.values || [];
      n2 = new Vn(t3);
    } else if ("removeAllFromArray" in e3) {
      const t3 = e3.removeAllFromArray.values || [];
      n2 = new Dn(t3);
    } else
      "increment" in e3 ? n2 = new xn(t2, e3.increment) : L();
    const s2 = ft.fromServerFormat(e3.fieldPath);
    return new On(s2, n2);
  }(t, e2)) : [];
  if (e.update) {
    e.update.name;
    const i = Fs(t, e.update.name), r = new De({
      mapValue: {
        fields: e.update.fields
      }
    });
    if (e.updateMask) {
      const t2 = function(t3) {
        const e2 = t3.fieldPaths || [];
        return new zt(e2.map((t4) => ft.fromServerFormat(t4)));
      }(e.updateMask);
      return new Wn(i, r, t2, n, s);
    }
    return new jn(i, r, n, s);
  }
  if (e.delete) {
    const s2 = Fs(t, e.delete);
    return new Yn(s2, n);
  }
  if (e.verify) {
    const s2 = Fs(t, e.verify);
    return new Xn(s2, n);
  }
  return L();
}
function zs(t, e) {
  return t && t.length > 0 ? (U(void 0 !== e), t.map((t2) => function(t3, e2) {
    let n = t3.updateTime ? Ns(t3.updateTime) : Ns(e2);
    return n.isEqual(ct.min()) && (n = Ns(e2)), new Fn(n, t3.transformResults || []);
  }(t2, e))) : [];
}
function Hs(t, e) {
  return {
    documents: [$s(t, e.path)]
  };
}
function Js(t, e) {
  const n = {
    structuredQuery: {}
  }, s = e.path;
  null !== e.collectionGroup ? (n.parent = $s(t, s), n.structuredQuery.from = [{
    collectionId: e.collectionGroup,
    allDescendants: true
  }]) : (n.parent = $s(t, s.popLast()), n.structuredQuery.from = [{
    collectionId: s.lastSegment()
  }]);
  const i = function(t2) {
    if (0 === t2.length)
      return;
    const e2 = t2.map((t3) => function(t4) {
      if ("==" === t4.op) {
        if (Ee(t4.value))
          return {
            unaryFilter: {
              field: ni(t4.field),
              op: "IS_NAN"
            }
          };
        if (Te(t4.value))
          return {
            unaryFilter: {
              field: ni(t4.field),
              op: "IS_NULL"
            }
          };
      } else if ("!=" === t4.op) {
        if (Ee(t4.value))
          return {
            unaryFilter: {
              field: ni(t4.field),
              op: "IS_NOT_NAN"
            }
          };
        if (Te(t4.value))
          return {
            unaryFilter: {
              field: ni(t4.field),
              op: "IS_NOT_NULL"
            }
          };
      }
      return {
        fieldFilter: {
          field: ni(t4.field),
          op: ei(t4.op),
          value: t4.value
        }
      };
    }(t3));
    if (1 === e2.length)
      return e2[0];
    return {
      compositeFilter: {
        op: "AND",
        filters: e2
      }
    };
  }(e.filters);
  i && (n.structuredQuery.where = i);
  const r = function(t2) {
    if (0 === t2.length)
      return;
    return t2.map((t3) => function(t4) {
      return {
        field: ni(t4.field),
        direction: ti(t4.dir)
      };
    }(t3));
  }(e.orderBy);
  r && (n.structuredQuery.orderBy = r);
  const o = function(t2, e2) {
    return t2.dt || oe(e2) ? e2 : {
      value: e2
    };
  }(t, e.limit);
  var u;
  return null !== o && (n.structuredQuery.limit = o), e.startAt && (n.structuredQuery.startAt = {
    before: (u = e.startAt).inclusive,
    values: u.position
  }), e.endAt && (n.structuredQuery.endAt = function(t2) {
    return {
      before: !t2.inclusive,
      values: t2.position
    };
  }(e.endAt)), n;
}
function Ys(t) {
  let e = Bs(t.parent);
  const n = t.structuredQuery, s = n.from ? n.from.length : 0;
  let i = null;
  if (s > 0) {
    U(1 === s);
    const t2 = n.from[0];
    t2.allDescendants ? i = t2.collectionId : e = e.child(t2.collectionId);
  }
  let r = [];
  n.where && (r = Zs(n.where));
  let o = [];
  n.orderBy && (o = n.orderBy.map((t2) => function(t3) {
    return new Xe(si(t3.field), function(t4) {
      switch (t4) {
        case "ASCENDING":
          return "asc";
        case "DESCENDING":
          return "desc";
        default:
          return;
      }
    }(t3.direction));
  }(t2)));
  let u = null;
  n.limit && (u = function(t2) {
    let e2;
    return e2 = "object" == typeof t2 ? t2.value : t2, oe(e2) ? null : e2;
  }(n.limit));
  let c = null;
  n.startAt && (c = function(t2) {
    const e2 = !!t2.before, n2 = t2.values || [];
    return new Ye(n2, e2);
  }(n.startAt));
  let a = null;
  return n.endAt && (a = function(t2) {
    const e2 = !t2.before, n2 = t2.values || [];
    return new Ye(n2, e2);
  }(n.endAt)), sn(e, i, o, r, u, "F", c, a);
}
function Xs(t, e) {
  const n = function(t2, e2) {
    switch (e2) {
      case 0:
        return null;
      case 1:
        return "existence-filter-mismatch";
      case 2:
        return "limbo-document";
      default:
        return L();
    }
  }(0, e.purpose);
  return null == n ? null : {
    "goog-listen-tags": n
  };
}
function Zs(t) {
  return t ? void 0 !== t.unaryFilter ? [ri(t)] : void 0 !== t.fieldFilter ? [ii(t)] : void 0 !== t.compositeFilter ? t.compositeFilter.filters.map((t2) => Zs(t2)).reduce((t2, e) => t2.concat(e)) : L() : [];
}
function ti(t) {
  return vs[t];
}
function ei(t) {
  return Vs[t];
}
function ni(t) {
  return {
    fieldPath: t.canonicalString()
  };
}
function si(t) {
  return ft.fromServerFormat(t.fieldPath);
}
function ii(t) {
  return qe.create(si(t.fieldFilter.field), function(t2) {
    switch (t2) {
      case "EQUAL":
        return "==";
      case "NOT_EQUAL":
        return "!=";
      case "GREATER_THAN":
        return ">";
      case "GREATER_THAN_OR_EQUAL":
        return ">=";
      case "LESS_THAN":
        return "<";
      case "LESS_THAN_OR_EQUAL":
        return "<=";
      case "ARRAY_CONTAINS":
        return "array-contains";
      case "IN":
        return "in";
      case "NOT_IN":
        return "not-in";
      case "ARRAY_CONTAINS_ANY":
        return "array-contains-any";
      default:
        return L();
    }
  }(t.fieldFilter.op), t.fieldFilter.value);
}
function ri(t) {
  switch (t.unaryFilter.op) {
    case "IS_NAN":
      const e = si(t.unaryFilter.field);
      return qe.create(e, "==", {
        doubleValue: NaN
      });
    case "IS_NULL":
      const n = si(t.unaryFilter.field);
      return qe.create(n, "==", {
        nullValue: "NULL_VALUE"
      });
    case "IS_NOT_NAN":
      const s = si(t.unaryFilter.field);
      return qe.create(s, "!=", {
        doubleValue: NaN
      });
    case "IS_NOT_NULL":
      const i = si(t.unaryFilter.field);
      return qe.create(i, "!=", {
        nullValue: "NULL_VALUE"
      });
    default:
      return L();
  }
}
function oi(t) {
  const e = [];
  return t.fields.forEach((t2) => e.push(t2.canonicalString())), {
    fieldPaths: e
  };
}
function ui(t) {
  return t.length >= 4 && "projects" === t.get(0) && "databases" === t.get(2);
}
function ci(t) {
  let e = "";
  for (let n = 0; n < t.length; n++)
    e.length > 0 && (e = hi(e)), e = ai(t.get(n), e);
  return hi(e);
}
function ai(t, e) {
  let n = e;
  const s = t.length;
  for (let e2 = 0; e2 < s; e2++) {
    const s2 = t.charAt(e2);
    switch (s2) {
      case "\0":
        n += "";
        break;
      case "":
        n += "";
        break;
      default:
        n += s2;
    }
  }
  return n;
}
function hi(t) {
  return t + "";
}
function li(t) {
  const e = t.length;
  if (U(e >= 2), 2 === e)
    return U("" === t.charAt(0) && "" === t.charAt(1)), ht.emptyPath();
  const n = e - 2, s = [];
  let i = "";
  for (let r = 0; r < e; ) {
    const e2 = t.indexOf("", r);
    (e2 < 0 || e2 > n) && L();
    switch (t.charAt(e2 + 1)) {
      case "":
        const n2 = t.substring(r, e2);
        let o;
        0 === i.length ? o = n2 : (i += n2, o = i, i = ""), s.push(o);
        break;
      case "":
        i += t.substring(r, e2), i += "\0";
        break;
      case "":
        i += t.substring(r, e2 + 1);
        break;
      default:
        L();
    }
    r = e2 + 2;
  }
  return new ht(s);
}
var fi = ["userId", "batchId"];
function di(t, e) {
  return [t, ci(e)];
}
function _i(t, e, n) {
  return [t, ci(e), n];
}
var wi = {};
var mi = ["prefixPath", "collectionGroup", "readTime", "documentId"];
var gi = ["prefixPath", "collectionGroup", "documentId"];
var yi = ["collectionGroup", "readTime", "prefixPath", "documentId"];
var pi = ["canonicalId", "targetId"];
var Ii = ["targetId", "path"];
var Ti = ["path", "targetId"];
var Ei = ["collectionId", "parent"];
var Ai = ["indexId", "uid"];
var Ri = ["uid", "sequenceNumber"];
var bi = ["indexId", "uid", "arrayValue", "directionalValue", "orderedDocumentKey", "documentKey"];
var Pi = ["indexId", "uid", "orderedDocumentKey"];
var vi = ["userId", "collectionPath", "documentId"];
var Vi = ["userId", "collectionPath", "largestBatchId"];
var Si = ["userId", "collectionGroup", "largestBatchId"];
var Di = [...[...[...[...["mutationQueues", "mutations", "documentMutations", "remoteDocuments", "targets", "owner", "targetGlobal", "targetDocuments"], "clientMetadata"], "remoteDocumentGlobal"], "collectionParents"], "bundles", "namedQueries"];
var Ci = [...Di, "documentOverlays"];
var xi = ["mutationQueues", "mutations", "documentMutations", "remoteDocumentsV14", "targets", "owner", "targetGlobal", "targetDocuments", "clientMetadata", "remoteDocumentGlobal", "collectionParents", "bundles", "namedQueries", "documentOverlays"];
var Ni = xi;
var ki = [...Ni, "indexConfiguration", "indexState", "indexEntries"];
var Oi = class extends Rt {
  constructor(t, e) {
    super(), this.ee = t, this.currentSequenceNumber = e;
  }
};
function Mi(t, e) {
  const n = K(t);
  return Vt.N(n.ee, e);
}
var Fi = class {
  constructor(t, e, n, s) {
    this.batchId = t, this.localWriteTime = e, this.baseMutations = n, this.mutations = s;
  }
  applyToRemoteDocument(t, e) {
    const n = e.mutationResults;
    for (let e2 = 0; e2 < this.mutations.length; e2++) {
      const s = this.mutations[e2];
      if (s.key.isEqual(t.key)) {
        qn(s, t, n[e2]);
      }
    }
  }
  applyToLocalView(t, e) {
    for (const n of this.baseMutations)
      n.key.isEqual(t.key) && (e = Kn(n, t, e, this.localWriteTime));
    for (const n of this.mutations)
      n.key.isEqual(t.key) && (e = Kn(n, t, e, this.localWriteTime));
    return e;
  }
  applyToLocalDocumentSet(t, e) {
    const n = ls();
    return this.mutations.forEach((s) => {
      const i = t.get(s.key), r = i.overlayedDocument;
      let o = this.applyToLocalView(r, i.mutatedFields);
      o = e.has(s.key) ? null : o;
      const u = Un(r, o);
      null !== u && n.set(s.key, u), r.isValidDocument() || r.convertToNoDocument(ct.min());
    }), n;
  }
  keys() {
    return this.mutations.reduce((t, e) => t.add(e.key), ws());
  }
  isEqual(t) {
    return this.batchId === t.batchId && rt(this.mutations, t.mutations, (t2, e) => Qn(t2, e)) && rt(this.baseMutations, t.baseMutations, (t2, e) => Qn(t2, e));
  }
};
var $i = class {
  constructor(t, e, n, s) {
    this.batch = t, this.commitVersion = e, this.mutationResults = n, this.docVersions = s;
  }
  static from(t, e, n) {
    U(t.mutations.length === n.length);
    let s = ds;
    const i = t.mutations;
    for (let t2 = 0; t2 < i.length; t2++)
      s = s.insert(i[t2].key, n[t2].version);
    return new $i(t, e, n, s);
  }
};
var Bi = class {
  constructor(t, e) {
    this.largestBatchId = t, this.mutation = e;
  }
  getKey() {
    return this.mutation.key;
  }
  isEqual(t) {
    return null !== t && this.mutation === t.mutation;
  }
  toString() {
    return `Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`;
  }
};
var Li = class {
  constructor(t, e, n, s, i = ct.min(), r = ct.min(), o = Jt.EMPTY_BYTE_STRING) {
    this.target = t, this.targetId = e, this.purpose = n, this.sequenceNumber = s, this.snapshotVersion = i, this.lastLimboFreeSnapshotVersion = r, this.resumeToken = o;
  }
  withSequenceNumber(t) {
    return new Li(this.target, this.targetId, this.purpose, t, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken);
  }
  withResumeToken(t, e) {
    return new Li(this.target, this.targetId, this.purpose, this.sequenceNumber, e, this.lastLimboFreeSnapshotVersion, t);
  }
  withLastLimboFreeSnapshotVersion(t) {
    return new Li(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, t, this.resumeToken);
  }
};
var Ui = class {
  constructor(t) {
    this.ne = t;
  }
};
function qi(t, e) {
  let n;
  if (e.document)
    n = Ks(t.ne, e.document, !!e.hasCommittedMutations);
  else if (e.noDocument) {
    const t2 = dt.fromSegments(e.noDocument.path), s = ji(e.noDocument.readTime);
    n = xe.newNoDocument(t2, s), e.hasCommittedMutations && n.setHasCommittedMutations();
  } else {
    if (!e.unknownDocument)
      return L();
    {
      const t2 = dt.fromSegments(e.unknownDocument.path), s = ji(e.unknownDocument.version);
      n = xe.newUnknownDocument(t2, s);
    }
  }
  return e.readTime && n.setReadTime(function(t2) {
    const e2 = new ut(t2[0], t2[1]);
    return ct.fromTimestamp(e2);
  }(e.readTime)), n;
}
function Ki(t, e) {
  const n = e.key, s = {
    prefixPath: n.getCollectionPath().popLast().toArray(),
    collectionGroup: n.collectionGroup,
    documentId: n.path.lastSegment(),
    readTime: Gi(e.readTime),
    hasCommittedMutations: e.hasCommittedMutations
  };
  if (e.isFoundDocument())
    s.document = function(t2, e2) {
      return {
        name: Ms(t2, e2.key),
        fields: e2.data.value.mapValue.fields,
        updateTime: Ds(t2, e2.version.toTimestamp())
      };
    }(t.ne, e);
  else if (e.isNoDocument())
    s.noDocument = {
      path: n.path.toArray(),
      readTime: Qi(e.version)
    };
  else {
    if (!e.isUnknownDocument())
      return L();
    s.unknownDocument = {
      path: n.path.toArray(),
      version: Qi(e.version)
    };
  }
  return s;
}
function Gi(t) {
  const e = t.toTimestamp();
  return [e.seconds, e.nanoseconds];
}
function Qi(t) {
  const e = t.toTimestamp();
  return {
    seconds: e.seconds,
    nanoseconds: e.nanoseconds
  };
}
function ji(t) {
  const e = new ut(t.seconds, t.nanoseconds);
  return ct.fromTimestamp(e);
}
function Wi(t, e) {
  const n = (e.baseMutations || []).map((e2) => Ws(t.ne, e2));
  for (let t2 = 0; t2 < e.mutations.length - 1; ++t2) {
    const n2 = e.mutations[t2];
    if (t2 + 1 < e.mutations.length && void 0 !== e.mutations[t2 + 1].transform) {
      const s2 = e.mutations[t2 + 1];
      n2.updateTransforms = s2.transform.fieldTransforms, e.mutations.splice(t2 + 1, 1), ++t2;
    }
  }
  const s = e.mutations.map((e2) => Ws(t.ne, e2)), i = ut.fromMillis(e.localWriteTimeMs);
  return new Fi(e.batchId, i, n, s);
}
function zi(t) {
  const e = ji(t.readTime), n = void 0 !== t.lastLimboFreeSnapshotVersion ? ji(t.lastLimboFreeSnapshotVersion) : ct.min();
  let s;
  var i;
  return void 0 !== t.query.documents ? (U(1 === (i = t.query).documents.length), s = ln(rn(Bs(i.documents[0])))) : s = function(t2) {
    return ln(Ys(t2));
  }(t.query), new Li(s, t.targetId, 0, t.lastListenSequenceNumber, e, n, Jt.fromBase64String(t.resumeToken));
}
function Hi(t, e) {
  const n = Qi(e.snapshotVersion), s = Qi(e.lastLimboFreeSnapshotVersion);
  let i;
  i = $e(e.target) ? Hs(t.ne, e.target) : Js(t.ne, e.target);
  const r = e.resumeToken.toBase64();
  return {
    targetId: e.targetId,
    canonicalId: Oe(e.target),
    readTime: n,
    resumeToken: r,
    lastListenSequenceNumber: e.sequenceNumber,
    lastLimboFreeSnapshotVersion: s,
    query: i
  };
}
function Ji(t) {
  const e = Ys({
    parent: t.parent,
    structuredQuery: t.structuredQuery
  });
  return "LAST" === t.limitType ? fn(e, e.limit, "L") : e;
}
function Yi(t, e) {
  return new Bi(e.largestBatchId, Ws(t.ne, e.overlayMutation));
}
function Xi(t, e) {
  const n = e.path.lastSegment();
  return [t, ci(e.path.popLast()), n];
}
function Zi(t, e, n, s) {
  return {
    indexId: t,
    uid: e.uid || "",
    sequenceNumber: n,
    readTime: Qi(s.readTime),
    documentKey: ci(s.documentKey.path),
    largestBatchId: s.largestBatchId
  };
}
var tr = class {
  getBundleMetadata(t, e) {
    return er(t).get(e).next((t2) => {
      if (t2)
        return {
          id: (e2 = t2).bundleId,
          createTime: ji(e2.createTime),
          version: e2.version
        };
      var e2;
    });
  }
  saveBundleMetadata(t, e) {
    return er(t).put({
      bundleId: (n = e).id,
      createTime: Qi(Ns(n.createTime)),
      version: n.version
    });
    var n;
  }
  getNamedQuery(t, e) {
    return nr(t).get(e).next((t2) => {
      if (t2)
        return {
          name: (e2 = t2).name,
          query: Ji(e2.bundledQuery),
          readTime: ji(e2.readTime)
        };
      var e2;
    });
  }
  saveNamedQuery(t, e) {
    return nr(t).put(function(t2) {
      return {
        name: t2.name,
        readTime: Qi(Ns(t2.readTime)),
        bundledQuery: t2.bundledQuery
      };
    }(e));
  }
};
function er(t) {
  return Mi(t, "bundles");
}
function nr(t) {
  return Mi(t, "namedQueries");
}
var sr = class {
  constructor(t, e) {
    this.wt = t, this.userId = e;
  }
  static se(t, e) {
    const n = e.uid || "";
    return new sr(t, n);
  }
  getOverlay(t, e) {
    return ir(t).get(Xi(this.userId, e)).next((t2) => t2 ? Yi(this.wt, t2) : null);
  }
  getOverlays(t, e) {
    const n = hs();
    return Pt.forEach(e, (e2) => this.getOverlay(t, e2).next((t2) => {
      null !== t2 && n.set(e2, t2);
    })).next(() => n);
  }
  saveOverlays(t, e, n) {
    const s = [];
    return n.forEach((n2, i) => {
      const r = new Bi(e, i);
      s.push(this.ie(t, r));
    }), Pt.waitFor(s);
  }
  removeOverlaysForBatchId(t, e, n) {
    const s = /* @__PURE__ */ new Set();
    e.forEach((t2) => s.add(ci(t2.getCollectionPath())));
    const i = [];
    return s.forEach((e2) => {
      const s2 = IDBKeyRange.bound([this.userId, e2, n], [this.userId, e2, n + 1], false, true);
      i.push(ir(t).W("collectionPathOverlayIndex", s2));
    }), Pt.waitFor(i);
  }
  getOverlaysForCollection(t, e, n) {
    const s = hs(), i = ci(e), r = IDBKeyRange.bound([this.userId, i, n], [this.userId, i, Number.POSITIVE_INFINITY], true);
    return ir(t).K("collectionPathOverlayIndex", r).next((t2) => {
      for (const e2 of t2) {
        const t3 = Yi(this.wt, e2);
        s.set(t3.getKey(), t3);
      }
      return s;
    });
  }
  getOverlaysForCollectionGroup(t, e, n, s) {
    const i = hs();
    let r;
    const o = IDBKeyRange.bound([this.userId, e, n], [this.userId, e, Number.POSITIVE_INFINITY], true);
    return ir(t).J({
      index: "collectionGroupOverlayIndex",
      range: o
    }, (t2, e2, n2) => {
      const o2 = Yi(this.wt, e2);
      i.size() < s || o2.largestBatchId === r ? (i.set(o2.getKey(), o2), r = o2.largestBatchId) : n2.done();
    }).next(() => i);
  }
  ie(t, e) {
    return ir(t).put(function(t2, e2, n) {
      const [s, i, r] = Xi(e2, n.mutation.key);
      return {
        userId: e2,
        collectionPath: i,
        documentId: r,
        collectionGroup: n.mutation.key.getCollectionGroup(),
        largestBatchId: n.largestBatchId,
        overlayMutation: js(t2.ne, n.mutation)
      };
    }(this.wt, this.userId, e));
  }
};
function ir(t) {
  return Mi(t, "documentOverlays");
}
var rr = class {
  constructor() {
  }
  re(t, e) {
    this.oe(t, e), e.ue();
  }
  oe(t, e) {
    if ("nullValue" in t)
      this.ce(e, 5);
    else if ("booleanValue" in t)
      this.ce(e, 10), e.ae(t.booleanValue ? 1 : 0);
    else if ("integerValue" in t)
      this.ce(e, 15), e.ae(Zt(t.integerValue));
    else if ("doubleValue" in t) {
      const n = Zt(t.doubleValue);
      isNaN(n) ? this.ce(e, 13) : (this.ce(e, 15), ue(n) ? e.ae(0) : e.ae(n));
    } else if ("timestampValue" in t) {
      const n = t.timestampValue;
      this.ce(e, 20), "string" == typeof n ? e.he(n) : (e.he(`${n.seconds || ""}`), e.ae(n.nanos || 0));
    } else if ("stringValue" in t)
      this.le(t.stringValue, e), this.fe(e);
    else if ("bytesValue" in t)
      this.ce(e, 30), e.de(te(t.bytesValue)), this.fe(e);
    else if ("referenceValue" in t)
      this._e(t.referenceValue, e);
    else if ("geoPointValue" in t) {
      const n = t.geoPointValue;
      this.ce(e, 45), e.ae(n.latitude || 0), e.ae(n.longitude || 0);
    } else
      "mapValue" in t ? be(t) ? this.ce(e, Number.MAX_SAFE_INTEGER) : (this.we(t.mapValue, e), this.fe(e)) : "arrayValue" in t ? (this.me(t.arrayValue, e), this.fe(e)) : L();
  }
  le(t, e) {
    this.ce(e, 25), this.ge(t, e);
  }
  ge(t, e) {
    e.he(t);
  }
  we(t, e) {
    const n = t.fields || {};
    this.ce(e, 55);
    for (const t2 of Object.keys(n))
      this.le(t2, e), this.oe(n[t2], e);
  }
  me(t, e) {
    const n = t.values || [];
    this.ce(e, 50);
    for (const t2 of n)
      this.oe(t2, e);
  }
  _e(t, e) {
    this.ce(e, 37);
    dt.fromName(t).path.forEach((t2) => {
      this.ce(e, 60), this.ge(t2, e);
    });
  }
  ce(t, e) {
    t.ae(e);
  }
  fe(t) {
    t.ae(2);
  }
};
rr.ye = new rr();
function or(t) {
  if (0 === t)
    return 8;
  let e = 0;
  return t >> 4 == 0 && (e += 4, t <<= 4), t >> 6 == 0 && (e += 2, t <<= 2), t >> 7 == 0 && (e += 1), e;
}
function ur(t) {
  const e = 64 - function(t2) {
    let e2 = 0;
    for (let n = 0; n < 8; ++n) {
      const s = or(255 & t2[n]);
      if (e2 += s, 8 !== s)
        break;
    }
    return e2;
  }(t);
  return Math.ceil(e / 8);
}
var cr = class {
  constructor() {
    this.buffer = new Uint8Array(1024), this.position = 0;
  }
  pe(t) {
    const e = t[Symbol.iterator]();
    let n = e.next();
    for (; !n.done; )
      this.Ie(n.value), n = e.next();
    this.Te();
  }
  Ee(t) {
    const e = t[Symbol.iterator]();
    let n = e.next();
    for (; !n.done; )
      this.Ae(n.value), n = e.next();
    this.Re();
  }
  be(t) {
    for (const e of t) {
      const t2 = e.charCodeAt(0);
      if (t2 < 128)
        this.Ie(t2);
      else if (t2 < 2048)
        this.Ie(960 | t2 >>> 6), this.Ie(128 | 63 & t2);
      else if (e < "\uD800" || "\uDBFF" < e)
        this.Ie(480 | t2 >>> 12), this.Ie(128 | 63 & t2 >>> 6), this.Ie(128 | 63 & t2);
      else {
        const t3 = e.codePointAt(0);
        this.Ie(240 | t3 >>> 18), this.Ie(128 | 63 & t3 >>> 12), this.Ie(128 | 63 & t3 >>> 6), this.Ie(128 | 63 & t3);
      }
    }
    this.Te();
  }
  Pe(t) {
    for (const e of t) {
      const t2 = e.charCodeAt(0);
      if (t2 < 128)
        this.Ae(t2);
      else if (t2 < 2048)
        this.Ae(960 | t2 >>> 6), this.Ae(128 | 63 & t2);
      else if (e < "\uD800" || "\uDBFF" < e)
        this.Ae(480 | t2 >>> 12), this.Ae(128 | 63 & t2 >>> 6), this.Ae(128 | 63 & t2);
      else {
        const t3 = e.codePointAt(0);
        this.Ae(240 | t3 >>> 18), this.Ae(128 | 63 & t3 >>> 12), this.Ae(128 | 63 & t3 >>> 6), this.Ae(128 | 63 & t3);
      }
    }
    this.Re();
  }
  ve(t) {
    const e = this.Ve(t), n = ur(e);
    this.Se(1 + n), this.buffer[this.position++] = 255 & n;
    for (let t2 = e.length - n; t2 < e.length; ++t2)
      this.buffer[this.position++] = 255 & e[t2];
  }
  De(t) {
    const e = this.Ve(t), n = ur(e);
    this.Se(1 + n), this.buffer[this.position++] = ~(255 & n);
    for (let t2 = e.length - n; t2 < e.length; ++t2)
      this.buffer[this.position++] = ~(255 & e[t2]);
  }
  Ce() {
    this.xe(255), this.xe(255);
  }
  Ne() {
    this.ke(255), this.ke(255);
  }
  reset() {
    this.position = 0;
  }
  seed(t) {
    this.Se(t.length), this.buffer.set(t, this.position), this.position += t.length;
  }
  Oe() {
    return this.buffer.slice(0, this.position);
  }
  Ve(t) {
    const e = function(t2) {
      const e2 = new DataView(new ArrayBuffer(8));
      return e2.setFloat64(0, t2, false), new Uint8Array(e2.buffer);
    }(t), n = 0 != (128 & e[0]);
    e[0] ^= n ? 255 : 128;
    for (let t2 = 1; t2 < e.length; ++t2)
      e[t2] ^= n ? 255 : 0;
    return e;
  }
  Ie(t) {
    const e = 255 & t;
    0 === e ? (this.xe(0), this.xe(255)) : 255 === e ? (this.xe(255), this.xe(0)) : this.xe(e);
  }
  Ae(t) {
    const e = 255 & t;
    0 === e ? (this.ke(0), this.ke(255)) : 255 === e ? (this.ke(255), this.ke(0)) : this.ke(t);
  }
  Te() {
    this.xe(0), this.xe(1);
  }
  Re() {
    this.ke(0), this.ke(1);
  }
  xe(t) {
    this.Se(1), this.buffer[this.position++] = t;
  }
  ke(t) {
    this.Se(1), this.buffer[this.position++] = ~t;
  }
  Se(t) {
    const e = t + this.position;
    if (e <= this.buffer.length)
      return;
    let n = 2 * this.buffer.length;
    n < e && (n = e);
    const s = new Uint8Array(n);
    s.set(this.buffer), this.buffer = s;
  }
};
var ar = class {
  constructor(t) {
    this.Me = t;
  }
  de(t) {
    this.Me.pe(t);
  }
  he(t) {
    this.Me.be(t);
  }
  ae(t) {
    this.Me.ve(t);
  }
  ue() {
    this.Me.Ce();
  }
};
var hr = class {
  constructor(t) {
    this.Me = t;
  }
  de(t) {
    this.Me.Ee(t);
  }
  he(t) {
    this.Me.Pe(t);
  }
  ae(t) {
    this.Me.De(t);
  }
  ue() {
    this.Me.Ne();
  }
};
var lr = class {
  constructor() {
    this.Me = new cr(), this.Fe = new ar(this.Me), this.$e = new hr(this.Me);
  }
  seed(t) {
    this.Me.seed(t);
  }
  Be(t) {
    return 0 === t ? this.Fe : this.$e;
  }
  Oe() {
    return this.Me.Oe();
  }
  reset() {
    this.Me.reset();
  }
};
var fr = class {
  constructor(t, e, n, s) {
    this.indexId = t, this.documentKey = e, this.arrayValue = n, this.directionalValue = s;
  }
  Le() {
    const t = this.directionalValue.length, e = 0 === t || 255 === this.directionalValue[t - 1] ? t + 1 : t, n = new Uint8Array(e);
    return n.set(this.directionalValue, 0), e !== t ? n.set([0], this.directionalValue.length) : ++n[n.length - 1], new fr(this.indexId, this.documentKey, this.arrayValue, n);
  }
};
function dr(t, e) {
  let n = t.indexId - e.indexId;
  return 0 !== n ? n : (n = _r(t.arrayValue, e.arrayValue), 0 !== n ? n : (n = _r(t.directionalValue, e.directionalValue), 0 !== n ? n : dt.comparator(t.documentKey, e.documentKey)));
}
function _r(t, e) {
  for (let n = 0; n < t.length && n < e.length; ++n) {
    const s = t[n] - e[n];
    if (0 !== s)
      return s;
  }
  return t.length - e.length;
}
var wr = class {
  constructor(t) {
    this.collectionId = null != t.collectionGroup ? t.collectionGroup : t.path.lastSegment(), this.Ue = t.orderBy, this.qe = [];
    for (const e of t.filters) {
      const t2 = e;
      t2.ht() ? this.Ke = t2 : this.qe.push(t2);
    }
  }
  Ge(t) {
    const e = wt(t);
    if (void 0 !== e && !this.Qe(e))
      return false;
    const n = mt(t);
    let s = 0, i = 0;
    for (; s < n.length && this.Qe(n[s]); ++s)
      ;
    if (s === n.length)
      return true;
    if (void 0 !== this.Ke) {
      const t2 = n[s];
      if (!this.je(this.Ke, t2) || !this.We(this.Ue[i++], t2))
        return false;
      ++s;
    }
    for (; s < n.length; ++s) {
      const t2 = n[s];
      if (i >= this.Ue.length || !this.We(this.Ue[i++], t2))
        return false;
    }
    return true;
  }
  Qe(t) {
    for (const e of this.qe)
      if (this.je(e, t))
        return true;
    return false;
  }
  je(t, e) {
    if (void 0 === t || !t.field.isEqual(e.fieldPath))
      return false;
    const n = "array-contains" === t.op || "array-contains-any" === t.op;
    return 2 === e.kind === n;
  }
  We(t, e) {
    return !!t.field.isEqual(e.fieldPath) && (0 === e.kind && "asc" === t.dir || 1 === e.kind && "desc" === t.dir);
  }
};
var mr = class {
  constructor() {
    this.ze = new gr();
  }
  addToCollectionParentIndex(t, e) {
    return this.ze.add(e), Pt.resolve();
  }
  getCollectionParents(t, e) {
    return Pt.resolve(this.ze.getEntries(e));
  }
  addFieldIndex(t, e) {
    return Pt.resolve();
  }
  deleteFieldIndex(t, e) {
    return Pt.resolve();
  }
  getDocumentsMatchingTarget(t, e) {
    return Pt.resolve(null);
  }
  getIndexType(t, e) {
    return Pt.resolve(0);
  }
  getFieldIndexes(t, e) {
    return Pt.resolve([]);
  }
  getNextCollectionGroupToUpdate(t) {
    return Pt.resolve(null);
  }
  getMinOffset(t, e) {
    return Pt.resolve(Tt.min());
  }
  getMinOffsetFromCollectionGroup(t, e) {
    return Pt.resolve(Tt.min());
  }
  updateCollectionGroup(t, e, n) {
    return Pt.resolve();
  }
  updateIndexEntries(t, e) {
    return Pt.resolve();
  }
};
var gr = class {
  constructor() {
    this.index = {};
  }
  add(t) {
    const e = t.lastSegment(), n = t.popLast(), s = this.index[e] || new Qt(ht.comparator), i = !s.has(n);
    return this.index[e] = s.add(n), i;
  }
  has(t) {
    const e = t.lastSegment(), n = t.popLast(), s = this.index[e];
    return s && s.has(n);
  }
  getEntries(t) {
    return (this.index[t] || new Qt(ht.comparator)).toArray();
  }
};
var yr = new Uint8Array(0);
var pr = class {
  constructor(t, e) {
    this.user = t, this.databaseId = e, this.He = new gr(), this.Je = new is((t2) => Oe(t2), (t2, e2) => Fe(t2, e2)), this.uid = t.uid || "";
  }
  addToCollectionParentIndex(t, e) {
    if (!this.He.has(e)) {
      const n = e.lastSegment(), s = e.popLast();
      t.addOnCommittedListener(() => {
        this.He.add(e);
      });
      const i = {
        collectionId: n,
        parent: ci(s)
      };
      return Ir(t).put(i);
    }
    return Pt.resolve();
  }
  getCollectionParents(t, e) {
    const n = [], s = IDBKeyRange.bound([e, ""], [ot(e), ""], false, true);
    return Ir(t).K(s).next((t2) => {
      for (const s2 of t2) {
        if (s2.collectionId !== e)
          break;
        n.push(li(s2.parent));
      }
      return n;
    });
  }
  addFieldIndex(t, e) {
    const n = Er(t), s = function(t2) {
      return {
        indexId: t2.indexId,
        collectionGroup: t2.collectionGroup,
        fields: t2.fields.map((t3) => [t3.fieldPath.canonicalString(), t3.kind])
      };
    }(e);
    delete s.indexId;
    const i = n.add(s);
    if (e.indexState) {
      const n2 = Ar(t);
      return i.next((t2) => {
        n2.put(Zi(t2, this.user, e.indexState.sequenceNumber, e.indexState.offset));
      });
    }
    return i.next();
  }
  deleteFieldIndex(t, e) {
    const n = Er(t), s = Ar(t), i = Tr(t);
    return n.delete(e.indexId).next(() => s.delete(IDBKeyRange.bound([e.indexId], [e.indexId + 1], false, true))).next(() => i.delete(IDBKeyRange.bound([e.indexId], [e.indexId + 1], false, true)));
  }
  getDocumentsMatchingTarget(t, e) {
    const n = Tr(t);
    let s = true;
    const i = /* @__PURE__ */ new Map();
    return Pt.forEach(this.Ye(e), (e2) => this.Xe(t, e2).next((t2) => {
      s && (s = !!t2), i.set(e2, t2);
    })).next(() => {
      if (s) {
        let t2 = ws();
        const s2 = [];
        return Pt.forEach(i, (i2, r) => {
          var o;
          M("IndexedDbIndexManager", `Using index ${o = i2, `id=${o.indexId}|cg=${o.collectionGroup}|f=${o.fields.map((t3) => `${t3.fieldPath}:${t3.kind}`).join(",")}`} to execute ${Oe(e)}`);
          const u = function(t3, e2) {
            const n2 = wt(e2);
            if (void 0 === n2)
              return null;
            for (const e3 of Be(t3, n2.fieldPath))
              switch (e3.op) {
                case "array-contains-any":
                  return e3.value.arrayValue.values || [];
                case "array-contains":
                  return [e3.value];
              }
            return null;
          }(r, i2), c = function(t3, e2) {
            const n2 = /* @__PURE__ */ new Map();
            for (const s3 of mt(e2))
              for (const e3 of Be(t3, s3.fieldPath))
                switch (e3.op) {
                  case "==":
                  case "in":
                    n2.set(s3.fieldPath.canonicalString(), e3.value);
                    break;
                  case "not-in":
                  case "!=":
                    return n2.set(s3.fieldPath.canonicalString(), e3.value), Array.from(n2.values());
                }
            return null;
          }(r, i2), a = function(t3, e2) {
            const n2 = [];
            let s3 = true;
            for (const i3 of mt(e2)) {
              const e3 = 0 === i3.kind ? Le(t3, i3.fieldPath, t3.startAt) : Ue(t3, i3.fieldPath, t3.startAt);
              n2.push(e3.value), s3 && (s3 = e3.inclusive);
            }
            return new Ye(n2, s3);
          }(r, i2), h = function(t3, e2) {
            const n2 = [];
            let s3 = true;
            for (const i3 of mt(e2)) {
              const e3 = 0 === i3.kind ? Ue(t3, i3.fieldPath, t3.endAt) : Le(t3, i3.fieldPath, t3.endAt);
              n2.push(e3.value), s3 && (s3 = e3.inclusive);
            }
            return new Ye(n2, s3);
          }(r, i2), l = this.Ze(i2, r, a), f = this.Ze(i2, r, h), d = this.tn(i2, r, c), _ = this.en(i2.indexId, u, l, a.inclusive, f, h.inclusive, d);
          return Pt.forEach(_, (i3) => n.j(i3, e.limit).next((e2) => {
            e2.forEach((e3) => {
              const n2 = dt.fromSegments(e3.documentKey);
              t2.has(n2) || (t2 = t2.add(n2), s2.push(n2));
            });
          }));
        }).next(() => s2);
      }
      return Pt.resolve(null);
    });
  }
  Ye(t) {
    let e = this.Je.get(t);
    return e || (e = [t], this.Je.set(t, e), e);
  }
  en(t, e, n, s, i, r, o) {
    const u = (null != e ? e.length : 1) * Math.max(n.length, i.length), c = u / (null != e ? e.length : 1), a = [];
    for (let h = 0; h < u; ++h) {
      const u2 = e ? this.nn(e[h / c]) : yr, l = this.sn(t, u2, n[h % c], s), f = this.rn(t, u2, i[h % c], r), d = o.map((e2) => this.sn(t, u2, e2, true));
      a.push(...this.createRange(l, f, d));
    }
    return a;
  }
  sn(t, e, n, s) {
    const i = new fr(t, dt.empty(), e, n);
    return s ? i : i.Le();
  }
  rn(t, e, n, s) {
    const i = new fr(t, dt.empty(), e, n);
    return s ? i.Le() : i;
  }
  Xe(t, e) {
    const n = new wr(e), s = null != e.collectionGroup ? e.collectionGroup : e.path.lastSegment();
    return this.getFieldIndexes(t, s).next((t2) => {
      let e2 = null;
      for (const s2 of t2) {
        n.Ge(s2) && (!e2 || s2.fields.length > e2.fields.length) && (e2 = s2);
      }
      return e2;
    });
  }
  getIndexType(t, e) {
    let n = 2;
    return Pt.forEach(this.Ye(e), (e2) => this.Xe(t, e2).next((t2) => {
      t2 ? 0 !== n && t2.fields.length < function(t3) {
        let e3 = new Qt(ft.comparator), n2 = false;
        for (const s of t3.filters) {
          const t4 = s;
          t4.field.isKeyField() || ("array-contains" === t4.op || "array-contains-any" === t4.op ? n2 = true : e3 = e3.add(t4.field));
        }
        for (const n3 of t3.orderBy)
          n3.field.isKeyField() || (e3 = e3.add(n3.field));
        return e3.size + (n2 ? 1 : 0);
      }(e2) && (n = 1) : n = 0;
    })).next(() => n);
  }
  on(t, e) {
    const n = new lr();
    for (const s of mt(t)) {
      const t2 = e.data.field(s.fieldPath);
      if (null == t2)
        return null;
      const i = n.Be(s.kind);
      rr.ye.re(t2, i);
    }
    return n.Oe();
  }
  nn(t) {
    const e = new lr();
    return rr.ye.re(t, e.Be(0)), e.Oe();
  }
  un(t, e) {
    const n = new lr();
    return rr.ye.re(ye(this.databaseId, e), n.Be(function(t2) {
      const e2 = mt(t2);
      return 0 === e2.length ? 0 : e2[e2.length - 1].kind;
    }(t))), n.Oe();
  }
  tn(t, e, n) {
    if (null === n)
      return [];
    let s = [];
    s.push(new lr());
    let i = 0;
    for (const r of mt(t)) {
      const t2 = n[i++];
      for (const n2 of s)
        if (this.cn(e, r.fieldPath) && Ie(t2))
          s = this.an(s, r, t2);
        else {
          const e2 = n2.Be(r.kind);
          rr.ye.re(t2, e2);
        }
    }
    return this.hn(s);
  }
  Ze(t, e, n) {
    return this.tn(t, e, n.position);
  }
  hn(t) {
    const e = [];
    for (let n = 0; n < t.length; ++n)
      e[n] = t[n].Oe();
    return e;
  }
  an(t, e, n) {
    const s = [...t], i = [];
    for (const t2 of n.arrayValue.values || [])
      for (const n2 of s) {
        const s2 = new lr();
        s2.seed(n2.Oe()), rr.ye.re(t2, s2.Be(e.kind)), i.push(s2);
      }
    return i;
  }
  cn(t, e) {
    return !!t.filters.find((t2) => t2 instanceof qe && t2.field.isEqual(e) && ("in" === t2.op || "not-in" === t2.op));
  }
  getFieldIndexes(t, e) {
    const n = Er(t), s = Ar(t);
    return (e ? n.K("collectionGroupIndex", IDBKeyRange.bound(e, e)) : n.K()).next((t2) => {
      const e2 = [];
      return Pt.forEach(t2, (t3) => s.get([t3.indexId, this.uid]).next((n2) => {
        e2.push(function(t4, e3) {
          const n3 = e3 ? new yt(e3.sequenceNumber, new Tt(ji(e3.readTime), new dt(li(e3.documentKey)), e3.largestBatchId)) : yt.empty(), s2 = t4.fields.map(([t5, e4]) => new gt(ft.fromServerFormat(t5), e4));
          return new _t(t4.indexId, t4.collectionGroup, s2, n3);
        }(t3, n2));
      })).next(() => e2);
    });
  }
  getNextCollectionGroupToUpdate(t) {
    return this.getFieldIndexes(t).next((t2) => 0 === t2.length ? null : (t2.sort((t3, e) => {
      const n = t3.indexState.sequenceNumber - e.indexState.sequenceNumber;
      return 0 !== n ? n : it(t3.collectionGroup, e.collectionGroup);
    }), t2[0].collectionGroup));
  }
  updateCollectionGroup(t, e, n) {
    const s = Er(t), i = Ar(t);
    return this.ln(t).next((t2) => s.K("collectionGroupIndex", IDBKeyRange.bound(e, e)).next((e2) => Pt.forEach(e2, (e3) => i.put(Zi(e3.indexId, this.user, t2, n)))));
  }
  updateIndexEntries(t, e) {
    const n = /* @__PURE__ */ new Map();
    return Pt.forEach(e, (e2, s) => {
      const i = n.get(e2.collectionGroup);
      return (i ? Pt.resolve(i) : this.getFieldIndexes(t, e2.collectionGroup)).next((i2) => (n.set(e2.collectionGroup, i2), Pt.forEach(i2, (n2) => this.fn(t, e2, n2).next((e3) => {
        const i3 = this.dn(s, n2);
        return e3.isEqual(i3) ? Pt.resolve() : this._n(t, s, n2, e3, i3);
      }))));
    });
  }
  wn(t, e, n, s) {
    return Tr(t).put({
      indexId: s.indexId,
      uid: this.uid,
      arrayValue: s.arrayValue,
      directionalValue: s.directionalValue,
      orderedDocumentKey: this.un(n, e.key),
      documentKey: e.key.path.toArray()
    });
  }
  mn(t, e, n, s) {
    return Tr(t).delete([s.indexId, this.uid, s.arrayValue, s.directionalValue, this.un(n, e.key), e.key.path.toArray()]);
  }
  fn(t, e, n) {
    const s = Tr(t);
    let i = new Qt(dr);
    return s.J({
      index: "documentKeyIndex",
      range: IDBKeyRange.only([n.indexId, this.uid, this.un(n, e)])
    }, (t2, s2) => {
      i = i.add(new fr(n.indexId, e, s2.arrayValue, s2.directionalValue));
    }).next(() => i);
  }
  dn(t, e) {
    let n = new Qt(dr);
    const s = this.on(e, t);
    if (null == s)
      return n;
    const i = wt(e);
    if (null != i) {
      const r = t.data.field(i.fieldPath);
      if (Ie(r))
        for (const i2 of r.arrayValue.values || [])
          n = n.add(new fr(e.indexId, t.key, this.nn(i2), s));
    } else
      n = n.add(new fr(e.indexId, t.key, yr, s));
    return n;
  }
  _n(t, e, n, s, i) {
    M("IndexedDbIndexManager", "Updating index entries for document '%s'", e.key);
    const r = [];
    return function(t2, e2, n2, s2, i2) {
      const r2 = t2.getIterator(), o = e2.getIterator();
      let u = Wt(r2), c = Wt(o);
      for (; u || c; ) {
        let t3 = false, e3 = false;
        if (u && c) {
          const s3 = n2(u, c);
          s3 < 0 ? e3 = true : s3 > 0 && (t3 = true);
        } else
          null != u ? e3 = true : t3 = true;
        t3 ? (s2(c), c = Wt(o)) : e3 ? (i2(u), u = Wt(r2)) : (u = Wt(r2), c = Wt(o));
      }
    }(s, i, dr, (s2) => {
      r.push(this.wn(t, e, n, s2));
    }, (s2) => {
      r.push(this.mn(t, e, n, s2));
    }), Pt.waitFor(r);
  }
  ln(t) {
    let e = 1;
    return Ar(t).J({
      index: "sequenceNumberIndex",
      reverse: true,
      range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER])
    }, (t2, n, s) => {
      s.done(), e = n.sequenceNumber + 1;
    }).next(() => e);
  }
  createRange(t, e, n) {
    n = n.sort((t2, e2) => dr(t2, e2)).filter((t2, e2, n2) => !e2 || 0 !== dr(t2, n2[e2 - 1]));
    const s = [];
    s.push(t);
    for (const i2 of n) {
      const n2 = dr(i2, t), r = dr(i2, e);
      if (0 === n2)
        s[0] = t.Le();
      else if (n2 > 0 && r < 0)
        s.push(i2), s.push(i2.Le());
      else if (r > 0)
        break;
    }
    s.push(e);
    const i = [];
    for (let t2 = 0; t2 < s.length; t2 += 2)
      i.push(IDBKeyRange.bound([s[t2].indexId, this.uid, s[t2].arrayValue, s[t2].directionalValue, yr, []], [s[t2 + 1].indexId, this.uid, s[t2 + 1].arrayValue, s[t2 + 1].directionalValue, yr, []]));
    return i;
  }
  getMinOffsetFromCollectionGroup(t, e) {
    return this.getFieldIndexes(t, e).next(Rr);
  }
  getMinOffset(t, e) {
    return Pt.mapArray(this.Ye(e), (e2) => this.Xe(t, e2).next((t2) => t2 || L())).next(Rr);
  }
};
function Ir(t) {
  return Mi(t, "collectionParents");
}
function Tr(t) {
  return Mi(t, "indexEntries");
}
function Er(t) {
  return Mi(t, "indexConfiguration");
}
function Ar(t) {
  return Mi(t, "indexState");
}
function Rr(t) {
  U(0 !== t.length);
  let e = t[0].indexState.offset, n = e.largestBatchId;
  for (let s = 1; s < t.length; s++) {
    const i = t[s].indexState.offset;
    Et(i, e) < 0 && (e = i), n < i.largestBatchId && (n = i.largestBatchId);
  }
  return new Tt(e.readTime, e.documentKey, n);
}
var br = {
  didRun: false,
  sequenceNumbersCollected: 0,
  targetsRemoved: 0,
  documentsRemoved: 0
};
var Pr = class {
  constructor(t, e, n) {
    this.cacheSizeCollectionThreshold = t, this.percentileToCollect = e, this.maximumSequenceNumbersToCollect = n;
  }
  static withCacheSize(t) {
    return new Pr(t, Pr.DEFAULT_COLLECTION_PERCENTILE, Pr.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
  }
};
function vr(t, e, n) {
  const s = t.store("mutations"), i = t.store("documentMutations"), r = [], o = IDBKeyRange.only(n.batchId);
  let u = 0;
  const c = s.J({
    range: o
  }, (t2, e2, n2) => (u++, n2.delete()));
  r.push(c.next(() => {
    U(1 === u);
  }));
  const a = [];
  for (const t2 of n.mutations) {
    const s2 = _i(e, t2.key.path, n.batchId);
    r.push(i.delete(s2)), a.push(t2.key);
  }
  return Pt.waitFor(r).next(() => a);
}
function Vr(t) {
  if (!t)
    return 0;
  let e;
  if (t.document)
    e = t.document;
  else if (t.unknownDocument)
    e = t.unknownDocument;
  else {
    if (!t.noDocument)
      throw L();
    e = t.noDocument;
  }
  return JSON.stringify(e).length;
}
Pr.DEFAULT_COLLECTION_PERCENTILE = 10, Pr.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, Pr.DEFAULT = new Pr(41943040, Pr.DEFAULT_COLLECTION_PERCENTILE, Pr.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), Pr.DISABLED = new Pr(-1, 0, 0);
var Sr = class {
  constructor(t, e, n, s) {
    this.userId = t, this.wt = e, this.indexManager = n, this.referenceDelegate = s, this.gn = {};
  }
  static se(t, e, n, s) {
    U("" !== t.uid);
    const i = t.isAuthenticated() ? t.uid : "";
    return new Sr(i, e, n, s);
  }
  checkEmpty(t) {
    let e = true;
    const n = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
    return Cr(t).J({
      index: "userMutationsIndex",
      range: n
    }, (t2, n2, s) => {
      e = false, s.done();
    }).next(() => e);
  }
  addMutationBatch(t, e, n, s) {
    const i = xr(t), r = Cr(t);
    return r.add({}).next((o) => {
      U("number" == typeof o);
      const u = new Fi(o, e, n, s), c = function(t2, e2, n2) {
        const s2 = n2.baseMutations.map((e3) => js(t2.ne, e3)), i2 = n2.mutations.map((e3) => js(t2.ne, e3));
        return {
          userId: e2,
          batchId: n2.batchId,
          localWriteTimeMs: n2.localWriteTime.toMillis(),
          baseMutations: s2,
          mutations: i2
        };
      }(this.wt, this.userId, u), a = [];
      let h = new Qt((t2, e2) => it(t2.canonicalString(), e2.canonicalString()));
      for (const t2 of s) {
        const e2 = _i(this.userId, t2.key.path, o);
        h = h.add(t2.key.path.popLast()), a.push(r.put(c)), a.push(i.put(e2, wi));
      }
      return h.forEach((e2) => {
        a.push(this.indexManager.addToCollectionParentIndex(t, e2));
      }), t.addOnCommittedListener(() => {
        this.gn[o] = u.keys();
      }), Pt.waitFor(a).next(() => u);
    });
  }
  lookupMutationBatch(t, e) {
    return Cr(t).get(e).next((t2) => t2 ? (U(t2.userId === this.userId), Wi(this.wt, t2)) : null);
  }
  yn(t, e) {
    return this.gn[e] ? Pt.resolve(this.gn[e]) : this.lookupMutationBatch(t, e).next((t2) => {
      if (t2) {
        const n = t2.keys();
        return this.gn[e] = n, n;
      }
      return null;
    });
  }
  getNextMutationBatchAfterBatchId(t, e) {
    const n = e + 1, s = IDBKeyRange.lowerBound([this.userId, n]);
    let i = null;
    return Cr(t).J({
      index: "userMutationsIndex",
      range: s
    }, (t2, e2, s2) => {
      e2.userId === this.userId && (U(e2.batchId >= n), i = Wi(this.wt, e2)), s2.done();
    }).next(() => i);
  }
  getHighestUnacknowledgedBatchId(t) {
    const e = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]);
    let n = -1;
    return Cr(t).J({
      index: "userMutationsIndex",
      range: e,
      reverse: true
    }, (t2, e2, s) => {
      n = e2.batchId, s.done();
    }).next(() => n);
  }
  getAllMutationBatches(t) {
    const e = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);
    return Cr(t).K("userMutationsIndex", e).next((t2) => t2.map((t3) => Wi(this.wt, t3)));
  }
  getAllMutationBatchesAffectingDocumentKey(t, e) {
    const n = di(this.userId, e.path), s = IDBKeyRange.lowerBound(n), i = [];
    return xr(t).J({
      range: s
    }, (n2, s2, r) => {
      const [o, u, c] = n2, a = li(u);
      if (o === this.userId && e.path.isEqual(a))
        return Cr(t).get(c).next((t2) => {
          if (!t2)
            throw L();
          U(t2.userId === this.userId), i.push(Wi(this.wt, t2));
        });
      r.done();
    }).next(() => i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t, e) {
    let n = new Qt(it);
    const s = [];
    return e.forEach((e2) => {
      const i = di(this.userId, e2.path), r = IDBKeyRange.lowerBound(i), o = xr(t).J({
        range: r
      }, (t2, s2, i2) => {
        const [r2, o2, u] = t2, c = li(o2);
        r2 === this.userId && e2.path.isEqual(c) ? n = n.add(u) : i2.done();
      });
      s.push(o);
    }), Pt.waitFor(s).next(() => this.pn(t, n));
  }
  getAllMutationBatchesAffectingQuery(t, e) {
    const n = e.path, s = n.length + 1, i = di(this.userId, n), r = IDBKeyRange.lowerBound(i);
    let o = new Qt(it);
    return xr(t).J({
      range: r
    }, (t2, e2, i2) => {
      const [r2, u, c] = t2, a = li(u);
      r2 === this.userId && n.isPrefixOf(a) ? a.length === s && (o = o.add(c)) : i2.done();
    }).next(() => this.pn(t, o));
  }
  pn(t, e) {
    const n = [], s = [];
    return e.forEach((e2) => {
      s.push(Cr(t).get(e2).next((t2) => {
        if (null === t2)
          throw L();
        U(t2.userId === this.userId), n.push(Wi(this.wt, t2));
      }));
    }), Pt.waitFor(s).next(() => n);
  }
  removeMutationBatch(t, e) {
    return vr(t.ee, this.userId, e).next((n) => (t.addOnCommittedListener(() => {
      this.In(e.batchId);
    }), Pt.forEach(n, (e2) => this.referenceDelegate.markPotentiallyOrphaned(t, e2))));
  }
  In(t) {
    delete this.gn[t];
  }
  performConsistencyCheck(t) {
    return this.checkEmpty(t).next((e) => {
      if (!e)
        return Pt.resolve();
      const n = IDBKeyRange.lowerBound([this.userId]);
      const s = [];
      return xr(t).J({
        range: n
      }, (t2, e2, n2) => {
        if (t2[0] === this.userId) {
          const e3 = li(t2[1]);
          s.push(e3);
        } else
          n2.done();
      }).next(() => {
        U(0 === s.length);
      });
    });
  }
  containsKey(t, e) {
    return Dr(t, this.userId, e);
  }
  Tn(t) {
    return Nr(t).get(this.userId).next((t2) => t2 || {
      userId: this.userId,
      lastAcknowledgedBatchId: -1,
      lastStreamToken: ""
    });
  }
};
function Dr(t, e, n) {
  const s = di(e, n.path), i = s[1], r = IDBKeyRange.lowerBound(s);
  let o = false;
  return xr(t).J({
    range: r,
    H: true
  }, (t2, n2, s2) => {
    const [r2, u, c] = t2;
    r2 === e && u === i && (o = true), s2.done();
  }).next(() => o);
}
function Cr(t) {
  return Mi(t, "mutations");
}
function xr(t) {
  return Mi(t, "documentMutations");
}
function Nr(t) {
  return Mi(t, "mutationQueues");
}
var kr = class {
  constructor(t) {
    this.En = t;
  }
  next() {
    return this.En += 2, this.En;
  }
  static An() {
    return new kr(0);
  }
  static Rn() {
    return new kr(-1);
  }
};
var Or = class {
  constructor(t, e) {
    this.referenceDelegate = t, this.wt = e;
  }
  allocateTargetId(t) {
    return this.bn(t).next((e) => {
      const n = new kr(e.highestTargetId);
      return e.highestTargetId = n.next(), this.Pn(t, e).next(() => e.highestTargetId);
    });
  }
  getLastRemoteSnapshotVersion(t) {
    return this.bn(t).next((t2) => ct.fromTimestamp(new ut(t2.lastRemoteSnapshotVersion.seconds, t2.lastRemoteSnapshotVersion.nanoseconds)));
  }
  getHighestSequenceNumber(t) {
    return this.bn(t).next((t2) => t2.highestListenSequenceNumber);
  }
  setTargetsMetadata(t, e, n) {
    return this.bn(t).next((s) => (s.highestListenSequenceNumber = e, n && (s.lastRemoteSnapshotVersion = n.toTimestamp()), e > s.highestListenSequenceNumber && (s.highestListenSequenceNumber = e), this.Pn(t, s)));
  }
  addTargetData(t, e) {
    return this.vn(t, e).next(() => this.bn(t).next((n) => (n.targetCount += 1, this.Vn(e, n), this.Pn(t, n))));
  }
  updateTargetData(t, e) {
    return this.vn(t, e);
  }
  removeTargetData(t, e) {
    return this.removeMatchingKeysForTargetId(t, e.targetId).next(() => Mr(t).delete(e.targetId)).next(() => this.bn(t)).next((e2) => (U(e2.targetCount > 0), e2.targetCount -= 1, this.Pn(t, e2)));
  }
  removeTargets(t, e, n) {
    let s = 0;
    const i = [];
    return Mr(t).J((r, o) => {
      const u = zi(o);
      u.sequenceNumber <= e && null === n.get(u.targetId) && (s++, i.push(this.removeTargetData(t, u)));
    }).next(() => Pt.waitFor(i)).next(() => s);
  }
  forEachTarget(t, e) {
    return Mr(t).J((t2, n) => {
      const s = zi(n);
      e(s);
    });
  }
  bn(t) {
    return Fr(t).get("targetGlobalKey").next((t2) => (U(null !== t2), t2));
  }
  Pn(t, e) {
    return Fr(t).put("targetGlobalKey", e);
  }
  vn(t, e) {
    return Mr(t).put(Hi(this.wt, e));
  }
  Vn(t, e) {
    let n = false;
    return t.targetId > e.highestTargetId && (e.highestTargetId = t.targetId, n = true), t.sequenceNumber > e.highestListenSequenceNumber && (e.highestListenSequenceNumber = t.sequenceNumber, n = true), n;
  }
  getTargetCount(t) {
    return this.bn(t).next((t2) => t2.targetCount);
  }
  getTargetData(t, e) {
    const n = Oe(e), s = IDBKeyRange.bound([n, Number.NEGATIVE_INFINITY], [n, Number.POSITIVE_INFINITY]);
    let i = null;
    return Mr(t).J({
      range: s,
      index: "queryTargetsIndex"
    }, (t2, n2, s2) => {
      const r = zi(n2);
      Fe(e, r.target) && (i = r, s2.done());
    }).next(() => i);
  }
  addMatchingKeys(t, e, n) {
    const s = [], i = $r(t);
    return e.forEach((e2) => {
      const r = ci(e2.path);
      s.push(i.put({
        targetId: n,
        path: r
      })), s.push(this.referenceDelegate.addReference(t, n, e2));
    }), Pt.waitFor(s);
  }
  removeMatchingKeys(t, e, n) {
    const s = $r(t);
    return Pt.forEach(e, (e2) => {
      const i = ci(e2.path);
      return Pt.waitFor([s.delete([n, i]), this.referenceDelegate.removeReference(t, n, e2)]);
    });
  }
  removeMatchingKeysForTargetId(t, e) {
    const n = $r(t), s = IDBKeyRange.bound([e], [e + 1], false, true);
    return n.delete(s);
  }
  getMatchingKeysForTargetId(t, e) {
    const n = IDBKeyRange.bound([e], [e + 1], false, true), s = $r(t);
    let i = ws();
    return s.J({
      range: n,
      H: true
    }, (t2, e2, n2) => {
      const s2 = li(t2[1]), r = new dt(s2);
      i = i.add(r);
    }).next(() => i);
  }
  containsKey(t, e) {
    const n = ci(e.path), s = IDBKeyRange.bound([n], [ot(n)], false, true);
    let i = 0;
    return $r(t).J({
      index: "documentTargetsIndex",
      H: true,
      range: s
    }, ([t2, e2], n2, s2) => {
      0 !== t2 && (i++, s2.done());
    }).next(() => i > 0);
  }
  te(t, e) {
    return Mr(t).get(e).next((t2) => t2 ? zi(t2) : null);
  }
};
function Mr(t) {
  return Mi(t, "targets");
}
function Fr(t) {
  return Mi(t, "targetGlobal");
}
function $r(t) {
  return Mi(t, "targetDocuments");
}
function Br([t, e], [n, s]) {
  const i = it(t, n);
  return 0 === i ? it(e, s) : i;
}
var Lr = class {
  constructor(t) {
    this.Sn = t, this.buffer = new Qt(Br), this.Dn = 0;
  }
  Cn() {
    return ++this.Dn;
  }
  xn(t) {
    const e = [t, this.Cn()];
    if (this.buffer.size < this.Sn)
      this.buffer = this.buffer.add(e);
    else {
      const t2 = this.buffer.last();
      Br(e, t2) < 0 && (this.buffer = this.buffer.delete(t2).add(e));
    }
  }
  get maxValue() {
    return this.buffer.last()[0];
  }
};
var Ur = class {
  constructor(t, e, n) {
    this.garbageCollector = t, this.asyncQueue = e, this.localStore = n, this.Nn = null;
  }
  start() {
    -1 !== this.garbageCollector.params.cacheSizeCollectionThreshold && this.kn(6e4);
  }
  stop() {
    this.Nn && (this.Nn.cancel(), this.Nn = null);
  }
  get started() {
    return null !== this.Nn;
  }
  kn(t) {
    M("LruGarbageCollector", `Garbage collection scheduled in ${t}ms`), this.Nn = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", t, async () => {
      this.Nn = null;
      try {
        await this.localStore.collectGarbage(this.garbageCollector);
      } catch (t2) {
        Ct(t2) ? M("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", t2) : await bt(t2);
      }
      await this.kn(3e5);
    });
  }
};
var qr = class {
  constructor(t, e) {
    this.On = t, this.params = e;
  }
  calculateTargetCount(t, e) {
    return this.On.Mn(t).next((t2) => Math.floor(e / 100 * t2));
  }
  nthSequenceNumber(t, e) {
    if (0 === e)
      return Pt.resolve($t.ot);
    const n = new Lr(e);
    return this.On.forEachTarget(t, (t2) => n.xn(t2.sequenceNumber)).next(() => this.On.Fn(t, (t2) => n.xn(t2))).next(() => n.maxValue);
  }
  removeTargets(t, e, n) {
    return this.On.removeTargets(t, e, n);
  }
  removeOrphanedDocuments(t, e) {
    return this.On.removeOrphanedDocuments(t, e);
  }
  collect(t, e) {
    return -1 === this.params.cacheSizeCollectionThreshold ? (M("LruGarbageCollector", "Garbage collection skipped; disabled"), Pt.resolve(br)) : this.getCacheSize(t).next((n) => n < this.params.cacheSizeCollectionThreshold ? (M("LruGarbageCollector", `Garbage collection skipped; Cache size ${n} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`), br) : this.$n(t, e));
  }
  getCacheSize(t) {
    return this.On.getCacheSize(t);
  }
  $n(t, e) {
    let n, s, i, r, o, c, a;
    const h = Date.now();
    return this.calculateTargetCount(t, this.params.percentileToCollect).next((e2) => (e2 > this.params.maximumSequenceNumbersToCollect ? (M("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${e2}`), s = this.params.maximumSequenceNumbersToCollect) : s = e2, r = Date.now(), this.nthSequenceNumber(t, s))).next((s2) => (n = s2, o = Date.now(), this.removeTargets(t, n, e))).next((e2) => (i = e2, c = Date.now(), this.removeOrphanedDocuments(t, n))).next((t2) => {
      if (a = Date.now(), k() <= LogLevel.DEBUG) {
        M("LruGarbageCollector", `LRU Garbage Collection
	Counted targets in ${r - h}ms
	Determined least recently used ${s} in ` + (o - r) + `ms
	Removed ${i} targets in ` + (c - o) + `ms
	Removed ${t2} documents in ` + (a - c) + `ms
Total Duration: ${a - h}ms`);
      }
      return Pt.resolve({
        didRun: true,
        sequenceNumbersCollected: s,
        targetsRemoved: i,
        documentsRemoved: t2
      });
    });
  }
};
var Kr = class {
  constructor(t, e) {
    this.db = t, this.garbageCollector = function(t2, e2) {
      return new qr(t2, e2);
    }(this, e);
  }
  Mn(t) {
    const e = this.Bn(t);
    return this.db.getTargetCache().getTargetCount(t).next((t2) => e.next((e2) => t2 + e2));
  }
  Bn(t) {
    let e = 0;
    return this.Fn(t, (t2) => {
      e++;
    }).next(() => e);
  }
  forEachTarget(t, e) {
    return this.db.getTargetCache().forEachTarget(t, e);
  }
  Fn(t, e) {
    return this.Ln(t, (t2, n) => e(n));
  }
  addReference(t, e, n) {
    return Gr(t, n);
  }
  removeReference(t, e, n) {
    return Gr(t, n);
  }
  removeTargets(t, e, n) {
    return this.db.getTargetCache().removeTargets(t, e, n);
  }
  markPotentiallyOrphaned(t, e) {
    return Gr(t, e);
  }
  Un(t, e) {
    return function(t2, e2) {
      let n = false;
      return Nr(t2).Y((s) => Dr(t2, s, e2).next((t3) => (t3 && (n = true), Pt.resolve(!t3)))).next(() => n);
    }(t, e);
  }
  removeOrphanedDocuments(t, e) {
    const n = this.db.getRemoteDocumentCache().newChangeBuffer(), s = [];
    let i = 0;
    return this.Ln(t, (r, o) => {
      if (o <= e) {
        const e2 = this.Un(t, r).next((e3) => {
          if (!e3)
            return i++, n.getEntry(t, r).next(() => (n.removeEntry(r, ct.min()), $r(t).delete([0, ci(r.path)])));
        });
        s.push(e2);
      }
    }).next(() => Pt.waitFor(s)).next(() => n.apply(t)).next(() => i);
  }
  removeTarget(t, e) {
    const n = e.withSequenceNumber(t.currentSequenceNumber);
    return this.db.getTargetCache().updateTargetData(t, n);
  }
  updateLimboDocument(t, e) {
    return Gr(t, e);
  }
  Ln(t, e) {
    const n = $r(t);
    let s, i = $t.ot;
    return n.J({
      index: "documentTargetsIndex"
    }, ([t2, n2], { path: r, sequenceNumber: o }) => {
      0 === t2 ? (i !== $t.ot && e(new dt(li(s)), i), i = o, s = r) : i = $t.ot;
    }).next(() => {
      i !== $t.ot && e(new dt(li(s)), i);
    });
  }
  getCacheSize(t) {
    return this.db.getRemoteDocumentCache().getSize(t);
  }
};
function Gr(t, e) {
  return $r(t).put(function(t2, e2) {
    return {
      targetId: 0,
      path: ci(t2.path),
      sequenceNumber: e2
    };
  }(e, t.currentSequenceNumber));
}
var Qr = class {
  constructor() {
    this.changes = new is((t) => t.toString(), (t, e) => t.isEqual(e)), this.changesApplied = false;
  }
  addEntry(t) {
    this.assertNotApplied(), this.changes.set(t.key, t);
  }
  removeEntry(t, e) {
    this.assertNotApplied(), this.changes.set(t, xe.newInvalidDocument(t).setReadTime(e));
  }
  getEntry(t, e) {
    this.assertNotApplied();
    const n = this.changes.get(e);
    return void 0 !== n ? Pt.resolve(n) : this.getFromCache(t, e);
  }
  getEntries(t, e) {
    return this.getAllFromCache(t, e);
  }
  apply(t) {
    return this.assertNotApplied(), this.changesApplied = true, this.applyChanges(t);
  }
  assertNotApplied() {
  }
};
var jr = class {
  constructor(t) {
    this.wt = t;
  }
  setIndexManager(t) {
    this.indexManager = t;
  }
  addEntry(t, e, n) {
    return Jr(t).put(n);
  }
  removeEntry(t, e, n) {
    return Jr(t).delete(function(t2, e2) {
      const n2 = t2.path.toArray();
      return [
        n2.slice(0, n2.length - 2),
        n2[n2.length - 2],
        Gi(e2),
        n2[n2.length - 1]
      ];
    }(e, n));
  }
  updateMetadata(t, e) {
    return this.getMetadata(t).next((n) => (n.byteSize += e, this.qn(t, n)));
  }
  getEntry(t, e) {
    let n = xe.newInvalidDocument(e);
    return Jr(t).J({
      index: "documentKeyIndex",
      range: IDBKeyRange.only(Yr(e))
    }, (t2, s) => {
      n = this.Kn(e, s);
    }).next(() => n);
  }
  Gn(t, e) {
    let n = {
      size: 0,
      document: xe.newInvalidDocument(e)
    };
    return Jr(t).J({
      index: "documentKeyIndex",
      range: IDBKeyRange.only(Yr(e))
    }, (t2, s) => {
      n = {
        document: this.Kn(e, s),
        size: Vr(s)
      };
    }).next(() => n);
  }
  getEntries(t, e) {
    let n = os();
    return this.Qn(t, e, (t2, e2) => {
      const s = this.Kn(t2, e2);
      n = n.insert(t2, s);
    }).next(() => n);
  }
  jn(t, e) {
    let n = os(), s = new qt(dt.comparator);
    return this.Qn(t, e, (t2, e2) => {
      const i = this.Kn(t2, e2);
      n = n.insert(t2, i), s = s.insert(t2, Vr(e2));
    }).next(() => ({
      documents: n,
      Wn: s
    }));
  }
  Qn(t, e, n) {
    if (e.isEmpty())
      return Pt.resolve();
    let s = new Qt(Zr);
    e.forEach((t2) => s = s.add(t2));
    const i = IDBKeyRange.bound(Yr(s.first()), Yr(s.last())), r = s.getIterator();
    let o = r.getNext();
    return Jr(t).J({
      index: "documentKeyIndex",
      range: i
    }, (t2, e2, s2) => {
      const i2 = dt.fromSegments([...e2.prefixPath, e2.collectionGroup, e2.documentId]);
      for (; o && Zr(o, i2) < 0; )
        n(o, null), o = r.getNext();
      o && o.isEqual(i2) && (n(o, e2), o = r.hasNext() ? r.getNext() : null), o ? s2.q(Yr(o)) : s2.done();
    }).next(() => {
      for (; o; )
        n(o, null), o = r.hasNext() ? r.getNext() : null;
    });
  }
  getAllFromCollection(t, e, n) {
    const s = [e.popLast().toArray(), e.lastSegment(), Gi(n.readTime), n.documentKey.path.isEmpty() ? "" : n.documentKey.path.lastSegment()], i = [e.popLast().toArray(), e.lastSegment(), [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], ""];
    return Jr(t).K(IDBKeyRange.bound(s, i, true)).next((t2) => {
      let e2 = os();
      for (const n2 of t2) {
        const t3 = this.Kn(dt.fromSegments(n2.prefixPath.concat(n2.collectionGroup, n2.documentId)), n2);
        e2 = e2.insert(t3.key, t3);
      }
      return e2;
    });
  }
  getAllFromCollectionGroup(t, e, n, s) {
    let i = os();
    const r = Xr(e, n), o = Xr(e, Tt.max());
    return Jr(t).J({
      index: "collectionGroupIndex",
      range: IDBKeyRange.bound(r, o, true)
    }, (t2, e2, n2) => {
      const r2 = this.Kn(dt.fromSegments(e2.prefixPath.concat(e2.collectionGroup, e2.documentId)), e2);
      i = i.insert(r2.key, r2), i.size === s && n2.done();
    }).next(() => i);
  }
  newChangeBuffer(t) {
    return new zr(this, !!t && t.trackRemovals);
  }
  getSize(t) {
    return this.getMetadata(t).next((t2) => t2.byteSize);
  }
  getMetadata(t) {
    return Hr(t).get("remoteDocumentGlobalKey").next((t2) => (U(!!t2), t2));
  }
  qn(t, e) {
    return Hr(t).put("remoteDocumentGlobalKey", e);
  }
  Kn(t, e) {
    if (e) {
      const t2 = qi(this.wt, e);
      if (!(t2.isNoDocument() && t2.version.isEqual(ct.min())))
        return t2;
    }
    return xe.newInvalidDocument(t);
  }
};
function Wr(t) {
  return new jr(t);
}
var zr = class extends Qr {
  constructor(t, e) {
    super(), this.zn = t, this.trackRemovals = e, this.Hn = new is((t2) => t2.toString(), (t2, e2) => t2.isEqual(e2));
  }
  applyChanges(t) {
    const e = [];
    let n = 0, s = new Qt((t2, e2) => it(t2.canonicalString(), e2.canonicalString()));
    return this.changes.forEach((i, r) => {
      const o = this.Hn.get(i);
      if (e.push(this.zn.removeEntry(t, i, o.readTime)), r.isValidDocument()) {
        const u = Ki(this.zn.wt, r);
        s = s.add(i.path.popLast());
        const c = Vr(u);
        n += c - o.size, e.push(this.zn.addEntry(t, i, u));
      } else if (n -= o.size, this.trackRemovals) {
        const n2 = Ki(this.zn.wt, r.convertToNoDocument(ct.min()));
        e.push(this.zn.addEntry(t, i, n2));
      }
    }), s.forEach((n2) => {
      e.push(this.zn.indexManager.addToCollectionParentIndex(t, n2));
    }), e.push(this.zn.updateMetadata(t, n)), Pt.waitFor(e);
  }
  getFromCache(t, e) {
    return this.zn.Gn(t, e).next((t2) => (this.Hn.set(e, {
      size: t2.size,
      readTime: t2.document.readTime
    }), t2.document));
  }
  getAllFromCache(t, e) {
    return this.zn.jn(t, e).next(({ documents: t2, Wn: e2 }) => (e2.forEach((e3, n) => {
      this.Hn.set(e3, {
        size: n,
        readTime: t2.get(e3).readTime
      });
    }), t2));
  }
};
function Hr(t) {
  return Mi(t, "remoteDocumentGlobal");
}
function Jr(t) {
  return Mi(t, "remoteDocumentsV14");
}
function Yr(t) {
  const e = t.path.toArray();
  return [
    e.slice(0, e.length - 2),
    e[e.length - 2],
    e[e.length - 1]
  ];
}
function Xr(t, e) {
  const n = e.documentKey.path.toArray();
  return [
    t,
    Gi(e.readTime),
    n.slice(0, n.length - 2),
    n.length > 0 ? n[n.length - 1] : ""
  ];
}
function Zr(t, e) {
  const n = t.path.toArray(), s = e.path.toArray();
  let i = 0;
  for (let t2 = 0; t2 < n.length - 2 && t2 < s.length - 2; ++t2)
    if (i = it(n[t2], s[t2]), i)
      return i;
  return i = it(n.length, s.length), i || (i = it(n[n.length - 2], s[s.length - 2]), i || it(n[n.length - 1], s[s.length - 1]));
}
var to = class {
  constructor(t, e) {
    this.overlayedDocument = t, this.mutatedFields = e;
  }
};
var eo = class {
  constructor(t, e, n, s) {
    this.remoteDocumentCache = t, this.mutationQueue = e, this.documentOverlayCache = n, this.indexManager = s;
  }
  getDocument(t, e) {
    let n = null;
    return this.documentOverlayCache.getOverlay(t, e).next((s) => (n = s, this.getBaseDocument(t, e, n))).next((t2) => (null !== n && Kn(n.mutation, t2, zt.empty(), ut.now()), t2));
  }
  getDocuments(t, e) {
    return this.remoteDocumentCache.getEntries(t, e).next((e2) => this.getLocalViewOfDocuments(t, e2, ws()).next(() => e2));
  }
  getLocalViewOfDocuments(t, e, n = ws()) {
    const s = hs();
    return this.populateOverlays(t, s, e).next(() => this.computeViews(t, e, s, n).next((t2) => {
      let e2 = cs();
      return t2.forEach((t3, n2) => {
        e2 = e2.insert(t3, n2.overlayedDocument);
      }), e2;
    }));
  }
  getOverlayedDocuments(t, e) {
    const n = hs();
    return this.populateOverlays(t, n, e).next(() => this.computeViews(t, e, n, ws()));
  }
  populateOverlays(t, e, n) {
    const s = [];
    return n.forEach((t2) => {
      e.has(t2) || s.push(t2);
    }), this.documentOverlayCache.getOverlays(t, s).next((t2) => {
      t2.forEach((t3, n2) => {
        e.set(t3, n2);
      });
    });
  }
  computeViews(t, e, n, s) {
    let i = os();
    const r = fs(), o = fs();
    return e.forEach((t2, e2) => {
      const o2 = n.get(e2.key);
      s.has(e2.key) && (void 0 === o2 || o2.mutation instanceof Wn) ? i = i.insert(e2.key, e2) : void 0 !== o2 && (r.set(e2.key, o2.mutation.getFieldMask()), Kn(o2.mutation, e2, o2.mutation.getFieldMask(), ut.now()));
    }), this.recalculateAndSaveOverlays(t, i).next((t2) => (t2.forEach((t3, e2) => r.set(t3, e2)), e.forEach((t3, e2) => {
      var n2;
      return o.set(t3, new to(e2, null !== (n2 = r.get(t3)) && void 0 !== n2 ? n2 : null));
    }), o));
  }
  recalculateAndSaveOverlays(t, e) {
    const n = fs();
    let s = new qt((t2, e2) => t2 - e2), i = ws();
    return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(t, e).next((t2) => {
      for (const i2 of t2)
        i2.keys().forEach((t3) => {
          const r = e.get(t3);
          if (null === r)
            return;
          let o = n.get(t3) || zt.empty();
          o = i2.applyToLocalView(r, o), n.set(t3, o);
          const u = (s.get(i2.batchId) || ws()).add(t3);
          s = s.insert(i2.batchId, u);
        });
    }).next(() => {
      const r = [], o = s.getReverseIterator();
      for (; o.hasNext(); ) {
        const s2 = o.getNext(), u = s2.key, c = s2.value, a = ls();
        c.forEach((t2) => {
          if (!i.has(t2)) {
            const s3 = Un(e.get(t2), n.get(t2));
            null !== s3 && a.set(t2, s3), i = i.add(t2);
          }
        }), r.push(this.documentOverlayCache.saveOverlays(t, u, a));
      }
      return Pt.waitFor(r);
    }).next(() => n);
  }
  recalculateAndSaveOverlaysForDocumentKeys(t, e) {
    return this.remoteDocumentCache.getEntries(t, e).next((e2) => this.recalculateAndSaveOverlays(t, e2));
  }
  getDocumentsMatchingQuery(t, e, n) {
    return function(t2) {
      return dt.isDocumentKey(t2.path) && null === t2.collectionGroup && 0 === t2.filters.length;
    }(e) ? this.getDocumentsMatchingDocumentQuery(t, e.path) : an(e) ? this.getDocumentsMatchingCollectionGroupQuery(t, e, n) : this.getDocumentsMatchingCollectionQuery(t, e, n);
  }
  getNextDocuments(t, e, n, s) {
    return this.remoteDocumentCache.getAllFromCollectionGroup(t, e, n, s).next((i) => {
      const r = s - i.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(t, e, n.largestBatchId, s - i.size) : Pt.resolve(hs());
      let o = -1, u = i;
      return r.next((e2) => Pt.forEach(e2, (e3, n2) => (o < n2.largestBatchId && (o = n2.largestBatchId), i.get(e3) ? Pt.resolve() : this.getBaseDocument(t, e3, n2).next((t2) => {
        u = u.insert(e3, t2);
      }))).next(() => this.populateOverlays(t, e2, i)).next(() => this.computeViews(t, u, e2, ws())).next((t2) => ({
        batchId: o,
        changes: as(t2)
      })));
    });
  }
  getDocumentsMatchingDocumentQuery(t, e) {
    return this.getDocument(t, new dt(e)).next((t2) => {
      let e2 = cs();
      return t2.isFoundDocument() && (e2 = e2.insert(t2.key, t2)), e2;
    });
  }
  getDocumentsMatchingCollectionGroupQuery(t, e, n) {
    const s = e.collectionGroup;
    let i = cs();
    return this.indexManager.getCollectionParents(t, s).next((r) => Pt.forEach(r, (r2) => {
      const o = function(t2, e2) {
        return new nn(e2, null, t2.explicitOrderBy.slice(), t2.filters.slice(), t2.limit, t2.limitType, t2.startAt, t2.endAt);
      }(e, r2.child(s));
      return this.getDocumentsMatchingCollectionQuery(t, o, n).next((t2) => {
        t2.forEach((t3, e2) => {
          i = i.insert(t3, e2);
        });
      });
    }).next(() => i));
  }
  getDocumentsMatchingCollectionQuery(t, e, n) {
    let s;
    return this.remoteDocumentCache.getAllFromCollection(t, e.path, n).next((i) => (s = i, this.documentOverlayCache.getOverlaysForCollection(t, e.path, n.largestBatchId))).next((t2) => {
      t2.forEach((t3, e2) => {
        const n3 = e2.getKey();
        null === s.get(n3) && (s = s.insert(n3, xe.newInvalidDocument(n3)));
      });
      let n2 = cs();
      return s.forEach((s2, i) => {
        const r = t2.get(s2);
        void 0 !== r && Kn(r.mutation, i, zt.empty(), ut.now()), mn(e, i) && (n2 = n2.insert(s2, i));
      }), n2;
    });
  }
  getBaseDocument(t, e, n) {
    return null === n || 1 === n.mutation.type ? this.remoteDocumentCache.getEntry(t, e) : Pt.resolve(xe.newInvalidDocument(e));
  }
};
var no = class {
  constructor(t) {
    this.wt = t, this.Jn = /* @__PURE__ */ new Map(), this.Yn = /* @__PURE__ */ new Map();
  }
  getBundleMetadata(t, e) {
    return Pt.resolve(this.Jn.get(e));
  }
  saveBundleMetadata(t, e) {
    var n;
    return this.Jn.set(e.id, {
      id: (n = e).id,
      version: n.version,
      createTime: Ns(n.createTime)
    }), Pt.resolve();
  }
  getNamedQuery(t, e) {
    return Pt.resolve(this.Yn.get(e));
  }
  saveNamedQuery(t, e) {
    return this.Yn.set(e.name, function(t2) {
      return {
        name: t2.name,
        query: Ji(t2.bundledQuery),
        readTime: Ns(t2.readTime)
      };
    }(e)), Pt.resolve();
  }
};
var so = class {
  constructor() {
    this.overlays = new qt(dt.comparator), this.Xn = /* @__PURE__ */ new Map();
  }
  getOverlay(t, e) {
    return Pt.resolve(this.overlays.get(e));
  }
  getOverlays(t, e) {
    const n = hs();
    return Pt.forEach(e, (e2) => this.getOverlay(t, e2).next((t2) => {
      null !== t2 && n.set(e2, t2);
    })).next(() => n);
  }
  saveOverlays(t, e, n) {
    return n.forEach((n2, s) => {
      this.ie(t, e, s);
    }), Pt.resolve();
  }
  removeOverlaysForBatchId(t, e, n) {
    const s = this.Xn.get(n);
    return void 0 !== s && (s.forEach((t2) => this.overlays = this.overlays.remove(t2)), this.Xn.delete(n)), Pt.resolve();
  }
  getOverlaysForCollection(t, e, n) {
    const s = hs(), i = e.length + 1, r = new dt(e.child("")), o = this.overlays.getIteratorFrom(r);
    for (; o.hasNext(); ) {
      const t2 = o.getNext().value, r2 = t2.getKey();
      if (!e.isPrefixOf(r2.path))
        break;
      r2.path.length === i && (t2.largestBatchId > n && s.set(t2.getKey(), t2));
    }
    return Pt.resolve(s);
  }
  getOverlaysForCollectionGroup(t, e, n, s) {
    let i = new qt((t2, e2) => t2 - e2);
    const r = this.overlays.getIterator();
    for (; r.hasNext(); ) {
      const t2 = r.getNext().value;
      if (t2.getKey().getCollectionGroup() === e && t2.largestBatchId > n) {
        let e2 = i.get(t2.largestBatchId);
        null === e2 && (e2 = hs(), i = i.insert(t2.largestBatchId, e2)), e2.set(t2.getKey(), t2);
      }
    }
    const o = hs(), u = i.getIterator();
    for (; u.hasNext(); ) {
      if (u.getNext().value.forEach((t2, e2) => o.set(t2, e2)), o.size() >= s)
        break;
    }
    return Pt.resolve(o);
  }
  ie(t, e, n) {
    const s = this.overlays.get(n.key);
    if (null !== s) {
      const t2 = this.Xn.get(s.largestBatchId).delete(n.key);
      this.Xn.set(s.largestBatchId, t2);
    }
    this.overlays = this.overlays.insert(n.key, new Bi(e, n));
    let i = this.Xn.get(e);
    void 0 === i && (i = ws(), this.Xn.set(e, i)), this.Xn.set(e, i.add(n.key));
  }
};
var io = class {
  constructor() {
    this.Zn = new Qt(ro.ts), this.es = new Qt(ro.ns);
  }
  isEmpty() {
    return this.Zn.isEmpty();
  }
  addReference(t, e) {
    const n = new ro(t, e);
    this.Zn = this.Zn.add(n), this.es = this.es.add(n);
  }
  ss(t, e) {
    t.forEach((t2) => this.addReference(t2, e));
  }
  removeReference(t, e) {
    this.rs(new ro(t, e));
  }
  os(t, e) {
    t.forEach((t2) => this.removeReference(t2, e));
  }
  us(t) {
    const e = new dt(new ht([])), n = new ro(e, t), s = new ro(e, t + 1), i = [];
    return this.es.forEachInRange([n, s], (t2) => {
      this.rs(t2), i.push(t2.key);
    }), i;
  }
  cs() {
    this.Zn.forEach((t) => this.rs(t));
  }
  rs(t) {
    this.Zn = this.Zn.delete(t), this.es = this.es.delete(t);
  }
  hs(t) {
    const e = new dt(new ht([])), n = new ro(e, t), s = new ro(e, t + 1);
    let i = ws();
    return this.es.forEachInRange([n, s], (t2) => {
      i = i.add(t2.key);
    }), i;
  }
  containsKey(t) {
    const e = new ro(t, 0), n = this.Zn.firstAfterOrEqual(e);
    return null !== n && t.isEqual(n.key);
  }
};
var ro = class {
  constructor(t, e) {
    this.key = t, this.ls = e;
  }
  static ts(t, e) {
    return dt.comparator(t.key, e.key) || it(t.ls, e.ls);
  }
  static ns(t, e) {
    return it(t.ls, e.ls) || dt.comparator(t.key, e.key);
  }
};
var oo = class {
  constructor(t, e) {
    this.indexManager = t, this.referenceDelegate = e, this.mutationQueue = [], this.fs = 1, this.ds = new Qt(ro.ts);
  }
  checkEmpty(t) {
    return Pt.resolve(0 === this.mutationQueue.length);
  }
  addMutationBatch(t, e, n, s) {
    const i = this.fs;
    this.fs++, this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1];
    const r = new Fi(i, e, n, s);
    this.mutationQueue.push(r);
    for (const e2 of s)
      this.ds = this.ds.add(new ro(e2.key, i)), this.indexManager.addToCollectionParentIndex(t, e2.key.path.popLast());
    return Pt.resolve(r);
  }
  lookupMutationBatch(t, e) {
    return Pt.resolve(this._s(e));
  }
  getNextMutationBatchAfterBatchId(t, e) {
    const n = e + 1, s = this.ws(n), i = s < 0 ? 0 : s;
    return Pt.resolve(this.mutationQueue.length > i ? this.mutationQueue[i] : null);
  }
  getHighestUnacknowledgedBatchId() {
    return Pt.resolve(0 === this.mutationQueue.length ? -1 : this.fs - 1);
  }
  getAllMutationBatches(t) {
    return Pt.resolve(this.mutationQueue.slice());
  }
  getAllMutationBatchesAffectingDocumentKey(t, e) {
    const n = new ro(e, 0), s = new ro(e, Number.POSITIVE_INFINITY), i = [];
    return this.ds.forEachInRange([n, s], (t2) => {
      const e2 = this._s(t2.ls);
      i.push(e2);
    }), Pt.resolve(i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t, e) {
    let n = new Qt(it);
    return e.forEach((t2) => {
      const e2 = new ro(t2, 0), s = new ro(t2, Number.POSITIVE_INFINITY);
      this.ds.forEachInRange([e2, s], (t3) => {
        n = n.add(t3.ls);
      });
    }), Pt.resolve(this.gs(n));
  }
  getAllMutationBatchesAffectingQuery(t, e) {
    const n = e.path, s = n.length + 1;
    let i = n;
    dt.isDocumentKey(i) || (i = i.child(""));
    const r = new ro(new dt(i), 0);
    let o = new Qt(it);
    return this.ds.forEachWhile((t2) => {
      const e2 = t2.key.path;
      return !!n.isPrefixOf(e2) && (e2.length === s && (o = o.add(t2.ls)), true);
    }, r), Pt.resolve(this.gs(o));
  }
  gs(t) {
    const e = [];
    return t.forEach((t2) => {
      const n = this._s(t2);
      null !== n && e.push(n);
    }), e;
  }
  removeMutationBatch(t, e) {
    U(0 === this.ys(e.batchId, "removed")), this.mutationQueue.shift();
    let n = this.ds;
    return Pt.forEach(e.mutations, (s) => {
      const i = new ro(s.key, e.batchId);
      return n = n.delete(i), this.referenceDelegate.markPotentiallyOrphaned(t, s.key);
    }).next(() => {
      this.ds = n;
    });
  }
  In(t) {
  }
  containsKey(t, e) {
    const n = new ro(e, 0), s = this.ds.firstAfterOrEqual(n);
    return Pt.resolve(e.isEqual(s && s.key));
  }
  performConsistencyCheck(t) {
    return this.mutationQueue.length, Pt.resolve();
  }
  ys(t, e) {
    return this.ws(t);
  }
  ws(t) {
    if (0 === this.mutationQueue.length)
      return 0;
    return t - this.mutationQueue[0].batchId;
  }
  _s(t) {
    const e = this.ws(t);
    if (e < 0 || e >= this.mutationQueue.length)
      return null;
    return this.mutationQueue[e];
  }
};
var uo = class {
  constructor(t) {
    this.ps = t, this.docs = new qt(dt.comparator), this.size = 0;
  }
  setIndexManager(t) {
    this.indexManager = t;
  }
  addEntry(t, e) {
    const n = e.key, s = this.docs.get(n), i = s ? s.size : 0, r = this.ps(e);
    return this.docs = this.docs.insert(n, {
      document: e.mutableCopy(),
      size: r
    }), this.size += r - i, this.indexManager.addToCollectionParentIndex(t, n.path.popLast());
  }
  removeEntry(t) {
    const e = this.docs.get(t);
    e && (this.docs = this.docs.remove(t), this.size -= e.size);
  }
  getEntry(t, e) {
    const n = this.docs.get(e);
    return Pt.resolve(n ? n.document.mutableCopy() : xe.newInvalidDocument(e));
  }
  getEntries(t, e) {
    let n = os();
    return e.forEach((t2) => {
      const e2 = this.docs.get(t2);
      n = n.insert(t2, e2 ? e2.document.mutableCopy() : xe.newInvalidDocument(t2));
    }), Pt.resolve(n);
  }
  getAllFromCollection(t, e, n) {
    let s = os();
    const i = new dt(e.child("")), r = this.docs.getIteratorFrom(i);
    for (; r.hasNext(); ) {
      const { key: t2, value: { document: i2 } } = r.getNext();
      if (!e.isPrefixOf(t2.path))
        break;
      t2.path.length > e.length + 1 || (Et(It(i2), n) <= 0 || (s = s.insert(i2.key, i2.mutableCopy())));
    }
    return Pt.resolve(s);
  }
  getAllFromCollectionGroup(t, e, n, s) {
    L();
  }
  Is(t, e) {
    return Pt.forEach(this.docs, (t2) => e(t2));
  }
  newChangeBuffer(t) {
    return new co(this);
  }
  getSize(t) {
    return Pt.resolve(this.size);
  }
};
var co = class extends Qr {
  constructor(t) {
    super(), this.zn = t;
  }
  applyChanges(t) {
    const e = [];
    return this.changes.forEach((n, s) => {
      s.isValidDocument() ? e.push(this.zn.addEntry(t, s)) : this.zn.removeEntry(n);
    }), Pt.waitFor(e);
  }
  getFromCache(t, e) {
    return this.zn.getEntry(t, e);
  }
  getAllFromCache(t, e) {
    return this.zn.getEntries(t, e);
  }
};
var ao = class {
  constructor(t) {
    this.persistence = t, this.Ts = new is((t2) => Oe(t2), Fe), this.lastRemoteSnapshotVersion = ct.min(), this.highestTargetId = 0, this.Es = 0, this.As = new io(), this.targetCount = 0, this.Rs = kr.An();
  }
  forEachTarget(t, e) {
    return this.Ts.forEach((t2, n) => e(n)), Pt.resolve();
  }
  getLastRemoteSnapshotVersion(t) {
    return Pt.resolve(this.lastRemoteSnapshotVersion);
  }
  getHighestSequenceNumber(t) {
    return Pt.resolve(this.Es);
  }
  allocateTargetId(t) {
    return this.highestTargetId = this.Rs.next(), Pt.resolve(this.highestTargetId);
  }
  setTargetsMetadata(t, e, n) {
    return n && (this.lastRemoteSnapshotVersion = n), e > this.Es && (this.Es = e), Pt.resolve();
  }
  vn(t) {
    this.Ts.set(t.target, t);
    const e = t.targetId;
    e > this.highestTargetId && (this.Rs = new kr(e), this.highestTargetId = e), t.sequenceNumber > this.Es && (this.Es = t.sequenceNumber);
  }
  addTargetData(t, e) {
    return this.vn(e), this.targetCount += 1, Pt.resolve();
  }
  updateTargetData(t, e) {
    return this.vn(e), Pt.resolve();
  }
  removeTargetData(t, e) {
    return this.Ts.delete(e.target), this.As.us(e.targetId), this.targetCount -= 1, Pt.resolve();
  }
  removeTargets(t, e, n) {
    let s = 0;
    const i = [];
    return this.Ts.forEach((r, o) => {
      o.sequenceNumber <= e && null === n.get(o.targetId) && (this.Ts.delete(r), i.push(this.removeMatchingKeysForTargetId(t, o.targetId)), s++);
    }), Pt.waitFor(i).next(() => s);
  }
  getTargetCount(t) {
    return Pt.resolve(this.targetCount);
  }
  getTargetData(t, e) {
    const n = this.Ts.get(e) || null;
    return Pt.resolve(n);
  }
  addMatchingKeys(t, e, n) {
    return this.As.ss(e, n), Pt.resolve();
  }
  removeMatchingKeys(t, e, n) {
    this.As.os(e, n);
    const s = this.persistence.referenceDelegate, i = [];
    return s && e.forEach((e2) => {
      i.push(s.markPotentiallyOrphaned(t, e2));
    }), Pt.waitFor(i);
  }
  removeMatchingKeysForTargetId(t, e) {
    return this.As.us(e), Pt.resolve();
  }
  getMatchingKeysForTargetId(t, e) {
    const n = this.As.hs(e);
    return Pt.resolve(n);
  }
  containsKey(t, e) {
    return Pt.resolve(this.As.containsKey(e));
  }
};
var ho = class {
  constructor(t, e) {
    this.bs = {}, this.overlays = {}, this.Ps = new $t(0), this.vs = false, this.vs = true, this.referenceDelegate = t(this), this.Vs = new ao(this);
    this.indexManager = new mr(), this.remoteDocumentCache = function(t2) {
      return new uo(t2);
    }((t2) => this.referenceDelegate.Ss(t2)), this.wt = new Ui(e), this.Ds = new no(this.wt);
  }
  start() {
    return Promise.resolve();
  }
  shutdown() {
    return this.vs = false, Promise.resolve();
  }
  get started() {
    return this.vs;
  }
  setDatabaseDeletedListener() {
  }
  setNetworkEnabled() {
  }
  getIndexManager(t) {
    return this.indexManager;
  }
  getDocumentOverlayCache(t) {
    let e = this.overlays[t.toKey()];
    return e || (e = new so(), this.overlays[t.toKey()] = e), e;
  }
  getMutationQueue(t, e) {
    let n = this.bs[t.toKey()];
    return n || (n = new oo(e, this.referenceDelegate), this.bs[t.toKey()] = n), n;
  }
  getTargetCache() {
    return this.Vs;
  }
  getRemoteDocumentCache() {
    return this.remoteDocumentCache;
  }
  getBundleCache() {
    return this.Ds;
  }
  runTransaction(t, e, n) {
    M("MemoryPersistence", "Starting transaction:", t);
    const s = new lo(this.Ps.next());
    return this.referenceDelegate.Cs(), n(s).next((t2) => this.referenceDelegate.xs(s).next(() => t2)).toPromise().then((t2) => (s.raiseOnCommittedEvent(), t2));
  }
  Ns(t, e) {
    return Pt.or(Object.values(this.bs).map((n) => () => n.containsKey(t, e)));
  }
};
var lo = class extends Rt {
  constructor(t) {
    super(), this.currentSequenceNumber = t;
  }
};
var fo = class {
  constructor(t) {
    this.persistence = t, this.ks = new io(), this.Os = null;
  }
  static Ms(t) {
    return new fo(t);
  }
  get Fs() {
    if (this.Os)
      return this.Os;
    throw L();
  }
  addReference(t, e, n) {
    return this.ks.addReference(n, e), this.Fs.delete(n.toString()), Pt.resolve();
  }
  removeReference(t, e, n) {
    return this.ks.removeReference(n, e), this.Fs.add(n.toString()), Pt.resolve();
  }
  markPotentiallyOrphaned(t, e) {
    return this.Fs.add(e.toString()), Pt.resolve();
  }
  removeTarget(t, e) {
    this.ks.us(e.targetId).forEach((t2) => this.Fs.add(t2.toString()));
    const n = this.persistence.getTargetCache();
    return n.getMatchingKeysForTargetId(t, e.targetId).next((t2) => {
      t2.forEach((t3) => this.Fs.add(t3.toString()));
    }).next(() => n.removeTargetData(t, e));
  }
  Cs() {
    this.Os = /* @__PURE__ */ new Set();
  }
  xs(t) {
    const e = this.persistence.getRemoteDocumentCache().newChangeBuffer();
    return Pt.forEach(this.Fs, (n) => {
      const s = dt.fromPath(n);
      return this.$s(t, s).next((t2) => {
        t2 || e.removeEntry(s, ct.min());
      });
    }).next(() => (this.Os = null, e.apply(t)));
  }
  updateLimboDocument(t, e) {
    return this.$s(t, e).next((t2) => {
      t2 ? this.Fs.delete(e.toString()) : this.Fs.add(e.toString());
    });
  }
  Ss(t) {
    return 0;
  }
  $s(t, e) {
    return Pt.or([() => Pt.resolve(this.ks.containsKey(e)), () => this.persistence.getTargetCache().containsKey(t, e), () => this.persistence.Ns(t, e)]);
  }
};
var _o = class {
  constructor(t) {
    this.wt = t;
  }
  O(t, e, n, s) {
    const i = new vt("createOrUpgrade", e);
    n < 1 && s >= 1 && (function(t2) {
      t2.createObjectStore("owner");
    }(t), function(t2) {
      t2.createObjectStore("mutationQueues", {
        keyPath: "userId"
      });
      t2.createObjectStore("mutations", {
        keyPath: "batchId",
        autoIncrement: true
      }).createIndex("userMutationsIndex", fi, {
        unique: true
      }), t2.createObjectStore("documentMutations");
    }(t), wo(t), function(t2) {
      t2.createObjectStore("remoteDocuments");
    }(t));
    let r = Pt.resolve();
    return n < 3 && s >= 3 && (0 !== n && (!function(t2) {
      t2.deleteObjectStore("targetDocuments"), t2.deleteObjectStore("targets"), t2.deleteObjectStore("targetGlobal");
    }(t), wo(t)), r = r.next(() => function(t2) {
      const e2 = t2.store("targetGlobal"), n2 = {
        highestTargetId: 0,
        highestListenSequenceNumber: 0,
        lastRemoteSnapshotVersion: ct.min().toTimestamp(),
        targetCount: 0
      };
      return e2.put("targetGlobalKey", n2);
    }(i))), n < 4 && s >= 4 && (0 !== n && (r = r.next(() => function(t2, e2) {
      return e2.store("mutations").K().next((n2) => {
        t2.deleteObjectStore("mutations");
        t2.createObjectStore("mutations", {
          keyPath: "batchId",
          autoIncrement: true
        }).createIndex("userMutationsIndex", fi, {
          unique: true
        });
        const s2 = e2.store("mutations"), i2 = n2.map((t3) => s2.put(t3));
        return Pt.waitFor(i2);
      });
    }(t, i))), r = r.next(() => {
      !function(t2) {
        t2.createObjectStore("clientMetadata", {
          keyPath: "clientId"
        });
      }(t);
    })), n < 5 && s >= 5 && (r = r.next(() => this.Bs(i))), n < 6 && s >= 6 && (r = r.next(() => (function(t2) {
      t2.createObjectStore("remoteDocumentGlobal");
    }(t), this.Ls(i)))), n < 7 && s >= 7 && (r = r.next(() => this.Us(i))), n < 8 && s >= 8 && (r = r.next(() => this.qs(t, i))), n < 9 && s >= 9 && (r = r.next(() => {
      !function(t2) {
        t2.objectStoreNames.contains("remoteDocumentChanges") && t2.deleteObjectStore("remoteDocumentChanges");
      }(t);
    })), n < 10 && s >= 10 && (r = r.next(() => this.Ks(i))), n < 11 && s >= 11 && (r = r.next(() => {
      !function(t2) {
        t2.createObjectStore("bundles", {
          keyPath: "bundleId"
        });
      }(t), function(t2) {
        t2.createObjectStore("namedQueries", {
          keyPath: "name"
        });
      }(t);
    })), n < 12 && s >= 12 && (r = r.next(() => {
      !function(t2) {
        const e2 = t2.createObjectStore("documentOverlays", {
          keyPath: vi
        });
        e2.createIndex("collectionPathOverlayIndex", Vi, {
          unique: false
        }), e2.createIndex("collectionGroupOverlayIndex", Si, {
          unique: false
        });
      }(t);
    })), n < 13 && s >= 13 && (r = r.next(() => function(t2) {
      const e2 = t2.createObjectStore("remoteDocumentsV14", {
        keyPath: mi
      });
      e2.createIndex("documentKeyIndex", gi), e2.createIndex("collectionGroupIndex", yi);
    }(t)).next(() => this.Gs(t, i)).next(() => t.deleteObjectStore("remoteDocuments"))), n < 14 && s >= 14 && (r = r.next(() => this.Qs(t, i))), n < 15 && s >= 15 && (r = r.next(() => function(t2) {
      t2.createObjectStore("indexConfiguration", {
        keyPath: "indexId",
        autoIncrement: true
      }).createIndex("collectionGroupIndex", "collectionGroup", {
        unique: false
      });
      t2.createObjectStore("indexState", {
        keyPath: Ai
      }).createIndex("sequenceNumberIndex", Ri, {
        unique: false
      });
      t2.createObjectStore("indexEntries", {
        keyPath: bi
      }).createIndex("documentKeyIndex", Pi, {
        unique: false
      });
    }(t))), r;
  }
  Ls(t) {
    let e = 0;
    return t.store("remoteDocuments").J((t2, n) => {
      e += Vr(n);
    }).next(() => {
      const n = {
        byteSize: e
      };
      return t.store("remoteDocumentGlobal").put("remoteDocumentGlobalKey", n);
    });
  }
  Bs(t) {
    const e = t.store("mutationQueues"), n = t.store("mutations");
    return e.K().next((e2) => Pt.forEach(e2, (e3) => {
      const s = IDBKeyRange.bound([e3.userId, -1], [e3.userId, e3.lastAcknowledgedBatchId]);
      return n.K("userMutationsIndex", s).next((n2) => Pt.forEach(n2, (n3) => {
        U(n3.userId === e3.userId);
        const s2 = Wi(this.wt, n3);
        return vr(t, e3.userId, s2).next(() => {
        });
      }));
    }));
  }
  Us(t) {
    const e = t.store("targetDocuments"), n = t.store("remoteDocuments");
    return t.store("targetGlobal").get("targetGlobalKey").next((t2) => {
      const s = [];
      return n.J((n2, i) => {
        const r = new ht(n2), o = function(t3) {
          return [0, ci(t3)];
        }(r);
        s.push(e.get(o).next((n3) => n3 ? Pt.resolve() : ((n4) => e.put({
          targetId: 0,
          path: ci(n4),
          sequenceNumber: t2.highestListenSequenceNumber
        }))(r)));
      }).next(() => Pt.waitFor(s));
    });
  }
  qs(t, e) {
    t.createObjectStore("collectionParents", {
      keyPath: Ei
    });
    const n = e.store("collectionParents"), s = new gr(), i = (t2) => {
      if (s.add(t2)) {
        const e2 = t2.lastSegment(), s2 = t2.popLast();
        return n.put({
          collectionId: e2,
          parent: ci(s2)
        });
      }
    };
    return e.store("remoteDocuments").J({
      H: true
    }, (t2, e2) => {
      const n2 = new ht(t2);
      return i(n2.popLast());
    }).next(() => e.store("documentMutations").J({
      H: true
    }, ([t2, e2, n2], s2) => {
      const r = li(e2);
      return i(r.popLast());
    }));
  }
  Ks(t) {
    const e = t.store("targets");
    return e.J((t2, n) => {
      const s = zi(n), i = Hi(this.wt, s);
      return e.put(i);
    });
  }
  Gs(t, e) {
    const n = e.store("remoteDocuments"), s = [];
    return n.J((t2, n2) => {
      const i = e.store("remoteDocumentsV14"), r = (o = n2, o.document ? new dt(ht.fromString(o.document.name).popFirst(5)) : o.noDocument ? dt.fromSegments(o.noDocument.path) : o.unknownDocument ? dt.fromSegments(o.unknownDocument.path) : L()).path.toArray();
      var o;
      const u = {
        prefixPath: r.slice(0, r.length - 2),
        collectionGroup: r[r.length - 2],
        documentId: r[r.length - 1],
        readTime: n2.readTime || [0, 0],
        unknownDocument: n2.unknownDocument,
        noDocument: n2.noDocument,
        document: n2.document,
        hasCommittedMutations: !!n2.hasCommittedMutations
      };
      s.push(i.put(u));
    }).next(() => Pt.waitFor(s));
  }
  Qs(t, e) {
    const n = e.store("mutations"), s = Wr(this.wt), i = new ho(fo.Ms, this.wt.ne);
    return n.K().next((t2) => {
      const n2 = /* @__PURE__ */ new Map();
      return t2.forEach((t3) => {
        var e2;
        let s2 = null !== (e2 = n2.get(t3.userId)) && void 0 !== e2 ? e2 : ws();
        Wi(this.wt, t3).keys().forEach((t4) => s2 = s2.add(t4)), n2.set(t3.userId, s2);
      }), Pt.forEach(n2, (t3, n3) => {
        const r = new C(n3), o = sr.se(this.wt, r), u = i.getIndexManager(r), c = Sr.se(r, this.wt, u, i.referenceDelegate);
        return new eo(s, c, o, u).recalculateAndSaveOverlaysForDocumentKeys(new Oi(e, $t.ot), t3).next();
      });
    });
  }
};
function wo(t) {
  t.createObjectStore("targetDocuments", {
    keyPath: Ii
  }).createIndex("documentTargetsIndex", Ti, {
    unique: true
  });
  t.createObjectStore("targets", {
    keyPath: "targetId"
  }).createIndex("queryTargetsIndex", pi, {
    unique: true
  }), t.createObjectStore("targetGlobal");
}
var mo = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.";
var go = class {
  constructor(t, e, n, s, i, r, o, u, c, a, h = 14) {
    if (this.allowTabSynchronization = t, this.persistenceKey = e, this.clientId = n, this.js = i, this.window = r, this.document = o, this.Ws = c, this.zs = a, this.Hs = h, this.Ps = null, this.vs = false, this.isPrimary = false, this.networkEnabled = true, this.Js = null, this.inForeground = false, this.Ys = null, this.Xs = null, this.Zs = Number.NEGATIVE_INFINITY, this.ti = (t2) => Promise.resolve(), !go.V())
      throw new Q(G.UNIMPLEMENTED, "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.");
    this.referenceDelegate = new Kr(this, s), this.ei = e + "main", this.wt = new Ui(u), this.ni = new Vt(this.ei, this.Hs, new _o(this.wt)), this.Vs = new Or(this.referenceDelegate, this.wt), this.remoteDocumentCache = Wr(this.wt), this.Ds = new tr(), this.window && this.window.localStorage ? this.si = this.window.localStorage : (this.si = null, false === a && F("IndexedDbPersistence", "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page."));
  }
  start() {
    return this.ii().then(() => {
      if (!this.isPrimary && !this.allowTabSynchronization)
        throw new Q(G.FAILED_PRECONDITION, mo);
      return this.ri(), this.oi(), this.ui(), this.runTransaction("getHighestListenSequenceNumber", "readonly", (t) => this.Vs.getHighestSequenceNumber(t));
    }).then((t) => {
      this.Ps = new $t(t, this.Ws);
    }).then(() => {
      this.vs = true;
    }).catch((t) => (this.ni && this.ni.close(), Promise.reject(t)));
  }
  ci(t) {
    return this.ti = async (e) => {
      if (this.started)
        return t(e);
    }, t(this.isPrimary);
  }
  setDatabaseDeletedListener(t) {
    this.ni.F(async (e) => {
      null === e.newVersion && await t();
    });
  }
  setNetworkEnabled(t) {
    this.networkEnabled !== t && (this.networkEnabled = t, this.js.enqueueAndForget(async () => {
      this.started && await this.ii();
    }));
  }
  ii() {
    return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", (t) => po(t).put({
      clientId: this.clientId,
      updateTimeMs: Date.now(),
      networkEnabled: this.networkEnabled,
      inForeground: this.inForeground
    }).next(() => {
      if (this.isPrimary)
        return this.ai(t).next((t2) => {
          t2 || (this.isPrimary = false, this.js.enqueueRetryable(() => this.ti(false)));
        });
    }).next(() => this.hi(t)).next((e) => this.isPrimary && !e ? this.li(t).next(() => false) : !!e && this.fi(t).next(() => true))).catch((t) => {
      if (Ct(t))
        return M("IndexedDbPersistence", "Failed to extend owner lease: ", t), this.isPrimary;
      if (!this.allowTabSynchronization)
        throw t;
      return M("IndexedDbPersistence", "Releasing owner lease after error during lease refresh", t), false;
    }).then((t) => {
      this.isPrimary !== t && this.js.enqueueRetryable(() => this.ti(t)), this.isPrimary = t;
    });
  }
  ai(t) {
    return yo(t).get("owner").next((t2) => Pt.resolve(this.di(t2)));
  }
  _i(t) {
    return po(t).delete(this.clientId);
  }
  async wi() {
    if (this.isPrimary && !this.mi(this.Zs, 18e5)) {
      this.Zs = Date.now();
      const t = await this.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", (t2) => {
        const e = Mi(t2, "clientMetadata");
        return e.K().next((t3) => {
          const n = this.gi(t3, 18e5), s = t3.filter((t4) => -1 === n.indexOf(t4));
          return Pt.forEach(s, (t4) => e.delete(t4.clientId)).next(() => s);
        });
      }).catch(() => []);
      if (this.si)
        for (const e of t)
          this.si.removeItem(this.yi(e.clientId));
    }
  }
  ui() {
    this.Xs = this.js.enqueueAfterDelay("client_metadata_refresh", 4e3, () => this.ii().then(() => this.wi()).then(() => this.ui()));
  }
  di(t) {
    return !!t && t.ownerId === this.clientId;
  }
  hi(t) {
    if (this.zs)
      return Pt.resolve(true);
    return yo(t).get("owner").next((e) => {
      if (null !== e && this.mi(e.leaseTimestampMs, 5e3) && !this.pi(e.ownerId)) {
        if (this.di(e) && this.networkEnabled)
          return true;
        if (!this.di(e)) {
          if (!e.allowTabSynchronization)
            throw new Q(G.FAILED_PRECONDITION, mo);
          return false;
        }
      }
      return !(!this.networkEnabled || !this.inForeground) || po(t).K().next((t2) => void 0 === this.gi(t2, 5e3).find((t3) => {
        if (this.clientId !== t3.clientId) {
          const e2 = !this.networkEnabled && t3.networkEnabled, n = !this.inForeground && t3.inForeground, s = this.networkEnabled === t3.networkEnabled;
          if (e2 || n && s)
            return true;
        }
        return false;
      }));
    }).next((t2) => (this.isPrimary !== t2 && M("IndexedDbPersistence", `Client ${t2 ? "is" : "is not"} eligible for a primary lease.`), t2));
  }
  async shutdown() {
    this.vs = false, this.Ii(), this.Xs && (this.Xs.cancel(), this.Xs = null), this.Ti(), this.Ei(), await this.ni.runTransaction("shutdown", "readwrite", ["owner", "clientMetadata"], (t) => {
      const e = new Oi(t, $t.ot);
      return this.li(e).next(() => this._i(e));
    }), this.ni.close(), this.Ai();
  }
  gi(t, e) {
    return t.filter((t2) => this.mi(t2.updateTimeMs, e) && !this.pi(t2.clientId));
  }
  Ri() {
    return this.runTransaction("getActiveClients", "readonly", (t) => po(t).K().next((t2) => this.gi(t2, 18e5).map((t3) => t3.clientId)));
  }
  get started() {
    return this.vs;
  }
  getMutationQueue(t, e) {
    return Sr.se(t, this.wt, e, this.referenceDelegate);
  }
  getTargetCache() {
    return this.Vs;
  }
  getRemoteDocumentCache() {
    return this.remoteDocumentCache;
  }
  getIndexManager(t) {
    return new pr(t, this.wt.ne.databaseId);
  }
  getDocumentOverlayCache(t) {
    return sr.se(this.wt, t);
  }
  getBundleCache() {
    return this.Ds;
  }
  runTransaction(t, e, n) {
    M("IndexedDbPersistence", "Starting transaction:", t);
    const s = "readonly" === e ? "readonly" : "readwrite", i = 15 === (r = this.Hs) ? ki : 14 === r ? Ni : 13 === r ? xi : 12 === r ? Ci : 11 === r ? Di : void L();
    var r;
    let o;
    return this.ni.runTransaction(t, s, i, (s2) => (o = new Oi(s2, this.Ps ? this.Ps.next() : $t.ot), "readwrite-primary" === e ? this.ai(o).next((t2) => !!t2 || this.hi(o)).next((e2) => {
      if (!e2)
        throw F(`Failed to obtain primary lease for action '${t}'.`), this.isPrimary = false, this.js.enqueueRetryable(() => this.ti(false)), new Q(G.FAILED_PRECONDITION, At);
      return n(o);
    }).next((t2) => this.fi(o).next(() => t2)) : this.bi(o).next(() => n(o)))).then((t2) => (o.raiseOnCommittedEvent(), t2));
  }
  bi(t) {
    return yo(t).get("owner").next((t2) => {
      if (null !== t2 && this.mi(t2.leaseTimestampMs, 5e3) && !this.pi(t2.ownerId) && !this.di(t2) && !(this.zs || this.allowTabSynchronization && t2.allowTabSynchronization))
        throw new Q(G.FAILED_PRECONDITION, mo);
    });
  }
  fi(t) {
    const e = {
      ownerId: this.clientId,
      allowTabSynchronization: this.allowTabSynchronization,
      leaseTimestampMs: Date.now()
    };
    return yo(t).put("owner", e);
  }
  static V() {
    return Vt.V();
  }
  li(t) {
    const e = yo(t);
    return e.get("owner").next((t2) => this.di(t2) ? (M("IndexedDbPersistence", "Releasing primary lease."), e.delete("owner")) : Pt.resolve());
  }
  mi(t, e) {
    const n = Date.now();
    return !(t < n - e) && (!(t > n) || (F(`Detected an update time that is in the future: ${t} > ${n}`), false));
  }
  ri() {
    null !== this.document && "function" == typeof this.document.addEventListener && (this.Ys = () => {
      this.js.enqueueAndForget(() => (this.inForeground = "visible" === this.document.visibilityState, this.ii()));
    }, this.document.addEventListener("visibilitychange", this.Ys), this.inForeground = "visible" === this.document.visibilityState);
  }
  Ti() {
    this.Ys && (this.document.removeEventListener("visibilitychange", this.Ys), this.Ys = null);
  }
  oi() {
    var t;
    "function" == typeof (null === (t = this.window) || void 0 === t ? void 0 : t.addEventListener) && (this.Js = () => {
      this.Ii(), isSafari() && navigator.appVersion.match(/Version\/1[45]/) && this.js.enterRestrictedMode(true), this.js.enqueueAndForget(() => this.shutdown());
    }, this.window.addEventListener("pagehide", this.Js));
  }
  Ei() {
    this.Js && (this.window.removeEventListener("pagehide", this.Js), this.Js = null);
  }
  pi(t) {
    var e;
    try {
      const n = null !== (null === (e = this.si) || void 0 === e ? void 0 : e.getItem(this.yi(t)));
      return M("IndexedDbPersistence", `Client '${t}' ${n ? "is" : "is not"} zombied in LocalStorage`), n;
    } catch (t2) {
      return F("IndexedDbPersistence", "Failed to get zombied client id.", t2), false;
    }
  }
  Ii() {
    if (this.si)
      try {
        this.si.setItem(this.yi(this.clientId), String(Date.now()));
      } catch (t) {
        F("Failed to set zombie client id.", t);
      }
  }
  Ai() {
    if (this.si)
      try {
        this.si.removeItem(this.yi(this.clientId));
      } catch (t) {
      }
  }
  yi(t) {
    return `firestore_zombie_${this.persistenceKey}_${t}`;
  }
};
function yo(t) {
  return Mi(t, "owner");
}
function po(t) {
  return Mi(t, "clientMetadata");
}
function Io(t, e) {
  let n = t.projectId;
  return t.isDefaultDatabase || (n += "." + t.database), "firestore/" + e + "/" + n + "/";
}
var To = class {
  constructor(t, e, n, s) {
    this.targetId = t, this.fromCache = e, this.Pi = n, this.vi = s;
  }
  static Vi(t, e) {
    let n = ws(), s = ws();
    for (const t2 of e.docChanges)
      switch (t2.type) {
        case 0:
          n = n.add(t2.doc.key);
          break;
        case 1:
          s = s.add(t2.doc.key);
      }
    return new To(t, e.fromCache, n, s);
  }
};
var Eo = class {
  constructor() {
    this.Si = false;
  }
  initialize(t, e) {
    this.Di = t, this.indexManager = e, this.Si = true;
  }
  getDocumentsMatchingQuery(t, e, n, s) {
    return this.Ci(t, e).next((i) => i || this.xi(t, e, s, n)).next((n2) => n2 || this.Ni(t, e));
  }
  Ci(t, e) {
    return Pt.resolve(null);
  }
  xi(t, e, n, s) {
    return on(e) || s.isEqual(ct.min()) ? this.Ni(t, e) : this.Di.getDocuments(t, n).next((i) => {
      const r = this.ki(e, i);
      return this.Oi(e, r, n, s) ? this.Ni(t, e) : (k() <= LogLevel.DEBUG && M("QueryEngine", "Re-using previous result from %s to execute query: %s", s.toString(), wn(e)), this.Mi(t, r, e, pt(s, -1)));
    });
  }
  ki(t, e) {
    let n = new Qt(yn(t));
    return e.forEach((e2, s) => {
      mn(t, s) && (n = n.add(s));
    }), n;
  }
  Oi(t, e, n, s) {
    if (null === t.limit)
      return false;
    if (n.size !== e.size)
      return true;
    const i = "F" === t.limitType ? e.last() : e.first();
    return !!i && (i.hasPendingWrites || i.version.compareTo(s) > 0);
  }
  Ni(t, e) {
    return k() <= LogLevel.DEBUG && M("QueryEngine", "Using full collection scan to execute query:", wn(e)), this.Di.getDocumentsMatchingQuery(t, e, Tt.min());
  }
  Mi(t, e, n, s) {
    return this.Di.getDocumentsMatchingQuery(t, n, s).next((t2) => (e.forEach((e2) => {
      t2 = t2.insert(e2.key, e2);
    }), t2));
  }
};
var Ao = class {
  constructor(t, e, n, s) {
    this.persistence = t, this.Fi = e, this.wt = s, this.$i = new qt(it), this.Bi = new is((t2) => Oe(t2), Fe), this.Li = /* @__PURE__ */ new Map(), this.Ui = t.getRemoteDocumentCache(), this.Vs = t.getTargetCache(), this.Ds = t.getBundleCache(), this.qi(n);
  }
  qi(t) {
    this.documentOverlayCache = this.persistence.getDocumentOverlayCache(t), this.indexManager = this.persistence.getIndexManager(t), this.mutationQueue = this.persistence.getMutationQueue(t, this.indexManager), this.localDocuments = new eo(this.Ui, this.mutationQueue, this.documentOverlayCache, this.indexManager), this.Ui.setIndexManager(this.indexManager), this.Fi.initialize(this.localDocuments, this.indexManager);
  }
  collectGarbage(t) {
    return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (e) => t.collect(e, this.$i));
  }
};
function Ro(t, e, n, s) {
  return new Ao(t, e, n, s);
}
async function bo(t, e) {
  const n = K(t);
  return await n.persistence.runTransaction("Handle user change", "readonly", (t2) => {
    let s;
    return n.mutationQueue.getAllMutationBatches(t2).next((i) => (s = i, n.qi(e), n.mutationQueue.getAllMutationBatches(t2))).next((e2) => {
      const i = [], r = [];
      let o = ws();
      for (const t3 of s) {
        i.push(t3.batchId);
        for (const e3 of t3.mutations)
          o = o.add(e3.key);
      }
      for (const t3 of e2) {
        r.push(t3.batchId);
        for (const e3 of t3.mutations)
          o = o.add(e3.key);
      }
      return n.localDocuments.getDocuments(t2, o).next((t3) => ({
        Ki: t3,
        removedBatchIds: i,
        addedBatchIds: r
      }));
    });
  });
}
function Po(t, e) {
  const n = K(t);
  return n.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (t2) => {
    const s = e.batch.keys(), i = n.Ui.newChangeBuffer({
      trackRemovals: true
    });
    return function(t3, e2, n2, s2) {
      const i2 = n2.batch, r = i2.keys();
      let o = Pt.resolve();
      return r.forEach((t4) => {
        o = o.next(() => s2.getEntry(e2, t4)).next((e3) => {
          const r2 = n2.docVersions.get(t4);
          U(null !== r2), e3.version.compareTo(r2) < 0 && (i2.applyToRemoteDocument(e3, n2), e3.isValidDocument() && (e3.setReadTime(n2.commitVersion), s2.addEntry(e3)));
        });
      }), o.next(() => t3.mutationQueue.removeMutationBatch(e2, i2));
    }(n, t2, e, i).next(() => i.apply(t2)).next(() => n.mutationQueue.performConsistencyCheck(t2)).next(() => n.documentOverlayCache.removeOverlaysForBatchId(t2, s, e.batch.batchId)).next(() => n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(t2, function(t3) {
      let e2 = ws();
      for (let n2 = 0; n2 < t3.mutationResults.length; ++n2) {
        t3.mutationResults[n2].transformResults.length > 0 && (e2 = e2.add(t3.batch.mutations[n2].key));
      }
      return e2;
    }(e))).next(() => n.localDocuments.getDocuments(t2, s));
  });
}
function vo(t) {
  const e = K(t);
  return e.persistence.runTransaction("Get last remote snapshot version", "readonly", (t2) => e.Vs.getLastRemoteSnapshotVersion(t2));
}
function Vo(t, e) {
  const n = K(t), s = e.snapshotVersion;
  let i = n.$i;
  return n.persistence.runTransaction("Apply remote event", "readwrite-primary", (t2) => {
    const r = n.Ui.newChangeBuffer({
      trackRemovals: true
    });
    i = n.$i;
    const o = [];
    e.targetChanges.forEach((r2, u2) => {
      const c2 = i.get(u2);
      if (!c2)
        return;
      o.push(n.Vs.removeMatchingKeys(t2, r2.removedDocuments, u2).next(() => n.Vs.addMatchingKeys(t2, r2.addedDocuments, u2)));
      let a = c2.withSequenceNumber(t2.currentSequenceNumber);
      e.targetMismatches.has(u2) ? a = a.withResumeToken(Jt.EMPTY_BYTE_STRING, ct.min()).withLastLimboFreeSnapshotVersion(ct.min()) : r2.resumeToken.approximateByteSize() > 0 && (a = a.withResumeToken(r2.resumeToken, s)), i = i.insert(u2, a), function(t3, e2, n2) {
        if (0 === t3.resumeToken.approximateByteSize())
          return true;
        if (e2.snapshotVersion.toMicroseconds() - t3.snapshotVersion.toMicroseconds() >= 3e8)
          return true;
        return n2.addedDocuments.size + n2.modifiedDocuments.size + n2.removedDocuments.size > 0;
      }(c2, a, r2) && o.push(n.Vs.updateTargetData(t2, a));
    });
    let u = os(), c = ws();
    if (e.documentUpdates.forEach((s2) => {
      e.resolvedLimboDocuments.has(s2) && o.push(n.persistence.referenceDelegate.updateLimboDocument(t2, s2));
    }), o.push(So(t2, r, e.documentUpdates).next((t3) => {
      u = t3.Gi, c = t3.Qi;
    })), !s.isEqual(ct.min())) {
      const e2 = n.Vs.getLastRemoteSnapshotVersion(t2).next((e3) => n.Vs.setTargetsMetadata(t2, t2.currentSequenceNumber, s));
      o.push(e2);
    }
    return Pt.waitFor(o).next(() => r.apply(t2)).next(() => n.localDocuments.getLocalViewOfDocuments(t2, u, c)).next(() => u);
  }).then((t2) => (n.$i = i, t2));
}
function So(t, e, n) {
  let s = ws(), i = ws();
  return n.forEach((t2) => s = s.add(t2)), e.getEntries(t, s).next((t2) => {
    let s2 = os();
    return n.forEach((n2, r) => {
      const o = t2.get(n2);
      r.isFoundDocument() !== o.isFoundDocument() && (i = i.add(n2)), r.isNoDocument() && r.version.isEqual(ct.min()) ? (e.removeEntry(n2, r.readTime), s2 = s2.insert(n2, r)) : !o.isValidDocument() || r.version.compareTo(o.version) > 0 || 0 === r.version.compareTo(o.version) && o.hasPendingWrites ? (e.addEntry(r), s2 = s2.insert(n2, r)) : M("LocalStore", "Ignoring outdated watch update for ", n2, ". Current version:", o.version, " Watch version:", r.version);
    }), {
      Gi: s2,
      Qi: i
    };
  });
}
function Do(t, e) {
  const n = K(t);
  return n.persistence.runTransaction("Get next mutation batch", "readonly", (t2) => (void 0 === e && (e = -1), n.mutationQueue.getNextMutationBatchAfterBatchId(t2, e)));
}
function Co(t, e) {
  const n = K(t);
  return n.persistence.runTransaction("Allocate target", "readwrite", (t2) => {
    let s;
    return n.Vs.getTargetData(t2, e).next((i) => i ? (s = i, Pt.resolve(s)) : n.Vs.allocateTargetId(t2).next((i2) => (s = new Li(e, i2, 0, t2.currentSequenceNumber), n.Vs.addTargetData(t2, s).next(() => s))));
  }).then((t2) => {
    const s = n.$i.get(t2.targetId);
    return (null === s || t2.snapshotVersion.compareTo(s.snapshotVersion) > 0) && (n.$i = n.$i.insert(t2.targetId, t2), n.Bi.set(e, t2.targetId)), t2;
  });
}
async function xo(t, e, n) {
  const s = K(t), i = s.$i.get(e), r = n ? "readwrite" : "readwrite-primary";
  try {
    n || await s.persistence.runTransaction("Release target", r, (t2) => s.persistence.referenceDelegate.removeTarget(t2, i));
  } catch (t2) {
    if (!Ct(t2))
      throw t2;
    M("LocalStore", `Failed to update sequence numbers for target ${e}: ${t2}`);
  }
  s.$i = s.$i.remove(e), s.Bi.delete(i.target);
}
function No(t, e, n) {
  const s = K(t);
  let i = ct.min(), r = ws();
  return s.persistence.runTransaction("Execute query", "readonly", (t2) => function(t3, e2, n2) {
    const s2 = K(t3), i2 = s2.Bi.get(n2);
    return void 0 !== i2 ? Pt.resolve(s2.$i.get(i2)) : s2.Vs.getTargetData(e2, n2);
  }(s, t2, ln(e)).next((e2) => {
    if (e2)
      return i = e2.lastLimboFreeSnapshotVersion, s.Vs.getMatchingKeysForTargetId(t2, e2.targetId).next((t3) => {
        r = t3;
      });
  }).next(() => s.Fi.getDocumentsMatchingQuery(t2, e, n ? i : ct.min(), n ? r : ws())).next((t3) => (Mo(s, gn(e), t3), {
    documents: t3,
    ji: r
  })));
}
function ko(t, e) {
  const n = K(t), s = K(n.Vs), i = n.$i.get(e);
  return i ? Promise.resolve(i.target) : n.persistence.runTransaction("Get target data", "readonly", (t2) => s.te(t2, e).next((t3) => t3 ? t3.target : null));
}
function Oo(t, e) {
  const n = K(t), s = n.Li.get(e) || ct.min();
  return n.persistence.runTransaction("Get new document changes", "readonly", (t2) => n.Ui.getAllFromCollectionGroup(t2, e, pt(s, -1), Number.MAX_SAFE_INTEGER)).then((t2) => (Mo(n, e, t2), t2));
}
function Mo(t, e, n) {
  let s = ct.min();
  n.forEach((t2, e2) => {
    e2.readTime.compareTo(s) > 0 && (s = e2.readTime);
  }), t.Li.set(e, s);
}
async function Fo(t, e, n, s) {
  const i = K(t);
  let r = ws(), o = os();
  for (const t2 of n) {
    const n2 = e.Wi(t2.metadata.name);
    t2.document && (r = r.add(n2));
    const s2 = e.zi(t2);
    s2.setReadTime(e.Hi(t2.metadata.readTime)), o = o.insert(n2, s2);
  }
  const u = i.Ui.newChangeBuffer({
    trackRemovals: true
  }), c = await Co(i, function(t2) {
    return ln(rn(ht.fromString(`__bundle__/docs/${t2}`)));
  }(s));
  return i.persistence.runTransaction("Apply bundle documents", "readwrite", (t2) => So(t2, u, o).next((e2) => (u.apply(t2), e2)).next((e2) => i.Vs.removeMatchingKeysForTargetId(t2, c.targetId).next(() => i.Vs.addMatchingKeys(t2, r, c.targetId)).next(() => i.localDocuments.getLocalViewOfDocuments(t2, e2.Gi, e2.Qi)).next(() => e2.Gi)));
}
async function $o(t, e, n = ws()) {
  const s = await Co(t, ln(Ji(e.bundledQuery))), i = K(t);
  return i.persistence.runTransaction("Save named query", "readwrite", (t2) => {
    const r = Ns(e.readTime);
    if (s.snapshotVersion.compareTo(r) >= 0)
      return i.Ds.saveNamedQuery(t2, e);
    const o = s.withResumeToken(Jt.EMPTY_BYTE_STRING, r);
    return i.$i = i.$i.insert(o.targetId, o), i.Vs.updateTargetData(t2, o).next(() => i.Vs.removeMatchingKeysForTargetId(t2, s.targetId)).next(() => i.Vs.addMatchingKeys(t2, n, s.targetId)).next(() => i.Ds.saveNamedQuery(t2, e));
  });
}
function Bo(t, e) {
  return `firestore_clients_${t}_${e}`;
}
function Lo(t, e, n) {
  let s = `firestore_mutations_${t}_${n}`;
  return e.isAuthenticated() && (s += `_${e.uid}`), s;
}
function Uo(t, e) {
  return `firestore_targets_${t}_${e}`;
}
var qo = class {
  constructor(t, e, n, s) {
    this.user = t, this.batchId = e, this.state = n, this.error = s;
  }
  static Ji(t, e, n) {
    const s = JSON.parse(n);
    let i, r = "object" == typeof s && -1 !== ["pending", "acknowledged", "rejected"].indexOf(s.state) && (void 0 === s.error || "object" == typeof s.error);
    return r && s.error && (r = "string" == typeof s.error.message && "string" == typeof s.error.code, r && (i = new Q(s.error.code, s.error.message))), r ? new qo(t, e, s.state, i) : (F("SharedClientState", `Failed to parse mutation state for ID '${e}': ${n}`), null);
  }
  Yi() {
    const t = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t);
  }
};
var Ko = class {
  constructor(t, e, n) {
    this.targetId = t, this.state = e, this.error = n;
  }
  static Ji(t, e) {
    const n = JSON.parse(e);
    let s, i = "object" == typeof n && -1 !== ["not-current", "current", "rejected"].indexOf(n.state) && (void 0 === n.error || "object" == typeof n.error);
    return i && n.error && (i = "string" == typeof n.error.message && "string" == typeof n.error.code, i && (s = new Q(n.error.code, n.error.message))), i ? new Ko(t, n.state, s) : (F("SharedClientState", `Failed to parse target state for ID '${t}': ${e}`), null);
  }
  Yi() {
    const t = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t);
  }
};
var Go = class {
  constructor(t, e) {
    this.clientId = t, this.activeTargetIds = e;
  }
  static Ji(t, e) {
    const n = JSON.parse(e);
    let s = "object" == typeof n && n.activeTargetIds instanceof Array, i = gs();
    for (let t2 = 0; s && t2 < n.activeTargetIds.length; ++t2)
      s = ce(n.activeTargetIds[t2]), i = i.add(n.activeTargetIds[t2]);
    return s ? new Go(t, i) : (F("SharedClientState", `Failed to parse client data for instance '${t}': ${e}`), null);
  }
};
var Qo = class {
  constructor(t, e) {
    this.clientId = t, this.onlineState = e;
  }
  static Ji(t) {
    const e = JSON.parse(t);
    return "object" == typeof e && -1 !== ["Unknown", "Online", "Offline"].indexOf(e.onlineState) && "string" == typeof e.clientId ? new Qo(e.clientId, e.onlineState) : (F("SharedClientState", `Failed to parse online state: ${t}`), null);
  }
};
var jo = class {
  constructor() {
    this.activeTargetIds = gs();
  }
  Xi(t) {
    this.activeTargetIds = this.activeTargetIds.add(t);
  }
  Zi(t) {
    this.activeTargetIds = this.activeTargetIds.delete(t);
  }
  Yi() {
    const t = {
      activeTargetIds: this.activeTargetIds.toArray(),
      updateTimeMs: Date.now()
    };
    return JSON.stringify(t);
  }
};
var Wo = class {
  constructor(t, e, n, s, i) {
    this.window = t, this.js = e, this.persistenceKey = n, this.tr = s, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null, this.er = this.nr.bind(this), this.sr = new qt(it), this.started = false, this.ir = [];
    const r = n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    this.storage = this.window.localStorage, this.currentUser = i, this.rr = Bo(this.persistenceKey, this.tr), this.ur = function(t2) {
      return `firestore_sequence_number_${t2}`;
    }(this.persistenceKey), this.sr = this.sr.insert(this.tr, new jo()), this.cr = new RegExp(`^firestore_clients_${r}_([^_]*)$`), this.ar = new RegExp(`^firestore_mutations_${r}_(\\d+)(?:_(.*))?$`), this.hr = new RegExp(`^firestore_targets_${r}_(\\d+)$`), this.lr = function(t2) {
      return `firestore_online_state_${t2}`;
    }(this.persistenceKey), this.dr = function(t2) {
      return `firestore_bundle_loaded_v2_${t2}`;
    }(this.persistenceKey), this.window.addEventListener("storage", this.er);
  }
  static V(t) {
    return !(!t || !t.localStorage);
  }
  async start() {
    const t = await this.syncEngine.Ri();
    for (const e2 of t) {
      if (e2 === this.tr)
        continue;
      const t2 = this.getItem(Bo(this.persistenceKey, e2));
      if (t2) {
        const n = Go.Ji(e2, t2);
        n && (this.sr = this.sr.insert(n.clientId, n));
      }
    }
    this._r();
    const e = this.storage.getItem(this.lr);
    if (e) {
      const t2 = this.wr(e);
      t2 && this.mr(t2);
    }
    for (const t2 of this.ir)
      this.nr(t2);
    this.ir = [], this.window.addEventListener("pagehide", () => this.shutdown()), this.started = true;
  }
  writeSequenceNumber(t) {
    this.setItem(this.ur, JSON.stringify(t));
  }
  getAllActiveQueryTargets() {
    return this.gr(this.sr);
  }
  isActiveQueryTarget(t) {
    let e = false;
    return this.sr.forEach((n, s) => {
      s.activeTargetIds.has(t) && (e = true);
    }), e;
  }
  addPendingMutation(t) {
    this.yr(t, "pending");
  }
  updateMutationState(t, e, n) {
    this.yr(t, e, n), this.pr(t);
  }
  addLocalQueryTarget(t) {
    let e = "not-current";
    if (this.isActiveQueryTarget(t)) {
      const n = this.storage.getItem(Uo(this.persistenceKey, t));
      if (n) {
        const s = Ko.Ji(t, n);
        s && (e = s.state);
      }
    }
    return this.Ir.Xi(t), this._r(), e;
  }
  removeLocalQueryTarget(t) {
    this.Ir.Zi(t), this._r();
  }
  isLocalQueryTarget(t) {
    return this.Ir.activeTargetIds.has(t);
  }
  clearQueryState(t) {
    this.removeItem(Uo(this.persistenceKey, t));
  }
  updateQueryState(t, e, n) {
    this.Tr(t, e, n);
  }
  handleUserChange(t, e, n) {
    e.forEach((t2) => {
      this.pr(t2);
    }), this.currentUser = t, n.forEach((t2) => {
      this.addPendingMutation(t2);
    });
  }
  setOnlineState(t) {
    this.Er(t);
  }
  notifyBundleLoaded(t) {
    this.Ar(t);
  }
  shutdown() {
    this.started && (this.window.removeEventListener("storage", this.er), this.removeItem(this.rr), this.started = false);
  }
  getItem(t) {
    const e = this.storage.getItem(t);
    return M("SharedClientState", "READ", t, e), e;
  }
  setItem(t, e) {
    M("SharedClientState", "SET", t, e), this.storage.setItem(t, e);
  }
  removeItem(t) {
    M("SharedClientState", "REMOVE", t), this.storage.removeItem(t);
  }
  nr(t) {
    const e = t;
    if (e.storageArea === this.storage) {
      if (M("SharedClientState", "EVENT", e.key, e.newValue), e.key === this.rr)
        return void F("Received WebStorage notification for local change. Another client might have garbage-collected our state");
      this.js.enqueueRetryable(async () => {
        if (this.started) {
          if (null !== e.key) {
            if (this.cr.test(e.key)) {
              if (null == e.newValue) {
                const t2 = this.Rr(e.key);
                return this.br(t2, null);
              }
              {
                const t2 = this.Pr(e.key, e.newValue);
                if (t2)
                  return this.br(t2.clientId, t2);
              }
            } else if (this.ar.test(e.key)) {
              if (null !== e.newValue) {
                const t2 = this.vr(e.key, e.newValue);
                if (t2)
                  return this.Vr(t2);
              }
            } else if (this.hr.test(e.key)) {
              if (null !== e.newValue) {
                const t2 = this.Sr(e.key, e.newValue);
                if (t2)
                  return this.Dr(t2);
              }
            } else if (e.key === this.lr) {
              if (null !== e.newValue) {
                const t2 = this.wr(e.newValue);
                if (t2)
                  return this.mr(t2);
              }
            } else if (e.key === this.ur) {
              const t2 = function(t3) {
                let e2 = $t.ot;
                if (null != t3)
                  try {
                    const n = JSON.parse(t3);
                    U("number" == typeof n), e2 = n;
                  } catch (t4) {
                    F("SharedClientState", "Failed to read sequence number from WebStorage", t4);
                  }
                return e2;
              }(e.newValue);
              t2 !== $t.ot && this.sequenceNumberHandler(t2);
            } else if (e.key === this.dr) {
              const t2 = this.Cr(e.newValue);
              await Promise.all(t2.map((t3) => this.syncEngine.Nr(t3)));
            }
          }
        } else
          this.ir.push(e);
      });
    }
  }
  get Ir() {
    return this.sr.get(this.tr);
  }
  _r() {
    this.setItem(this.rr, this.Ir.Yi());
  }
  yr(t, e, n) {
    const s = new qo(this.currentUser, t, e, n), i = Lo(this.persistenceKey, this.currentUser, t);
    this.setItem(i, s.Yi());
  }
  pr(t) {
    const e = Lo(this.persistenceKey, this.currentUser, t);
    this.removeItem(e);
  }
  Er(t) {
    const e = {
      clientId: this.tr,
      onlineState: t
    };
    this.storage.setItem(this.lr, JSON.stringify(e));
  }
  Tr(t, e, n) {
    const s = Uo(this.persistenceKey, t), i = new Ko(t, e, n);
    this.setItem(s, i.Yi());
  }
  Ar(t) {
    const e = JSON.stringify(Array.from(t));
    this.setItem(this.dr, e);
  }
  Rr(t) {
    const e = this.cr.exec(t);
    return e ? e[1] : null;
  }
  Pr(t, e) {
    const n = this.Rr(t);
    return Go.Ji(n, e);
  }
  vr(t, e) {
    const n = this.ar.exec(t), s = Number(n[1]), i = void 0 !== n[2] ? n[2] : null;
    return qo.Ji(new C(i), s, e);
  }
  Sr(t, e) {
    const n = this.hr.exec(t), s = Number(n[1]);
    return Ko.Ji(s, e);
  }
  wr(t) {
    return Qo.Ji(t);
  }
  Cr(t) {
    return JSON.parse(t);
  }
  async Vr(t) {
    if (t.user.uid === this.currentUser.uid)
      return this.syncEngine.kr(t.batchId, t.state, t.error);
    M("SharedClientState", `Ignoring mutation for non-active user ${t.user.uid}`);
  }
  Dr(t) {
    return this.syncEngine.Or(t.targetId, t.state, t.error);
  }
  br(t, e) {
    const n = e ? this.sr.insert(t, e) : this.sr.remove(t), s = this.gr(this.sr), i = this.gr(n), r = [], o = [];
    return i.forEach((t2) => {
      s.has(t2) || r.push(t2);
    }), s.forEach((t2) => {
      i.has(t2) || o.push(t2);
    }), this.syncEngine.Mr(r, o).then(() => {
      this.sr = n;
    });
  }
  mr(t) {
    this.sr.get(t.clientId) && this.onlineStateHandler(t.onlineState);
  }
  gr(t) {
    let e = gs();
    return t.forEach((t2, n) => {
      e = e.unionWith(n.activeTargetIds);
    }), e;
  }
};
var zo = class {
  constructor() {
    this.Fr = new jo(), this.$r = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null;
  }
  addPendingMutation(t) {
  }
  updateMutationState(t, e, n) {
  }
  addLocalQueryTarget(t) {
    return this.Fr.Xi(t), this.$r[t] || "not-current";
  }
  updateQueryState(t, e, n) {
    this.$r[t] = e;
  }
  removeLocalQueryTarget(t) {
    this.Fr.Zi(t);
  }
  isLocalQueryTarget(t) {
    return this.Fr.activeTargetIds.has(t);
  }
  clearQueryState(t) {
    delete this.$r[t];
  }
  getAllActiveQueryTargets() {
    return this.Fr.activeTargetIds;
  }
  isActiveQueryTarget(t) {
    return this.Fr.activeTargetIds.has(t);
  }
  start() {
    return this.Fr = new jo(), Promise.resolve();
  }
  handleUserChange(t, e, n) {
  }
  setOnlineState(t) {
  }
  shutdown() {
  }
  writeSequenceNumber(t) {
  }
  notifyBundleLoaded(t) {
  }
};
var Ho = class {
  Br(t) {
  }
  shutdown() {
  }
};
var Jo = class {
  constructor() {
    this.Lr = () => this.Ur(), this.qr = () => this.Kr(), this.Gr = [], this.Qr();
  }
  Br(t) {
    this.Gr.push(t);
  }
  shutdown() {
    window.removeEventListener("online", this.Lr), window.removeEventListener("offline", this.qr);
  }
  Qr() {
    window.addEventListener("online", this.Lr), window.addEventListener("offline", this.qr);
  }
  Ur() {
    M("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
    for (const t of this.Gr)
      t(0);
  }
  Kr() {
    M("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
    for (const t of this.Gr)
      t(1);
  }
  static V() {
    return "undefined" != typeof window && void 0 !== window.addEventListener && void 0 !== window.removeEventListener;
  }
};
var Yo = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery"
};
var Xo = class {
  constructor(t) {
    this.jr = t.jr, this.Wr = t.Wr;
  }
  zr(t) {
    this.Hr = t;
  }
  Jr(t) {
    this.Yr = t;
  }
  onMessage(t) {
    this.Xr = t;
  }
  close() {
    this.Wr();
  }
  send(t) {
    this.jr(t);
  }
  Zr() {
    this.Hr();
  }
  eo(t) {
    this.Yr(t);
  }
  no(t) {
    this.Xr(t);
  }
};
var Zo = class extends class {
  constructor(t) {
    this.databaseInfo = t, this.databaseId = t.databaseId;
    const e = t.ssl ? "https" : "http";
    this.so = e + "://" + t.host, this.io = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents";
  }
  ro(t, e, n, s, i) {
    const r = this.oo(t, e);
    M("RestConnection", "Sending: ", r, n);
    const o = {};
    return this.uo(o, s, i), this.co(t, r, o, n).then((t2) => (M("RestConnection", "Received: ", t2), t2), (e2) => {
      throw $("RestConnection", `${t} failed with error: `, e2, "url: ", r, "request:", n), e2;
    });
  }
  ao(t, e, n, s, i, r) {
    return this.ro(t, e, n, s, i);
  }
  uo(t, e, n) {
    t["X-Goog-Api-Client"] = "gl-js/ fire/" + x, t["Content-Type"] = "text/plain", this.databaseInfo.appId && (t["X-Firebase-GMPID"] = this.databaseInfo.appId), e && e.headers.forEach((e2, n2) => t[n2] = e2), n && n.headers.forEach((e2, n2) => t[n2] = e2);
  }
  oo(t, e) {
    const n = Yo[t];
    return `${this.so}/v1/${e}:${n}`;
  }
} {
  constructor(t) {
    super(t), this.forceLongPolling = t.forceLongPolling, this.autoDetectLongPolling = t.autoDetectLongPolling, this.useFetchStreams = t.useFetchStreams;
  }
  co(t, e, n, s) {
    return new Promise((i, r) => {
      const o = new XhrIo();
      o.listenOnce(EventType.COMPLETE, () => {
        try {
          switch (o.getLastErrorCode()) {
            case ErrorCode.NO_ERROR:
              const e2 = o.getResponseJson();
              M("Connection", "XHR received:", JSON.stringify(e2)), i(e2);
              break;
            case ErrorCode.TIMEOUT:
              M("Connection", 'RPC "' + t + '" timed out'), r(new Q(G.DEADLINE_EXCEEDED, "Request time out"));
              break;
            case ErrorCode.HTTP_ERROR:
              const n2 = o.getStatus();
              if (M("Connection", 'RPC "' + t + '" failed with status:', n2, "response text:", o.getResponseText()), n2 > 0) {
                const t2 = o.getResponseJson().error;
                if (t2 && t2.status && t2.message) {
                  const e3 = function(t3) {
                    const e4 = t3.toLowerCase().replace(/_/g, "-");
                    return Object.values(G).indexOf(e4) >= 0 ? e4 : G.UNKNOWN;
                  }(t2.status);
                  r(new Q(e3, t2.message));
                } else
                  r(new Q(G.UNKNOWN, "Server responded with status " + o.getStatus()));
              } else
                r(new Q(G.UNAVAILABLE, "Connection failed."));
              break;
            default:
              L();
          }
        } finally {
          M("Connection", 'RPC "' + t + '" completed.');
        }
      });
      const u = JSON.stringify(s);
      o.send(e, "POST", u, n, 15);
    });
  }
  ho(t, e, n) {
    const s = [this.so, "/", "google.firestore.v1.Firestore", "/", t, "/channel"], i = createWebChannelTransport(), r = getStatEventTarget(), o = {
      httpSessionIdParam: "gsessionid",
      initMessageHeaders: {},
      messageUrlParams: {
        database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
      },
      sendRawJson: true,
      supportsCrossDomainXhr: true,
      internalChannelParams: {
        forwardChannelRequestTimeoutMs: 6e5
      },
      forceLongPolling: this.forceLongPolling,
      detectBufferingProxy: this.autoDetectLongPolling
    };
    this.useFetchStreams && (o.xmlHttpFactory = new FetchXmlHttpFactory({})), this.uo(o.initMessageHeaders, e, n), isMobileCordova() || isReactNative() || isElectron() || isIE() || isUWP() || isBrowserExtension() || (o.httpHeadersOverwriteParam = "$httpHeaders");
    const u = s.join("");
    M("Connection", "Creating WebChannel: " + u, o);
    const c = i.createWebChannel(u, o);
    let a = false, h = false;
    const l = new Xo({
      jr: (t2) => {
        h ? M("Connection", "Not sending because WebChannel is closed:", t2) : (a || (M("Connection", "Opening WebChannel transport."), c.open(), a = true), M("Connection", "WebChannel sending:", t2), c.send(t2));
      },
      Wr: () => c.close()
    }), y = (t2, e2, n2) => {
      t2.listen(e2, (t3) => {
        try {
          n2(t3);
        } catch (t4) {
          setTimeout(() => {
            throw t4;
          }, 0);
        }
      });
    };
    return y(c, WebChannel.EventType.OPEN, () => {
      h || M("Connection", "WebChannel transport opened.");
    }), y(c, WebChannel.EventType.CLOSE, () => {
      h || (h = true, M("Connection", "WebChannel transport closed"), l.eo());
    }), y(c, WebChannel.EventType.ERROR, (t2) => {
      h || (h = true, $("Connection", "WebChannel transport errored:", t2), l.eo(new Q(G.UNAVAILABLE, "The operation could not be completed")));
    }), y(c, WebChannel.EventType.MESSAGE, (t2) => {
      var e2;
      if (!h) {
        const n2 = t2.data[0];
        U(!!n2);
        const s2 = n2, i2 = s2.error || (null === (e2 = s2[0]) || void 0 === e2 ? void 0 : e2.error);
        if (i2) {
          M("Connection", "WebChannel received error:", i2);
          const t3 = i2.status;
          let e3 = function(t4) {
            const e4 = ts[t4];
            if (void 0 !== e4)
              return ss(e4);
          }(t3), n3 = i2.message;
          void 0 === e3 && (e3 = G.INTERNAL, n3 = "Unknown error status: " + t3 + " with message " + i2.message), h = true, l.eo(new Q(e3, n3)), c.close();
        } else
          M("Connection", "WebChannel received:", n2), l.no(n2);
      }
    }), y(r, Event.STAT_EVENT, (t2) => {
      t2.stat === Stat.PROXY ? M("Connection", "Detected buffering proxy") : t2.stat === Stat.NOPROXY && M("Connection", "Detected no buffering proxy");
    }), setTimeout(() => {
      l.Zr();
    }, 0), l;
  }
};
function tu() {
  return "undefined" != typeof window ? window : null;
}
function eu() {
  return "undefined" != typeof document ? document : null;
}
function nu(t) {
  return new Ss(t, true);
}
var su = class {
  constructor(t, e, n = 1e3, s = 1.5, i = 6e4) {
    this.js = t, this.timerId = e, this.lo = n, this.fo = s, this._o = i, this.wo = 0, this.mo = null, this.yo = Date.now(), this.reset();
  }
  reset() {
    this.wo = 0;
  }
  po() {
    this.wo = this._o;
  }
  Io(t) {
    this.cancel();
    const e = Math.floor(this.wo + this.To()), n = Math.max(0, Date.now() - this.yo), s = Math.max(0, e - n);
    s > 0 && M("ExponentialBackoff", `Backing off for ${s} ms (base delay: ${this.wo} ms, delay with jitter: ${e} ms, last attempt: ${n} ms ago)`), this.mo = this.js.enqueueAfterDelay(this.timerId, s, () => (this.yo = Date.now(), t())), this.wo *= this.fo, this.wo < this.lo && (this.wo = this.lo), this.wo > this._o && (this.wo = this._o);
  }
  Eo() {
    null !== this.mo && (this.mo.skipDelay(), this.mo = null);
  }
  cancel() {
    null !== this.mo && (this.mo.cancel(), this.mo = null);
  }
  To() {
    return (Math.random() - 0.5) * this.wo;
  }
};
var iu = class {
  constructor(t, e, n, s, i, r, o, u) {
    this.js = t, this.Ao = n, this.Ro = s, this.bo = i, this.authCredentialsProvider = r, this.appCheckCredentialsProvider = o, this.listener = u, this.state = 0, this.Po = 0, this.vo = null, this.Vo = null, this.stream = null, this.So = new su(t, e);
  }
  Do() {
    return 1 === this.state || 5 === this.state || this.Co();
  }
  Co() {
    return 2 === this.state || 3 === this.state;
  }
  start() {
    4 !== this.state ? this.auth() : this.xo();
  }
  async stop() {
    this.Do() && await this.close(0);
  }
  No() {
    this.state = 0, this.So.reset();
  }
  ko() {
    this.Co() && null === this.vo && (this.vo = this.js.enqueueAfterDelay(this.Ao, 6e4, () => this.Oo()));
  }
  Mo(t) {
    this.Fo(), this.stream.send(t);
  }
  async Oo() {
    if (this.Co())
      return this.close(0);
  }
  Fo() {
    this.vo && (this.vo.cancel(), this.vo = null);
  }
  $o() {
    this.Vo && (this.Vo.cancel(), this.Vo = null);
  }
  async close(t, e) {
    this.Fo(), this.$o(), this.So.cancel(), this.Po++, 4 !== t ? this.So.reset() : e && e.code === G.RESOURCE_EXHAUSTED ? (F(e.toString()), F("Using maximum backoff delay to prevent overloading the backend."), this.So.po()) : e && e.code === G.UNAUTHENTICATED && 3 !== this.state && (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), null !== this.stream && (this.Bo(), this.stream.close(), this.stream = null), this.state = t, await this.listener.Jr(e);
  }
  Bo() {
  }
  auth() {
    this.state = 1;
    const t = this.Lo(this.Po), e = this.Po;
    Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(([t2, n]) => {
      this.Po === e && this.Uo(t2, n);
    }, (e2) => {
      t(() => {
        const t2 = new Q(G.UNKNOWN, "Fetching auth token failed: " + e2.message);
        return this.qo(t2);
      });
    });
  }
  Uo(t, e) {
    const n = this.Lo(this.Po);
    this.stream = this.Ko(t, e), this.stream.zr(() => {
      n(() => (this.state = 2, this.Vo = this.js.enqueueAfterDelay(this.Ro, 1e4, () => (this.Co() && (this.state = 3), Promise.resolve())), this.listener.zr()));
    }), this.stream.Jr((t2) => {
      n(() => this.qo(t2));
    }), this.stream.onMessage((t2) => {
      n(() => this.onMessage(t2));
    });
  }
  xo() {
    this.state = 5, this.So.Io(async () => {
      this.state = 0, this.start();
    });
  }
  qo(t) {
    return M("PersistentStream", `close with error: ${t}`), this.stream = null, this.close(4, t);
  }
  Lo(t) {
    return (e) => {
      this.js.enqueueAndForget(() => this.Po === t ? e() : (M("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()));
    };
  }
};
var ru = class extends iu {
  constructor(t, e, n, s, i, r) {
    super(t, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", e, n, s, r), this.wt = i;
  }
  Ko(t, e) {
    return this.bo.ho("Listen", t, e);
  }
  onMessage(t) {
    this.So.reset();
    const e = Qs(this.wt, t), n = function(t2) {
      if (!("targetChange" in t2))
        return ct.min();
      const e2 = t2.targetChange;
      return e2.targetIds && e2.targetIds.length ? ct.min() : e2.readTime ? Ns(e2.readTime) : ct.min();
    }(t);
    return this.listener.Go(e, n);
  }
  Qo(t) {
    const e = {};
    e.database = Ls(this.wt), e.addTarget = function(t2, e2) {
      let n2;
      const s = e2.target;
      return n2 = $e(s) ? {
        documents: Hs(t2, s)
      } : {
        query: Js(t2, s)
      }, n2.targetId = e2.targetId, e2.resumeToken.approximateByteSize() > 0 ? n2.resumeToken = Cs(t2, e2.resumeToken) : e2.snapshotVersion.compareTo(ct.min()) > 0 && (n2.readTime = Ds(t2, e2.snapshotVersion.toTimestamp())), n2;
    }(this.wt, t);
    const n = Xs(this.wt, t);
    n && (e.labels = n), this.Mo(e);
  }
  jo(t) {
    const e = {};
    e.database = Ls(this.wt), e.removeTarget = t, this.Mo(e);
  }
};
var ou = class extends iu {
  constructor(t, e, n, s, i, r) {
    super(t, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", e, n, s, r), this.wt = i, this.Wo = false;
  }
  get zo() {
    return this.Wo;
  }
  start() {
    this.Wo = false, this.lastStreamToken = void 0, super.start();
  }
  Bo() {
    this.Wo && this.Ho([]);
  }
  Ko(t, e) {
    return this.bo.ho("Write", t, e);
  }
  onMessage(t) {
    if (U(!!t.streamToken), this.lastStreamToken = t.streamToken, this.Wo) {
      this.So.reset();
      const e = zs(t.writeResults, t.commitTime), n = Ns(t.commitTime);
      return this.listener.Jo(n, e);
    }
    return U(!t.writeResults || 0 === t.writeResults.length), this.Wo = true, this.listener.Yo();
  }
  Xo() {
    const t = {};
    t.database = Ls(this.wt), this.Mo(t);
  }
  Ho(t) {
    const e = {
      streamToken: this.lastStreamToken,
      writes: t.map((t2) => js(this.wt, t2))
    };
    this.Mo(e);
  }
};
var uu = class extends class {
} {
  constructor(t, e, n, s) {
    super(), this.authCredentials = t, this.appCheckCredentials = e, this.bo = n, this.wt = s, this.Zo = false;
  }
  tu() {
    if (this.Zo)
      throw new Q(G.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  ro(t, e, n) {
    return this.tu(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, i]) => this.bo.ro(t, e, n, s, i)).catch((t2) => {
      throw "FirebaseError" === t2.name ? (t2.code === G.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t2) : new Q(G.UNKNOWN, t2.toString());
    });
  }
  ao(t, e, n, s) {
    return this.tu(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([i, r]) => this.bo.ao(t, e, n, i, r, s)).catch((t2) => {
      throw "FirebaseError" === t2.name ? (t2.code === G.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t2) : new Q(G.UNKNOWN, t2.toString());
    });
  }
  terminate() {
    this.Zo = true;
  }
};
var cu = class {
  constructor(t, e) {
    this.asyncQueue = t, this.onlineStateHandler = e, this.state = "Unknown", this.eu = 0, this.nu = null, this.su = true;
  }
  iu() {
    0 === this.eu && (this.ru("Unknown"), this.nu = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.nu = null, this.ou("Backend didn't respond within 10 seconds."), this.ru("Offline"), Promise.resolve())));
  }
  uu(t) {
    "Online" === this.state ? this.ru("Unknown") : (this.eu++, this.eu >= 1 && (this.cu(), this.ou(`Connection failed 1 times. Most recent error: ${t.toString()}`), this.ru("Offline")));
  }
  set(t) {
    this.cu(), this.eu = 0, "Online" === t && (this.su = false), this.ru(t);
  }
  ru(t) {
    t !== this.state && (this.state = t, this.onlineStateHandler(t));
  }
  ou(t) {
    const e = `Could not reach Cloud Firestore backend. ${t}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
    this.su ? (F(e), this.su = false) : M("OnlineStateTracker", e);
  }
  cu() {
    null !== this.nu && (this.nu.cancel(), this.nu = null);
  }
};
var au = class {
  constructor(t, e, n, s, i) {
    this.localStore = t, this.datastore = e, this.asyncQueue = n, this.remoteSyncer = {}, this.au = [], this.hu = /* @__PURE__ */ new Map(), this.lu = /* @__PURE__ */ new Set(), this.fu = [], this.du = i, this.du.Br((t2) => {
      n.enqueueAndForget(async () => {
        yu(this) && (M("RemoteStore", "Restarting streams for network reachability change."), await async function(t3) {
          const e2 = K(t3);
          e2.lu.add(4), await lu(e2), e2._u.set("Unknown"), e2.lu.delete(4), await hu(e2);
        }(this));
      });
    }), this._u = new cu(n, s);
  }
};
async function hu(t) {
  if (yu(t))
    for (const e of t.fu)
      await e(true);
}
async function lu(t) {
  for (const e of t.fu)
    await e(false);
}
function fu(t, e) {
  const n = K(t);
  n.hu.has(e.targetId) || (n.hu.set(e.targetId, e), gu(n) ? mu(n) : Mu(n).Co() && _u(n, e));
}
function du(t, e) {
  const n = K(t), s = Mu(n);
  n.hu.delete(e), s.Co() && wu(n, e), 0 === n.hu.size && (s.Co() ? s.ko() : yu(n) && n._u.set("Unknown"));
}
function _u(t, e) {
  t.wu.Nt(e.targetId), Mu(t).Qo(e);
}
function wu(t, e) {
  t.wu.Nt(e), Mu(t).jo(e);
}
function mu(t) {
  t.wu = new Rs({
    getRemoteKeysForTarget: (e) => t.remoteSyncer.getRemoteKeysForTarget(e),
    te: (e) => t.hu.get(e) || null
  }), Mu(t).start(), t._u.iu();
}
function gu(t) {
  return yu(t) && !Mu(t).Do() && t.hu.size > 0;
}
function yu(t) {
  return 0 === K(t).lu.size;
}
function pu(t) {
  t.wu = void 0;
}
async function Iu(t) {
  t.hu.forEach((e, n) => {
    _u(t, e);
  });
}
async function Tu(t, e) {
  pu(t), gu(t) ? (t._u.uu(e), mu(t)) : t._u.set("Unknown");
}
async function Eu(t, e, n) {
  if (t._u.set("Online"), e instanceof Es && 2 === e.state && e.cause)
    try {
      await async function(t2, e2) {
        const n2 = e2.cause;
        for (const s of e2.targetIds)
          t2.hu.has(s) && (await t2.remoteSyncer.rejectListen(s, n2), t2.hu.delete(s), t2.wu.removeTarget(s));
      }(t, e);
    } catch (n2) {
      M("RemoteStore", "Failed to remove targets %s: %s ", e.targetIds.join(","), n2), await Au(t, n2);
    }
  else if (e instanceof Is ? t.wu.Ut(e) : e instanceof Ts ? t.wu.zt(e) : t.wu.Gt(e), !n.isEqual(ct.min()))
    try {
      const e2 = await vo(t.localStore);
      n.compareTo(e2) >= 0 && await function(t2, e3) {
        const n2 = t2.wu.Yt(e3);
        return n2.targetChanges.forEach((n3, s) => {
          if (n3.resumeToken.approximateByteSize() > 0) {
            const i = t2.hu.get(s);
            i && t2.hu.set(s, i.withResumeToken(n3.resumeToken, e3));
          }
        }), n2.targetMismatches.forEach((e4) => {
          const n3 = t2.hu.get(e4);
          if (!n3)
            return;
          t2.hu.set(e4, n3.withResumeToken(Jt.EMPTY_BYTE_STRING, n3.snapshotVersion)), wu(t2, e4);
          const s = new Li(n3.target, e4, 1, n3.sequenceNumber);
          _u(t2, s);
        }), t2.remoteSyncer.applyRemoteEvent(n2);
      }(t, n);
    } catch (e2) {
      M("RemoteStore", "Failed to raise snapshot:", e2), await Au(t, e2);
    }
}
async function Au(t, e, n) {
  if (!Ct(e))
    throw e;
  t.lu.add(1), await lu(t), t._u.set("Offline"), n || (n = () => vo(t.localStore)), t.asyncQueue.enqueueRetryable(async () => {
    M("RemoteStore", "Retrying IndexedDB access"), await n(), t.lu.delete(1), await hu(t);
  });
}
function Ru(t, e) {
  return e().catch((n) => Au(t, n, e));
}
async function bu(t) {
  const e = K(t), n = Fu(e);
  let s = e.au.length > 0 ? e.au[e.au.length - 1].batchId : -1;
  for (; Pu(e); )
    try {
      const t2 = await Do(e.localStore, s);
      if (null === t2) {
        0 === e.au.length && n.ko();
        break;
      }
      s = t2.batchId, vu(e, t2);
    } catch (t2) {
      await Au(e, t2);
    }
  Vu(e) && Su(e);
}
function Pu(t) {
  return yu(t) && t.au.length < 10;
}
function vu(t, e) {
  t.au.push(e);
  const n = Fu(t);
  n.Co() && n.zo && n.Ho(e.mutations);
}
function Vu(t) {
  return yu(t) && !Fu(t).Do() && t.au.length > 0;
}
function Su(t) {
  Fu(t).start();
}
async function Du(t) {
  Fu(t).Xo();
}
async function Cu(t) {
  const e = Fu(t);
  for (const n of t.au)
    e.Ho(n.mutations);
}
async function xu(t, e, n) {
  const s = t.au.shift(), i = $i.from(s, e, n);
  await Ru(t, () => t.remoteSyncer.applySuccessfulWrite(i)), await bu(t);
}
async function Nu(t, e) {
  e && Fu(t).zo && await async function(t2, e2) {
    if (n = e2.code, ns(n) && n !== G.ABORTED) {
      const n2 = t2.au.shift();
      Fu(t2).No(), await Ru(t2, () => t2.remoteSyncer.rejectFailedWrite(n2.batchId, e2)), await bu(t2);
    }
    var n;
  }(t, e), Vu(t) && Su(t);
}
async function ku(t, e) {
  const n = K(t);
  n.asyncQueue.verifyOperationInProgress(), M("RemoteStore", "RemoteStore received new credentials");
  const s = yu(n);
  n.lu.add(3), await lu(n), s && n._u.set("Unknown"), await n.remoteSyncer.handleCredentialChange(e), n.lu.delete(3), await hu(n);
}
async function Ou(t, e) {
  const n = K(t);
  e ? (n.lu.delete(2), await hu(n)) : e || (n.lu.add(2), await lu(n), n._u.set("Unknown"));
}
function Mu(t) {
  return t.mu || (t.mu = function(t2, e, n) {
    const s = K(t2);
    return s.tu(), new ru(e, s.bo, s.authCredentials, s.appCheckCredentials, s.wt, n);
  }(t.datastore, t.asyncQueue, {
    zr: Iu.bind(null, t),
    Jr: Tu.bind(null, t),
    Go: Eu.bind(null, t)
  }), t.fu.push(async (e) => {
    e ? (t.mu.No(), gu(t) ? mu(t) : t._u.set("Unknown")) : (await t.mu.stop(), pu(t));
  })), t.mu;
}
function Fu(t) {
  return t.gu || (t.gu = function(t2, e, n) {
    const s = K(t2);
    return s.tu(), new ou(e, s.bo, s.authCredentials, s.appCheckCredentials, s.wt, n);
  }(t.datastore, t.asyncQueue, {
    zr: Du.bind(null, t),
    Jr: Nu.bind(null, t),
    Yo: Cu.bind(null, t),
    Jo: xu.bind(null, t)
  }), t.fu.push(async (e) => {
    e ? (t.gu.No(), await bu(t)) : (await t.gu.stop(), t.au.length > 0 && (M("RemoteStore", `Stopping write stream with ${t.au.length} pending writes`), t.au = []));
  })), t.gu;
}
var $u = class {
  constructor(t, e, n, s, i) {
    this.asyncQueue = t, this.timerId = e, this.targetTimeMs = n, this.op = s, this.removalCallback = i, this.deferred = new j(), this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch((t2) => {
    });
  }
  static createAndSchedule(t, e, n, s, i) {
    const r = Date.now() + n, o = new $u(t, e, r, s, i);
    return o.start(n), o;
  }
  start(t) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), t);
  }
  skipDelay() {
    return this.handleDelayElapsed();
  }
  cancel(t) {
    null !== this.timerHandle && (this.clearTimeout(), this.deferred.reject(new Q(G.CANCELLED, "Operation cancelled" + (t ? ": " + t : ""))));
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => null !== this.timerHandle ? (this.clearTimeout(), this.op().then((t) => this.deferred.resolve(t))) : Promise.resolve());
  }
  clearTimeout() {
    null !== this.timerHandle && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
  }
};
function Bu(t, e) {
  if (F("AsyncQueue", `${e}: ${t}`), Ct(t))
    return new Q(G.UNAVAILABLE, `${e}: ${t}`);
  throw t;
}
var Lu = class {
  constructor(t) {
    this.comparator = t ? (e, n) => t(e, n) || dt.comparator(e.key, n.key) : (t2, e) => dt.comparator(t2.key, e.key), this.keyedMap = cs(), this.sortedSet = new qt(this.comparator);
  }
  static emptySet(t) {
    return new Lu(t.comparator);
  }
  has(t) {
    return null != this.keyedMap.get(t);
  }
  get(t) {
    return this.keyedMap.get(t);
  }
  first() {
    return this.sortedSet.minKey();
  }
  last() {
    return this.sortedSet.maxKey();
  }
  isEmpty() {
    return this.sortedSet.isEmpty();
  }
  indexOf(t) {
    const e = this.keyedMap.get(t);
    return e ? this.sortedSet.indexOf(e) : -1;
  }
  get size() {
    return this.sortedSet.size;
  }
  forEach(t) {
    this.sortedSet.inorderTraversal((e, n) => (t(e), false));
  }
  add(t) {
    const e = this.delete(t.key);
    return e.copy(e.keyedMap.insert(t.key, t), e.sortedSet.insert(t, null));
  }
  delete(t) {
    const e = this.get(t);
    return e ? this.copy(this.keyedMap.remove(t), this.sortedSet.remove(e)) : this;
  }
  isEqual(t) {
    if (!(t instanceof Lu))
      return false;
    if (this.size !== t.size)
      return false;
    const e = this.sortedSet.getIterator(), n = t.sortedSet.getIterator();
    for (; e.hasNext(); ) {
      const t2 = e.getNext().key, s = n.getNext().key;
      if (!t2.isEqual(s))
        return false;
    }
    return true;
  }
  toString() {
    const t = [];
    return this.forEach((e) => {
      t.push(e.toString());
    }), 0 === t.length ? "DocumentSet ()" : "DocumentSet (\n  " + t.join("  \n") + "\n)";
  }
  copy(t, e) {
    const n = new Lu();
    return n.comparator = this.comparator, n.keyedMap = t, n.sortedSet = e, n;
  }
};
var Uu = class {
  constructor() {
    this.yu = new qt(dt.comparator);
  }
  track(t) {
    const e = t.doc.key, n = this.yu.get(e);
    n ? 0 !== t.type && 3 === n.type ? this.yu = this.yu.insert(e, t) : 3 === t.type && 1 !== n.type ? this.yu = this.yu.insert(e, {
      type: n.type,
      doc: t.doc
    }) : 2 === t.type && 2 === n.type ? this.yu = this.yu.insert(e, {
      type: 2,
      doc: t.doc
    }) : 2 === t.type && 0 === n.type ? this.yu = this.yu.insert(e, {
      type: 0,
      doc: t.doc
    }) : 1 === t.type && 0 === n.type ? this.yu = this.yu.remove(e) : 1 === t.type && 2 === n.type ? this.yu = this.yu.insert(e, {
      type: 1,
      doc: n.doc
    }) : 0 === t.type && 1 === n.type ? this.yu = this.yu.insert(e, {
      type: 2,
      doc: t.doc
    }) : L() : this.yu = this.yu.insert(e, t);
  }
  pu() {
    const t = [];
    return this.yu.inorderTraversal((e, n) => {
      t.push(n);
    }), t;
  }
};
var qu = class {
  constructor(t, e, n, s, i, r, o, u) {
    this.query = t, this.docs = e, this.oldDocs = n, this.docChanges = s, this.mutatedKeys = i, this.fromCache = r, this.syncStateChanged = o, this.excludesMetadataChanges = u;
  }
  static fromInitialDocuments(t, e, n, s) {
    const i = [];
    return e.forEach((t2) => {
      i.push({
        type: 0,
        doc: t2
      });
    }), new qu(t, e, Lu.emptySet(e), i, n, s, true, false);
  }
  get hasPendingWrites() {
    return !this.mutatedKeys.isEmpty();
  }
  isEqual(t) {
    if (!(this.fromCache === t.fromCache && this.syncStateChanged === t.syncStateChanged && this.mutatedKeys.isEqual(t.mutatedKeys) && dn(this.query, t.query) && this.docs.isEqual(t.docs) && this.oldDocs.isEqual(t.oldDocs)))
      return false;
    const e = this.docChanges, n = t.docChanges;
    if (e.length !== n.length)
      return false;
    for (let t2 = 0; t2 < e.length; t2++)
      if (e[t2].type !== n[t2].type || !e[t2].doc.isEqual(n[t2].doc))
        return false;
    return true;
  }
};
var Ku = class {
  constructor() {
    this.Iu = void 0, this.listeners = [];
  }
};
var Gu = class {
  constructor() {
    this.queries = new is((t) => _n(t), dn), this.onlineState = "Unknown", this.Tu = /* @__PURE__ */ new Set();
  }
};
async function Qu(t, e) {
  const n = K(t), s = e.query;
  let i = false, r = n.queries.get(s);
  if (r || (i = true, r = new Ku()), i)
    try {
      r.Iu = await n.onListen(s);
    } catch (t2) {
      const n2 = Bu(t2, `Initialization of query '${wn(e.query)}' failed`);
      return void e.onError(n2);
    }
  if (n.queries.set(s, r), r.listeners.push(e), e.Eu(n.onlineState), r.Iu) {
    e.Au(r.Iu) && Hu(n);
  }
}
async function ju(t, e) {
  const n = K(t), s = e.query;
  let i = false;
  const r = n.queries.get(s);
  if (r) {
    const t2 = r.listeners.indexOf(e);
    t2 >= 0 && (r.listeners.splice(t2, 1), i = 0 === r.listeners.length);
  }
  if (i)
    return n.queries.delete(s), n.onUnlisten(s);
}
function Wu(t, e) {
  const n = K(t);
  let s = false;
  for (const t2 of e) {
    const e2 = t2.query, i = n.queries.get(e2);
    if (i) {
      for (const e3 of i.listeners)
        e3.Au(t2) && (s = true);
      i.Iu = t2;
    }
  }
  s && Hu(n);
}
function zu(t, e, n) {
  const s = K(t), i = s.queries.get(e);
  if (i)
    for (const t2 of i.listeners)
      t2.onError(n);
  s.queries.delete(e);
}
function Hu(t) {
  t.Tu.forEach((t2) => {
    t2.next();
  });
}
var Ju = class {
  constructor(t, e, n) {
    this.query = t, this.Ru = e, this.bu = false, this.Pu = null, this.onlineState = "Unknown", this.options = n || {};
  }
  Au(t) {
    if (!this.options.includeMetadataChanges) {
      const e2 = [];
      for (const n of t.docChanges)
        3 !== n.type && e2.push(n);
      t = new qu(t.query, t.docs, t.oldDocs, e2, t.mutatedKeys, t.fromCache, t.syncStateChanged, true);
    }
    let e = false;
    return this.bu ? this.vu(t) && (this.Ru.next(t), e = true) : this.Vu(t, this.onlineState) && (this.Su(t), e = true), this.Pu = t, e;
  }
  onError(t) {
    this.Ru.error(t);
  }
  Eu(t) {
    this.onlineState = t;
    let e = false;
    return this.Pu && !this.bu && this.Vu(this.Pu, t) && (this.Su(this.Pu), e = true), e;
  }
  Vu(t, e) {
    if (!t.fromCache)
      return true;
    const n = "Offline" !== e;
    return (!this.options.Du || !n) && (!t.docs.isEmpty() || "Offline" === e);
  }
  vu(t) {
    if (t.docChanges.length > 0)
      return true;
    const e = this.Pu && this.Pu.hasPendingWrites !== t.hasPendingWrites;
    return !(!t.syncStateChanged && !e) && true === this.options.includeMetadataChanges;
  }
  Su(t) {
    t = qu.fromInitialDocuments(t.query, t.docs, t.mutatedKeys, t.fromCache), this.bu = true, this.Ru.next(t);
  }
};
var Yu = class {
  constructor(t, e) {
    this.payload = t, this.byteLength = e;
  }
  Cu() {
    return "metadata" in this.payload;
  }
};
var Xu = class {
  constructor(t) {
    this.wt = t;
  }
  Wi(t) {
    return Fs(this.wt, t);
  }
  zi(t) {
    return t.metadata.exists ? Ks(this.wt, t.document, false) : xe.newNoDocument(this.Wi(t.metadata.name), this.Hi(t.metadata.readTime));
  }
  Hi(t) {
    return Ns(t);
  }
};
var Zu = class {
  constructor(t, e, n) {
    this.xu = t, this.localStore = e, this.wt = n, this.queries = [], this.documents = [], this.collectionGroups = /* @__PURE__ */ new Set(), this.progress = tc(t);
  }
  Nu(t) {
    this.progress.bytesLoaded += t.byteLength;
    let e = this.progress.documentsLoaded;
    if (t.payload.namedQuery)
      this.queries.push(t.payload.namedQuery);
    else if (t.payload.documentMetadata) {
      this.documents.push({
        metadata: t.payload.documentMetadata
      }), t.payload.documentMetadata.exists || ++e;
      const n = ht.fromString(t.payload.documentMetadata.name);
      this.collectionGroups.add(n.get(n.length - 2));
    } else
      t.payload.document && (this.documents[this.documents.length - 1].document = t.payload.document, ++e);
    return e !== this.progress.documentsLoaded ? (this.progress.documentsLoaded = e, Object.assign({}, this.progress)) : null;
  }
  ku(t) {
    const e = /* @__PURE__ */ new Map(), n = new Xu(this.wt);
    for (const s of t)
      if (s.metadata.queries) {
        const t2 = n.Wi(s.metadata.name);
        for (const n2 of s.metadata.queries) {
          const s2 = (e.get(n2) || ws()).add(t2);
          e.set(n2, s2);
        }
      }
    return e;
  }
  async complete() {
    const t = await Fo(this.localStore, new Xu(this.wt), this.documents, this.xu.id), e = this.ku(this.documents);
    for (const t2 of this.queries)
      await $o(this.localStore, t2, e.get(t2.name));
    return this.progress.taskState = "Success", {
      progress: this.progress,
      Ou: this.collectionGroups,
      Mu: t
    };
  }
};
function tc(t) {
  return {
    taskState: "Running",
    documentsLoaded: 0,
    bytesLoaded: 0,
    totalDocuments: t.totalDocuments,
    totalBytes: t.totalBytes
  };
}
var ec = class {
  constructor(t) {
    this.key = t;
  }
};
var nc = class {
  constructor(t) {
    this.key = t;
  }
};
var sc = class {
  constructor(t, e) {
    this.query = t, this.Fu = e, this.$u = null, this.current = false, this.Bu = ws(), this.mutatedKeys = ws(), this.Lu = yn(t), this.Uu = new Lu(this.Lu);
  }
  get qu() {
    return this.Fu;
  }
  Ku(t, e) {
    const n = e ? e.Gu : new Uu(), s = e ? e.Uu : this.Uu;
    let i = e ? e.mutatedKeys : this.mutatedKeys, r = s, o = false;
    const u = "F" === this.query.limitType && s.size === this.query.limit ? s.last() : null, c = "L" === this.query.limitType && s.size === this.query.limit ? s.first() : null;
    if (t.inorderTraversal((t2, e2) => {
      const a = s.get(t2), h = mn(this.query, e2) ? e2 : null, l = !!a && this.mutatedKeys.has(a.key), f = !!h && (h.hasLocalMutations || this.mutatedKeys.has(h.key) && h.hasCommittedMutations);
      let d = false;
      if (a && h) {
        a.data.isEqual(h.data) ? l !== f && (n.track({
          type: 3,
          doc: h
        }), d = true) : this.Qu(a, h) || (n.track({
          type: 2,
          doc: h
        }), d = true, (u && this.Lu(h, u) > 0 || c && this.Lu(h, c) < 0) && (o = true));
      } else
        !a && h ? (n.track({
          type: 0,
          doc: h
        }), d = true) : a && !h && (n.track({
          type: 1,
          doc: a
        }), d = true, (u || c) && (o = true));
      d && (h ? (r = r.add(h), i = f ? i.add(t2) : i.delete(t2)) : (r = r.delete(t2), i = i.delete(t2)));
    }), null !== this.query.limit)
      for (; r.size > this.query.limit; ) {
        const t2 = "F" === this.query.limitType ? r.last() : r.first();
        r = r.delete(t2.key), i = i.delete(t2.key), n.track({
          type: 1,
          doc: t2
        });
      }
    return {
      Uu: r,
      Gu: n,
      Oi: o,
      mutatedKeys: i
    };
  }
  Qu(t, e) {
    return t.hasLocalMutations && e.hasCommittedMutations && !e.hasLocalMutations;
  }
  applyChanges(t, e, n) {
    const s = this.Uu;
    this.Uu = t.Uu, this.mutatedKeys = t.mutatedKeys;
    const i = t.Gu.pu();
    i.sort((t2, e2) => function(t3, e3) {
      const n2 = (t4) => {
        switch (t4) {
          case 0:
            return 1;
          case 2:
          case 3:
            return 2;
          case 1:
            return 0;
          default:
            return L();
        }
      };
      return n2(t3) - n2(e3);
    }(t2.type, e2.type) || this.Lu(t2.doc, e2.doc)), this.ju(n);
    const r = e ? this.Wu() : [], o = 0 === this.Bu.size && this.current ? 1 : 0, u = o !== this.$u;
    if (this.$u = o, 0 !== i.length || u) {
      return {
        snapshot: new qu(this.query, t.Uu, s, i, t.mutatedKeys, 0 === o, u, false),
        zu: r
      };
    }
    return {
      zu: r
    };
  }
  Eu(t) {
    return this.current && "Offline" === t ? (this.current = false, this.applyChanges({
      Uu: this.Uu,
      Gu: new Uu(),
      mutatedKeys: this.mutatedKeys,
      Oi: false
    }, false)) : {
      zu: []
    };
  }
  Hu(t) {
    return !this.Fu.has(t) && (!!this.Uu.has(t) && !this.Uu.get(t).hasLocalMutations);
  }
  ju(t) {
    t && (t.addedDocuments.forEach((t2) => this.Fu = this.Fu.add(t2)), t.modifiedDocuments.forEach((t2) => {
    }), t.removedDocuments.forEach((t2) => this.Fu = this.Fu.delete(t2)), this.current = t.current);
  }
  Wu() {
    if (!this.current)
      return [];
    const t = this.Bu;
    this.Bu = ws(), this.Uu.forEach((t2) => {
      this.Hu(t2.key) && (this.Bu = this.Bu.add(t2.key));
    });
    const e = [];
    return t.forEach((t2) => {
      this.Bu.has(t2) || e.push(new nc(t2));
    }), this.Bu.forEach((n) => {
      t.has(n) || e.push(new ec(n));
    }), e;
  }
  Ju(t) {
    this.Fu = t.ji, this.Bu = ws();
    const e = this.Ku(t.documents);
    return this.applyChanges(e, true);
  }
  Yu() {
    return qu.fromInitialDocuments(this.query, this.Uu, this.mutatedKeys, 0 === this.$u);
  }
};
var ic = class {
  constructor(t, e, n) {
    this.query = t, this.targetId = e, this.view = n;
  }
};
var rc = class {
  constructor(t) {
    this.key = t, this.Xu = false;
  }
};
var oc = class {
  constructor(t, e, n, s, i, r) {
    this.localStore = t, this.remoteStore = e, this.eventManager = n, this.sharedClientState = s, this.currentUser = i, this.maxConcurrentLimboResolutions = r, this.Zu = {}, this.tc = new is((t2) => _n(t2), dn), this.ec = /* @__PURE__ */ new Map(), this.nc = /* @__PURE__ */ new Set(), this.sc = new qt(dt.comparator), this.ic = /* @__PURE__ */ new Map(), this.rc = new io(), this.oc = {}, this.uc = /* @__PURE__ */ new Map(), this.cc = kr.Rn(), this.onlineState = "Unknown", this.ac = void 0;
  }
  get isPrimaryClient() {
    return true === this.ac;
  }
};
async function uc(t, e) {
  const n = Mc(t);
  let s, i;
  const r = n.tc.get(e);
  if (r)
    s = r.targetId, n.sharedClientState.addLocalQueryTarget(s), i = r.view.Yu();
  else {
    const t2 = await Co(n.localStore, ln(e));
    n.isPrimaryClient && fu(n.remoteStore, t2);
    const r2 = n.sharedClientState.addLocalQueryTarget(t2.targetId);
    s = t2.targetId, i = await cc(n, e, s, "current" === r2);
  }
  return i;
}
async function cc(t, e, n, s) {
  t.hc = (e2, n2, s2) => async function(t2, e3, n3, s3) {
    let i2 = e3.view.Ku(n3);
    i2.Oi && (i2 = await No(t2.localStore, e3.query, false).then(({ documents: t3 }) => e3.view.Ku(t3, i2)));
    const r2 = s3 && s3.targetChanges.get(e3.targetId), o2 = e3.view.applyChanges(i2, t2.isPrimaryClient, r2);
    return Tc(t2, e3.targetId, o2.zu), o2.snapshot;
  }(t, e2, n2, s2);
  const i = await No(t.localStore, e, true), r = new sc(e, i.ji), o = r.Ku(i.documents), u = ps.createSynthesizedTargetChangeForCurrentChange(n, s && "Offline" !== t.onlineState), c = r.applyChanges(o, t.isPrimaryClient, u);
  Tc(t, n, c.zu);
  const a = new ic(e, n, r);
  return t.tc.set(e, a), t.ec.has(n) ? t.ec.get(n).push(e) : t.ec.set(n, [e]), c.snapshot;
}
async function ac(t, e) {
  const n = K(t), s = n.tc.get(e), i = n.ec.get(s.targetId);
  if (i.length > 1)
    return n.ec.set(s.targetId, i.filter((t2) => !dn(t2, e))), void n.tc.delete(e);
  if (n.isPrimaryClient) {
    n.sharedClientState.removeLocalQueryTarget(s.targetId);
    n.sharedClientState.isActiveQueryTarget(s.targetId) || await xo(n.localStore, s.targetId, false).then(() => {
      n.sharedClientState.clearQueryState(s.targetId), du(n.remoteStore, s.targetId), pc(n, s.targetId);
    }).catch(bt);
  } else
    pc(n, s.targetId), await xo(n.localStore, s.targetId, true);
}
async function hc(t, e, n) {
  const s = Fc(t);
  try {
    const t2 = await function(t3, e2) {
      const n2 = K(t3), s2 = ut.now(), i = e2.reduce((t4, e3) => t4.add(e3.key), ws());
      let r, o;
      return n2.persistence.runTransaction("Locally write mutations", "readwrite", (t4) => {
        let u = os(), c = ws();
        return n2.Ui.getEntries(t4, i).next((t5) => {
          u = t5, u.forEach((t6, e3) => {
            e3.isValidDocument() || (c = c.add(t6));
          });
        }).next(() => n2.localDocuments.getOverlayedDocuments(t4, u)).next((i2) => {
          r = i2;
          const o2 = [];
          for (const t5 of e2) {
            const e3 = Gn(t5, r.get(t5.key).overlayedDocument);
            null != e3 && o2.push(new Wn(t5.key, e3, Ce(e3.value.mapValue), $n.exists(true)));
          }
          return n2.mutationQueue.addMutationBatch(t4, s2, o2, e2);
        }).next((e3) => {
          o = e3;
          const s3 = e3.applyToLocalDocumentSet(r, c);
          return n2.documentOverlayCache.saveOverlays(t4, e3.batchId, s3);
        });
      }).then(() => ({
        batchId: o.batchId,
        changes: as(r)
      }));
    }(s.localStore, e);
    s.sharedClientState.addPendingMutation(t2.batchId), function(t3, e2, n2) {
      let s2 = t3.oc[t3.currentUser.toKey()];
      s2 || (s2 = new qt(it));
      s2 = s2.insert(e2, n2), t3.oc[t3.currentUser.toKey()] = s2;
    }(s, t2.batchId, n), await Rc(s, t2.changes), await bu(s.remoteStore);
  } catch (t2) {
    const e2 = Bu(t2, "Failed to persist write");
    n.reject(e2);
  }
}
async function lc(t, e) {
  const n = K(t);
  try {
    const t2 = await Vo(n.localStore, e);
    e.targetChanges.forEach((t3, e2) => {
      const s = n.ic.get(e2);
      s && (U(t3.addedDocuments.size + t3.modifiedDocuments.size + t3.removedDocuments.size <= 1), t3.addedDocuments.size > 0 ? s.Xu = true : t3.modifiedDocuments.size > 0 ? U(s.Xu) : t3.removedDocuments.size > 0 && (U(s.Xu), s.Xu = false));
    }), await Rc(n, t2, e);
  } catch (t2) {
    await bt(t2);
  }
}
function fc(t, e, n) {
  const s = K(t);
  if (s.isPrimaryClient && 0 === n || !s.isPrimaryClient && 1 === n) {
    const t2 = [];
    s.tc.forEach((n2, s2) => {
      const i = s2.view.Eu(e);
      i.snapshot && t2.push(i.snapshot);
    }), function(t3, e2) {
      const n2 = K(t3);
      n2.onlineState = e2;
      let s2 = false;
      n2.queries.forEach((t4, n3) => {
        for (const t5 of n3.listeners)
          t5.Eu(e2) && (s2 = true);
      }), s2 && Hu(n2);
    }(s.eventManager, e), t2.length && s.Zu.Go(t2), s.onlineState = e, s.isPrimaryClient && s.sharedClientState.setOnlineState(e);
  }
}
async function dc(t, e, n) {
  const s = K(t);
  s.sharedClientState.updateQueryState(e, "rejected", n);
  const i = s.ic.get(e), r = i && i.key;
  if (r) {
    let t2 = new qt(dt.comparator);
    t2 = t2.insert(r, xe.newNoDocument(r, ct.min()));
    const n2 = ws().add(r), i2 = new ys(ct.min(), /* @__PURE__ */ new Map(), new Qt(it), t2, n2);
    await lc(s, i2), s.sc = s.sc.remove(r), s.ic.delete(e), Ac(s);
  } else
    await xo(s.localStore, e, false).then(() => pc(s, e, n)).catch(bt);
}
async function _c(t, e) {
  const n = K(t), s = e.batch.batchId;
  try {
    const t2 = await Po(n.localStore, e);
    yc(n, s, null), gc(n, s), n.sharedClientState.updateMutationState(s, "acknowledged"), await Rc(n, t2);
  } catch (t2) {
    await bt(t2);
  }
}
async function wc(t, e, n) {
  const s = K(t);
  try {
    const t2 = await function(t3, e2) {
      const n2 = K(t3);
      return n2.persistence.runTransaction("Reject batch", "readwrite-primary", (t4) => {
        let s2;
        return n2.mutationQueue.lookupMutationBatch(t4, e2).next((e3) => (U(null !== e3), s2 = e3.keys(), n2.mutationQueue.removeMutationBatch(t4, e3))).next(() => n2.mutationQueue.performConsistencyCheck(t4)).next(() => n2.documentOverlayCache.removeOverlaysForBatchId(t4, s2, e2)).next(() => n2.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(t4, s2)).next(() => n2.localDocuments.getDocuments(t4, s2));
      });
    }(s.localStore, e);
    yc(s, e, n), gc(s, e), s.sharedClientState.updateMutationState(e, "rejected", n), await Rc(s, t2);
  } catch (n2) {
    await bt(n2);
  }
}
async function mc(t, e) {
  const n = K(t);
  yu(n.remoteStore) || M("SyncEngine", "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled.");
  try {
    const t2 = await function(t3) {
      const e2 = K(t3);
      return e2.persistence.runTransaction("Get highest unacknowledged batch id", "readonly", (t4) => e2.mutationQueue.getHighestUnacknowledgedBatchId(t4));
    }(n.localStore);
    if (-1 === t2)
      return void e.resolve();
    const s = n.uc.get(t2) || [];
    s.push(e), n.uc.set(t2, s);
  } catch (t2) {
    const n2 = Bu(t2, "Initialization of waitForPendingWrites() operation failed");
    e.reject(n2);
  }
}
function gc(t, e) {
  (t.uc.get(e) || []).forEach((t2) => {
    t2.resolve();
  }), t.uc.delete(e);
}
function yc(t, e, n) {
  const s = K(t);
  let i = s.oc[s.currentUser.toKey()];
  if (i) {
    const t2 = i.get(e);
    t2 && (n ? t2.reject(n) : t2.resolve(), i = i.remove(e)), s.oc[s.currentUser.toKey()] = i;
  }
}
function pc(t, e, n = null) {
  t.sharedClientState.removeLocalQueryTarget(e);
  for (const s of t.ec.get(e))
    t.tc.delete(s), n && t.Zu.lc(s, n);
  if (t.ec.delete(e), t.isPrimaryClient) {
    t.rc.us(e).forEach((e2) => {
      t.rc.containsKey(e2) || Ic(t, e2);
    });
  }
}
function Ic(t, e) {
  t.nc.delete(e.path.canonicalString());
  const n = t.sc.get(e);
  null !== n && (du(t.remoteStore, n), t.sc = t.sc.remove(e), t.ic.delete(n), Ac(t));
}
function Tc(t, e, n) {
  for (const s of n)
    if (s instanceof ec)
      t.rc.addReference(s.key, e), Ec(t, s);
    else if (s instanceof nc) {
      M("SyncEngine", "Document no longer in limbo: " + s.key), t.rc.removeReference(s.key, e);
      t.rc.containsKey(s.key) || Ic(t, s.key);
    } else
      L();
}
function Ec(t, e) {
  const n = e.key, s = n.path.canonicalString();
  t.sc.get(n) || t.nc.has(s) || (M("SyncEngine", "New document in limbo: " + n), t.nc.add(s), Ac(t));
}
function Ac(t) {
  for (; t.nc.size > 0 && t.sc.size < t.maxConcurrentLimboResolutions; ) {
    const e = t.nc.values().next().value;
    t.nc.delete(e);
    const n = new dt(ht.fromString(e)), s = t.cc.next();
    t.ic.set(s, new rc(n)), t.sc = t.sc.insert(n, s), fu(t.remoteStore, new Li(ln(rn(n.path)), s, 2, $t.ot));
  }
}
async function Rc(t, e, n) {
  const s = K(t), i = [], r = [], o = [];
  s.tc.isEmpty() || (s.tc.forEach((t2, u) => {
    o.push(s.hc(u, e, n).then((t3) => {
      if (t3) {
        s.isPrimaryClient && s.sharedClientState.updateQueryState(u.targetId, t3.fromCache ? "not-current" : "current"), i.push(t3);
        const e2 = To.Vi(u.targetId, t3);
        r.push(e2);
      }
    }));
  }), await Promise.all(o), s.Zu.Go(i), await async function(t2, e2) {
    const n2 = K(t2);
    try {
      await n2.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (t3) => Pt.forEach(e2, (e3) => Pt.forEach(e3.Pi, (s2) => n2.persistence.referenceDelegate.addReference(t3, e3.targetId, s2)).next(() => Pt.forEach(e3.vi, (s2) => n2.persistence.referenceDelegate.removeReference(t3, e3.targetId, s2)))));
    } catch (t3) {
      if (!Ct(t3))
        throw t3;
      M("LocalStore", "Failed to update sequence numbers: " + t3);
    }
    for (const t3 of e2) {
      const e3 = t3.targetId;
      if (!t3.fromCache) {
        const t4 = n2.$i.get(e3), s2 = t4.snapshotVersion, i2 = t4.withLastLimboFreeSnapshotVersion(s2);
        n2.$i = n2.$i.insert(e3, i2);
      }
    }
  }(s.localStore, r));
}
async function bc(t, e) {
  const n = K(t);
  if (!n.currentUser.isEqual(e)) {
    M("SyncEngine", "User change. New user:", e.toKey());
    const t2 = await bo(n.localStore, e);
    n.currentUser = e, function(t3, e2) {
      t3.uc.forEach((t4) => {
        t4.forEach((t5) => {
          t5.reject(new Q(G.CANCELLED, e2));
        });
      }), t3.uc.clear();
    }(n, "'waitForPendingWrites' promise is rejected due to a user change."), n.sharedClientState.handleUserChange(e, t2.removedBatchIds, t2.addedBatchIds), await Rc(n, t2.Ki);
  }
}
function Pc(t, e) {
  const n = K(t), s = n.ic.get(e);
  if (s && s.Xu)
    return ws().add(s.key);
  {
    let t2 = ws();
    const s2 = n.ec.get(e);
    if (!s2)
      return t2;
    for (const e2 of s2) {
      const s3 = n.tc.get(e2);
      t2 = t2.unionWith(s3.view.qu);
    }
    return t2;
  }
}
async function vc(t, e) {
  const n = K(t), s = await No(n.localStore, e.query, true), i = e.view.Ju(s);
  return n.isPrimaryClient && Tc(n, e.targetId, i.zu), i;
}
async function Vc(t, e) {
  const n = K(t);
  return Oo(n.localStore, e).then((t2) => Rc(n, t2));
}
async function Sc(t, e, n, s) {
  const i = K(t), r = await function(t2, e2) {
    const n2 = K(t2), s2 = K(n2.mutationQueue);
    return n2.persistence.runTransaction("Lookup mutation documents", "readonly", (t3) => s2.yn(t3, e2).next((e3) => e3 ? n2.localDocuments.getDocuments(t3, e3) : Pt.resolve(null)));
  }(i.localStore, e);
  null !== r ? ("pending" === n ? await bu(i.remoteStore) : "acknowledged" === n || "rejected" === n ? (yc(i, e, s || null), gc(i, e), function(t2, e2) {
    K(K(t2).mutationQueue).In(e2);
  }(i.localStore, e)) : L(), await Rc(i, r)) : M("SyncEngine", "Cannot apply mutation batch with id: " + e);
}
async function Dc(t, e) {
  const n = K(t);
  if (Mc(n), Fc(n), true === e && true !== n.ac) {
    const t2 = n.sharedClientState.getAllActiveQueryTargets(), e2 = await Cc(n, t2.toArray());
    n.ac = true, await Ou(n.remoteStore, true);
    for (const t3 of e2)
      fu(n.remoteStore, t3);
  } else if (false === e && false !== n.ac) {
    const t2 = [];
    let e2 = Promise.resolve();
    n.ec.forEach((s, i) => {
      n.sharedClientState.isLocalQueryTarget(i) ? t2.push(i) : e2 = e2.then(() => (pc(n, i), xo(n.localStore, i, true))), du(n.remoteStore, i);
    }), await e2, await Cc(n, t2), function(t3) {
      const e3 = K(t3);
      e3.ic.forEach((t4, n2) => {
        du(e3.remoteStore, n2);
      }), e3.rc.cs(), e3.ic = /* @__PURE__ */ new Map(), e3.sc = new qt(dt.comparator);
    }(n), n.ac = false, await Ou(n.remoteStore, false);
  }
}
async function Cc(t, e, n) {
  const s = K(t), i = [], r = [];
  for (const t2 of e) {
    let e2;
    const n2 = s.ec.get(t2);
    if (n2 && 0 !== n2.length) {
      e2 = await Co(s.localStore, ln(n2[0]));
      for (const t3 of n2) {
        const e3 = s.tc.get(t3), n3 = await vc(s, e3);
        n3.snapshot && r.push(n3.snapshot);
      }
    } else {
      const n3 = await ko(s.localStore, t2);
      e2 = await Co(s.localStore, n3), await cc(s, xc(n3), t2, false);
    }
    i.push(e2);
  }
  return s.Zu.Go(r), i;
}
function xc(t) {
  return sn(t.path, t.collectionGroup, t.orderBy, t.filters, t.limit, "F", t.startAt, t.endAt);
}
function Nc(t) {
  const e = K(t);
  return K(K(e.localStore).persistence).Ri();
}
async function kc(t, e, n, s) {
  const i = K(t);
  if (i.ac)
    return void M("SyncEngine", "Ignoring unexpected query state notification.");
  const r = i.ec.get(e);
  if (r && r.length > 0)
    switch (n) {
      case "current":
      case "not-current": {
        const t2 = await Oo(i.localStore, gn(r[0])), s2 = ys.createSynthesizedRemoteEventForCurrentChange(e, "current" === n);
        await Rc(i, t2, s2);
        break;
      }
      case "rejected":
        await xo(i.localStore, e, true), pc(i, e, s);
        break;
      default:
        L();
    }
}
async function Oc(t, e, n) {
  const s = Mc(t);
  if (s.ac) {
    for (const t2 of e) {
      if (s.ec.has(t2)) {
        M("SyncEngine", "Adding an already active target " + t2);
        continue;
      }
      const e2 = await ko(s.localStore, t2), n2 = await Co(s.localStore, e2);
      await cc(s, xc(e2), n2.targetId, false), fu(s.remoteStore, n2);
    }
    for (const t2 of n)
      s.ec.has(t2) && await xo(s.localStore, t2, false).then(() => {
        du(s.remoteStore, t2), pc(s, t2);
      }).catch(bt);
  }
}
function Mc(t) {
  const e = K(t);
  return e.remoteStore.remoteSyncer.applyRemoteEvent = lc.bind(null, e), e.remoteStore.remoteSyncer.getRemoteKeysForTarget = Pc.bind(null, e), e.remoteStore.remoteSyncer.rejectListen = dc.bind(null, e), e.Zu.Go = Wu.bind(null, e.eventManager), e.Zu.lc = zu.bind(null, e.eventManager), e;
}
function Fc(t) {
  const e = K(t);
  return e.remoteStore.remoteSyncer.applySuccessfulWrite = _c.bind(null, e), e.remoteStore.remoteSyncer.rejectFailedWrite = wc.bind(null, e), e;
}
function $c(t, e, n) {
  const s = K(t);
  (async function(t2, e2, n2) {
    try {
      const s2 = await e2.getMetadata();
      if (await function(t3, e3) {
        const n3 = K(t3), s3 = Ns(e3.createTime);
        return n3.persistence.runTransaction("hasNewerBundle", "readonly", (t4) => n3.Ds.getBundleMetadata(t4, e3.id)).then((t4) => !!t4 && t4.createTime.compareTo(s3) >= 0);
      }(t2.localStore, s2))
        return await e2.close(), n2._completeWith(function(t3) {
          return {
            taskState: "Success",
            documentsLoaded: t3.totalDocuments,
            bytesLoaded: t3.totalBytes,
            totalDocuments: t3.totalDocuments,
            totalBytes: t3.totalBytes
          };
        }(s2)), Promise.resolve(/* @__PURE__ */ new Set());
      n2._updateProgress(tc(s2));
      const i = new Zu(s2, t2.localStore, e2.wt);
      let r = await e2.fc();
      for (; r; ) {
        const t3 = await i.Nu(r);
        t3 && n2._updateProgress(t3), r = await e2.fc();
      }
      const o = await i.complete();
      return await Rc(t2, o.Mu, void 0), await function(t3, e3) {
        const n3 = K(t3);
        return n3.persistence.runTransaction("Save bundle", "readwrite", (t4) => n3.Ds.saveBundleMetadata(t4, e3));
      }(t2.localStore, s2), n2._completeWith(o.progress), Promise.resolve(o.Ou);
    } catch (t3) {
      return $("SyncEngine", `Loading bundle failed with ${t3}`), n2._failWith(t3), Promise.resolve(/* @__PURE__ */ new Set());
    }
  })(s, e, n).then((t2) => {
    s.sharedClientState.notifyBundleLoaded(t2);
  });
}
var Bc = class {
  constructor() {
    this.synchronizeTabs = false;
  }
  async initialize(t) {
    this.wt = nu(t.databaseInfo.databaseId), this.sharedClientState = this.dc(t), this.persistence = this._c(t), await this.persistence.start(), this.localStore = this.wc(t), this.gcScheduler = this.mc(t, this.localStore), this.indexBackfillerScheduler = this.gc(t, this.localStore);
  }
  mc(t, e) {
    return null;
  }
  gc(t, e) {
    return null;
  }
  wc(t) {
    return Ro(this.persistence, new Eo(), t.initialUser, this.wt);
  }
  _c(t) {
    return new ho(fo.Ms, this.wt);
  }
  dc(t) {
    return new zo();
  }
  async terminate() {
    this.gcScheduler && this.gcScheduler.stop(), await this.sharedClientState.shutdown(), await this.persistence.shutdown();
  }
};
var Lc = class extends Bc {
  constructor(t, e, n) {
    super(), this.yc = t, this.cacheSizeBytes = e, this.forceOwnership = n, this.synchronizeTabs = false;
  }
  async initialize(t) {
    await super.initialize(t), await this.yc.initialize(this, t), await Fc(this.yc.syncEngine), await bu(this.yc.remoteStore), await this.persistence.ci(() => (this.gcScheduler && !this.gcScheduler.started && this.gcScheduler.start(), this.indexBackfillerScheduler && !this.indexBackfillerScheduler.started && this.indexBackfillerScheduler.start(), Promise.resolve()));
  }
  wc(t) {
    return Ro(this.persistence, new Eo(), t.initialUser, this.wt);
  }
  mc(t, e) {
    const n = this.persistence.referenceDelegate.garbageCollector;
    return new Ur(n, t.asyncQueue, e);
  }
  gc(t, e) {
    const n = new Ft(e, this.persistence);
    return new Mt(t.asyncQueue, n);
  }
  _c(t) {
    const e = Io(t.databaseInfo.databaseId, t.databaseInfo.persistenceKey), n = void 0 !== this.cacheSizeBytes ? Pr.withCacheSize(this.cacheSizeBytes) : Pr.DEFAULT;
    return new go(this.synchronizeTabs, e, t.clientId, n, t.asyncQueue, tu(), eu(), this.wt, this.sharedClientState, !!this.forceOwnership);
  }
  dc(t) {
    return new zo();
  }
};
var Uc = class extends Lc {
  constructor(t, e) {
    super(t, e, false), this.yc = t, this.cacheSizeBytes = e, this.synchronizeTabs = true;
  }
  async initialize(t) {
    await super.initialize(t);
    const e = this.yc.syncEngine;
    this.sharedClientState instanceof Wo && (this.sharedClientState.syncEngine = {
      kr: Sc.bind(null, e),
      Or: kc.bind(null, e),
      Mr: Oc.bind(null, e),
      Ri: Nc.bind(null, e),
      Nr: Vc.bind(null, e)
    }, await this.sharedClientState.start()), await this.persistence.ci(async (t2) => {
      await Dc(this.yc.syncEngine, t2), this.gcScheduler && (t2 && !this.gcScheduler.started ? this.gcScheduler.start() : t2 || this.gcScheduler.stop()), this.indexBackfillerScheduler && (t2 && !this.indexBackfillerScheduler.started ? this.indexBackfillerScheduler.start() : t2 || this.indexBackfillerScheduler.stop());
    });
  }
  dc(t) {
    const e = tu();
    if (!Wo.V(e))
      throw new Q(G.UNIMPLEMENTED, "IndexedDB persistence is only available on platforms that support LocalStorage.");
    const n = Io(t.databaseInfo.databaseId, t.databaseInfo.persistenceKey);
    return new Wo(e, t.asyncQueue, n, t.clientId, t.initialUser);
  }
};
var qc = class {
  async initialize(t, e) {
    this.localStore || (this.localStore = t.localStore, this.sharedClientState = t.sharedClientState, this.datastore = this.createDatastore(e), this.remoteStore = this.createRemoteStore(e), this.eventManager = this.createEventManager(e), this.syncEngine = this.createSyncEngine(e, !t.synchronizeTabs), this.sharedClientState.onlineStateHandler = (t2) => fc(this.syncEngine, t2, 1), this.remoteStore.remoteSyncer.handleCredentialChange = bc.bind(null, this.syncEngine), await Ou(this.remoteStore, this.syncEngine.isPrimaryClient));
  }
  createEventManager(t) {
    return new Gu();
  }
  createDatastore(t) {
    const e = nu(t.databaseInfo.databaseId), n = (s = t.databaseInfo, new Zo(s));
    var s;
    return function(t2, e2, n2, s2) {
      return new uu(t2, e2, n2, s2);
    }(t.authCredentials, t.appCheckCredentials, n, e);
  }
  createRemoteStore(t) {
    return e = this.localStore, n = this.datastore, s = t.asyncQueue, i = (t2) => fc(this.syncEngine, t2, 0), r = Jo.V() ? new Jo() : new Ho(), new au(e, n, s, i, r);
    var e, n, s, i, r;
  }
  createSyncEngine(t, e) {
    return function(t2, e2, n, s, i, r, o) {
      const u = new oc(t2, e2, n, s, i, r);
      return o && (u.ac = true), u;
    }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, t.initialUser, t.maxConcurrentLimboResolutions, e);
  }
  terminate() {
    return async function(t) {
      const e = K(t);
      M("RemoteStore", "RemoteStore shutting down."), e.lu.add(5), await lu(e), e.du.shutdown(), e._u.set("Unknown");
    }(this.remoteStore);
  }
};
function Kc(t, e = 10240) {
  let n = 0;
  return {
    async read() {
      if (n < t.byteLength) {
        const s = {
          value: t.slice(n, n + e),
          done: false
        };
        return n += e, s;
      }
      return {
        done: true
      };
    },
    async cancel() {
    },
    releaseLock() {
    },
    closed: Promise.reject("unimplemented")
  };
}
var Gc = class {
  constructor(t) {
    this.observer = t, this.muted = false;
  }
  next(t) {
    this.observer.next && this.Ic(this.observer.next, t);
  }
  error(t) {
    this.observer.error ? this.Ic(this.observer.error, t) : console.error("Uncaught Error in snapshot listener:", t);
  }
  Tc() {
    this.muted = true;
  }
  Ic(t, e) {
    this.muted || setTimeout(() => {
      this.muted || t(e);
    }, 0);
  }
};
var Qc = class {
  constructor(t, e) {
    this.Ec = t, this.wt = e, this.metadata = new j(), this.buffer = new Uint8Array(), this.Ac = new TextDecoder("utf-8"), this.Rc().then((t2) => {
      t2 && t2.Cu() ? this.metadata.resolve(t2.payload.metadata) : this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is
             ${JSON.stringify(null == t2 ? void 0 : t2.payload)}`));
    }, (t2) => this.metadata.reject(t2));
  }
  close() {
    return this.Ec.cancel();
  }
  async getMetadata() {
    return this.metadata.promise;
  }
  async fc() {
    return await this.getMetadata(), this.Rc();
  }
  async Rc() {
    const t = await this.bc();
    if (null === t)
      return null;
    const e = this.Ac.decode(t), n = Number(e);
    isNaN(n) && this.Pc(`length string (${e}) is not valid number`);
    const s = await this.vc(n);
    return new Yu(JSON.parse(s), t.length + n);
  }
  Vc() {
    return this.buffer.findIndex((t) => t === "{".charCodeAt(0));
  }
  async bc() {
    for (; this.Vc() < 0; ) {
      if (await this.Sc())
        break;
    }
    if (0 === this.buffer.length)
      return null;
    const t = this.Vc();
    t < 0 && this.Pc("Reached the end of bundle when a length string is expected.");
    const e = this.buffer.slice(0, t);
    return this.buffer = this.buffer.slice(t), e;
  }
  async vc(t) {
    for (; this.buffer.length < t; ) {
      await this.Sc() && this.Pc("Reached the end of bundle when more is expected.");
    }
    const e = this.Ac.decode(this.buffer.slice(0, t));
    return this.buffer = this.buffer.slice(t), e;
  }
  Pc(t) {
    throw this.Ec.cancel(), new Error(`Invalid bundle format: ${t}`);
  }
  async Sc() {
    const t = await this.Ec.read();
    if (!t.done) {
      const e = new Uint8Array(this.buffer.length + t.value.length);
      e.set(this.buffer), e.set(t.value, this.buffer.length), this.buffer = e;
    }
    return t.done;
  }
};
var jc = class {
  constructor(t) {
    this.datastore = t, this.readVersions = /* @__PURE__ */ new Map(), this.mutations = [], this.committed = false, this.lastWriteError = null, this.writtenDocs = /* @__PURE__ */ new Set();
  }
  async lookup(t) {
    if (this.ensureCommitNotCalled(), this.mutations.length > 0)
      throw new Q(G.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes.");
    const e = await async function(t2, e2) {
      const n = K(t2), s = Ls(n.wt) + "/documents", i = {
        documents: e2.map((t3) => Ms(n.wt, t3))
      }, r = await n.ao("BatchGetDocuments", s, i, e2.length), o = /* @__PURE__ */ new Map();
      r.forEach((t3) => {
        const e3 = Gs(n.wt, t3);
        o.set(e3.key.toString(), e3);
      });
      const u = [];
      return e2.forEach((t3) => {
        const e3 = o.get(t3.toString());
        U(!!e3), u.push(e3);
      }), u;
    }(this.datastore, t);
    return e.forEach((t2) => this.recordVersion(t2)), e;
  }
  set(t, e) {
    this.write(e.toMutation(t, this.precondition(t))), this.writtenDocs.add(t.toString());
  }
  update(t, e) {
    try {
      this.write(e.toMutation(t, this.preconditionForUpdate(t)));
    } catch (t2) {
      this.lastWriteError = t2;
    }
    this.writtenDocs.add(t.toString());
  }
  delete(t) {
    this.write(new Yn(t, this.precondition(t))), this.writtenDocs.add(t.toString());
  }
  async commit() {
    if (this.ensureCommitNotCalled(), this.lastWriteError)
      throw this.lastWriteError;
    const t = this.readVersions;
    this.mutations.forEach((e) => {
      t.delete(e.key.toString());
    }), t.forEach((t2, e) => {
      const n = dt.fromPath(e);
      this.mutations.push(new Xn(n, this.precondition(n)));
    }), await async function(t2, e) {
      const n = K(t2), s = Ls(n.wt) + "/documents", i = {
        writes: e.map((t3) => js(n.wt, t3))
      };
      await n.ro("Commit", s, i);
    }(this.datastore, this.mutations), this.committed = true;
  }
  recordVersion(t) {
    let e;
    if (t.isFoundDocument())
      e = t.version;
    else {
      if (!t.isNoDocument())
        throw L();
      e = ct.min();
    }
    const n = this.readVersions.get(t.key.toString());
    if (n) {
      if (!e.isEqual(n))
        throw new Q(G.ABORTED, "Document version changed between two reads.");
    } else
      this.readVersions.set(t.key.toString(), e);
  }
  precondition(t) {
    const e = this.readVersions.get(t.toString());
    return !this.writtenDocs.has(t.toString()) && e ? $n.updateTime(e) : $n.none();
  }
  preconditionForUpdate(t) {
    const e = this.readVersions.get(t.toString());
    if (!this.writtenDocs.has(t.toString()) && e) {
      if (e.isEqual(ct.min()))
        throw new Q(G.INVALID_ARGUMENT, "Can't update a document that doesn't exist.");
      return $n.updateTime(e);
    }
    return $n.exists(true);
  }
  write(t) {
    this.ensureCommitNotCalled(), this.mutations.push(t);
  }
  ensureCommitNotCalled() {
  }
};
var Wc = class {
  constructor(t, e, n, s, i) {
    this.asyncQueue = t, this.datastore = e, this.options = n, this.updateFunction = s, this.deferred = i, this.Dc = n.maxAttempts, this.So = new su(this.asyncQueue, "transaction_retry");
  }
  run() {
    this.Dc -= 1, this.Cc();
  }
  Cc() {
    this.So.Io(async () => {
      const t = new jc(this.datastore), e = this.xc(t);
      e && e.then((e2) => {
        this.asyncQueue.enqueueAndForget(() => t.commit().then(() => {
          this.deferred.resolve(e2);
        }).catch((t2) => {
          this.Nc(t2);
        }));
      }).catch((t2) => {
        this.Nc(t2);
      });
    });
  }
  xc(t) {
    try {
      const e = this.updateFunction(t);
      return !oe(e) && e.catch && e.then ? e : (this.deferred.reject(Error("Transaction callback must return a Promise")), null);
    } catch (t2) {
      return this.deferred.reject(t2), null;
    }
  }
  Nc(t) {
    this.Dc > 0 && this.kc(t) ? (this.Dc -= 1, this.asyncQueue.enqueueAndForget(() => (this.Cc(), Promise.resolve()))) : this.deferred.reject(t);
  }
  kc(t) {
    if ("FirebaseError" === t.name) {
      const e = t.code;
      return "aborted" === e || "failed-precondition" === e || !ns(e);
    }
    return false;
  }
};
var zc = class {
  constructor(t, e, n, s) {
    this.authCredentials = t, this.appCheckCredentials = e, this.asyncQueue = n, this.databaseInfo = s, this.user = C.UNAUTHENTICATED, this.clientId = st.I(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this.authCredentials.start(n, async (t2) => {
      M("FirestoreClient", "Received user=", t2.uid), await this.authCredentialListener(t2), this.user = t2;
    }), this.appCheckCredentials.start(n, (t2) => (M("FirestoreClient", "Received new app check token=", t2), this.appCheckCredentialListener(t2, this.user)));
  }
  async getConfiguration() {
    return {
      asyncQueue: this.asyncQueue,
      databaseInfo: this.databaseInfo,
      clientId: this.clientId,
      authCredentials: this.authCredentials,
      appCheckCredentials: this.appCheckCredentials,
      initialUser: this.user,
      maxConcurrentLimboResolutions: 100
    };
  }
  setCredentialChangeListener(t) {
    this.authCredentialListener = t;
  }
  setAppCheckTokenChangeListener(t) {
    this.appCheckCredentialListener = t;
  }
  verifyNotTerminated() {
    if (this.asyncQueue.isShuttingDown)
      throw new Q(G.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  terminate() {
    this.asyncQueue.enterRestrictedMode();
    const t = new j();
    return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
      try {
        this.onlineComponents && await this.onlineComponents.terminate(), this.offlineComponents && await this.offlineComponents.terminate(), this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), t.resolve();
      } catch (e) {
        const n = Bu(e, "Failed to shutdown persistence");
        t.reject(n);
      }
    }), t.promise;
  }
};
async function Hc(t, e) {
  t.asyncQueue.verifyOperationInProgress(), M("FirestoreClient", "Initializing OfflineComponentProvider");
  const n = await t.getConfiguration();
  await e.initialize(n);
  let s = n.initialUser;
  t.setCredentialChangeListener(async (t2) => {
    s.isEqual(t2) || (await bo(e.localStore, t2), s = t2);
  }), e.persistence.setDatabaseDeletedListener(() => t.terminate()), t.offlineComponents = e;
}
async function Jc(t, e) {
  t.asyncQueue.verifyOperationInProgress();
  const n = await Yc(t);
  M("FirestoreClient", "Initializing OnlineComponentProvider");
  const s = await t.getConfiguration();
  await e.initialize(n, s), t.setCredentialChangeListener((t2) => ku(e.remoteStore, t2)), t.setAppCheckTokenChangeListener((t2, n2) => ku(e.remoteStore, n2)), t.onlineComponents = e;
}
async function Yc(t) {
  return t.offlineComponents || (M("FirestoreClient", "Using default OfflineComponentProvider"), await Hc(t, new Bc())), t.offlineComponents;
}
async function Xc(t) {
  return t.onlineComponents || (M("FirestoreClient", "Using default OnlineComponentProvider"), await Jc(t, new qc())), t.onlineComponents;
}
function Zc(t) {
  return Yc(t).then((t2) => t2.persistence);
}
function ta(t) {
  return Yc(t).then((t2) => t2.localStore);
}
function ea(t) {
  return Xc(t).then((t2) => t2.remoteStore);
}
function na(t) {
  return Xc(t).then((t2) => t2.syncEngine);
}
async function sa(t) {
  const e = await Xc(t), n = e.eventManager;
  return n.onListen = uc.bind(null, e.syncEngine), n.onUnlisten = ac.bind(null, e.syncEngine), n;
}
function ia(t) {
  return t.asyncQueue.enqueue(async () => {
    const e = await Zc(t), n = await ea(t);
    return e.setNetworkEnabled(true), function(t2) {
      const e2 = K(t2);
      return e2.lu.delete(0), hu(e2);
    }(n);
  });
}
function ra(t) {
  return t.asyncQueue.enqueue(async () => {
    const e = await Zc(t), n = await ea(t);
    return e.setNetworkEnabled(false), async function(t2) {
      const e2 = K(t2);
      e2.lu.add(0), await lu(e2), e2._u.set("Offline");
    }(n);
  });
}
function oa(t, e) {
  const n = new j();
  return t.asyncQueue.enqueueAndForget(async () => async function(t2, e2, n2) {
    try {
      const s = await function(t3, e3) {
        const n3 = K(t3);
        return n3.persistence.runTransaction("read document", "readonly", (t4) => n3.localDocuments.getDocument(t4, e3));
      }(t2, e2);
      s.isFoundDocument() ? n2.resolve(s) : s.isNoDocument() ? n2.resolve(null) : n2.reject(new Q(G.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)"));
    } catch (t3) {
      const s = Bu(t3, `Failed to get document '${e2} from cache`);
      n2.reject(s);
    }
  }(await ta(t), e, n)), n.promise;
}
function ua(t, e, n = {}) {
  const s = new j();
  return t.asyncQueue.enqueueAndForget(async () => function(t2, e2, n2, s2, i) {
    const r = new Gc({
      next: (r2) => {
        e2.enqueueAndForget(() => ju(t2, o));
        const u = r2.docs.has(n2);
        !u && r2.fromCache ? i.reject(new Q(G.UNAVAILABLE, "Failed to get document because the client is offline.")) : u && r2.fromCache && s2 && "server" === s2.source ? i.reject(new Q(G.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : i.resolve(r2);
      },
      error: (t3) => i.reject(t3)
    }), o = new Ju(rn(n2.path), r, {
      includeMetadataChanges: true,
      Du: true
    });
    return Qu(t2, o);
  }(await sa(t), t.asyncQueue, e, n, s)), s.promise;
}
function ca(t, e) {
  const n = new j();
  return t.asyncQueue.enqueueAndForget(async () => async function(t2, e2, n2) {
    try {
      const s = await No(t2, e2, true), i = new sc(e2, s.ji), r = i.Ku(s.documents), o = i.applyChanges(r, false);
      n2.resolve(o.snapshot);
    } catch (t3) {
      const s = Bu(t3, `Failed to execute query '${e2} against cache`);
      n2.reject(s);
    }
  }(await ta(t), e, n)), n.promise;
}
function aa(t, e, n = {}) {
  const s = new j();
  return t.asyncQueue.enqueueAndForget(async () => function(t2, e2, n2, s2, i) {
    const r = new Gc({
      next: (n3) => {
        e2.enqueueAndForget(() => ju(t2, o)), n3.fromCache && "server" === s2.source ? i.reject(new Q(G.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : i.resolve(n3);
      },
      error: (t3) => i.reject(t3)
    }), o = new Ju(n2, r, {
      includeMetadataChanges: true,
      Du: true
    });
    return Qu(t2, o);
  }(await sa(t), t.asyncQueue, e, n, s)), s.promise;
}
function ha(t, e) {
  const n = new Gc(e);
  return t.asyncQueue.enqueueAndForget(async () => function(t2, e2) {
    K(t2).Tu.add(e2), e2.next();
  }(await sa(t), n)), () => {
    n.Tc(), t.asyncQueue.enqueueAndForget(async () => function(t2, e2) {
      K(t2).Tu.delete(e2);
    }(await sa(t), n));
  };
}
function la(t, e, n) {
  const s = new j();
  return t.asyncQueue.enqueueAndForget(async () => {
    const i = await function(t2) {
      return Xc(t2).then((t3) => t3.datastore);
    }(t);
    new Wc(t.asyncQueue, i, n, e, s).run();
  }), s.promise;
}
function fa(t, e, n, s) {
  const i = function(t2, e2) {
    let n2;
    n2 = "string" == typeof t2 ? new TextEncoder().encode(t2) : t2;
    return function(t3, e3) {
      return new Qc(t3, e3);
    }(function(t3, e3) {
      if (t3 instanceof Uint8Array)
        return Kc(t3, e3);
      if (t3 instanceof ArrayBuffer)
        return Kc(new Uint8Array(t3), e3);
      if (t3 instanceof ReadableStream)
        return t3.getReader();
      throw new Error("Source of `toByteStreamReader` has to be a ArrayBuffer or ReadableStream");
    }(n2), e2);
  }(n, nu(e));
  t.asyncQueue.enqueueAndForget(async () => {
    $c(await na(t), i, s);
  });
}
function da(t, e) {
  return t.asyncQueue.enqueue(async () => function(t2, e2) {
    const n = K(t2);
    return n.persistence.runTransaction("Get named query", "readonly", (t3) => n.Ds.getNamedQuery(t3, e2));
  }(await ta(t), e));
}
var _a = /* @__PURE__ */ new Map();
function wa(t, e, n) {
  if (!n)
    throw new Q(G.INVALID_ARGUMENT, `Function ${t}() cannot be called with an empty ${e}.`);
}
function ma(t, e, n, s) {
  if (true === e && true === s)
    throw new Q(G.INVALID_ARGUMENT, `${t} and ${n} cannot be used together.`);
}
function ga(t) {
  if (!dt.isDocumentKey(t))
    throw new Q(G.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${t} has ${t.length}.`);
}
function ya(t) {
  if (dt.isDocumentKey(t))
    throw new Q(G.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${t} has ${t.length}.`);
}
function pa(t) {
  if (void 0 === t)
    return "undefined";
  if (null === t)
    return "null";
  if ("string" == typeof t)
    return t.length > 20 && (t = `${t.substring(0, 20)}...`), JSON.stringify(t);
  if ("number" == typeof t || "boolean" == typeof t)
    return "" + t;
  if ("object" == typeof t) {
    if (t instanceof Array)
      return "an array";
    {
      const e = function(t2) {
        if (t2.constructor)
          return t2.constructor.name;
        return null;
      }(t);
      return e ? `a custom ${e} object` : "an object";
    }
  }
  return "function" == typeof t ? "a function" : L();
}
function Ia(t, e) {
  if ("_delegate" in t && (t = t._delegate), !(t instanceof e)) {
    if (e.name === t.constructor.name)
      throw new Q(G.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const n = pa(t);
      throw new Q(G.INVALID_ARGUMENT, `Expected type '${e.name}', but it was: ${n}`);
    }
  }
  return t;
}
function Ta(t, e) {
  if (e <= 0)
    throw new Q(G.INVALID_ARGUMENT, `Function ${t}() requires a positive number, but it was: ${e}.`);
}
var Ea = class {
  constructor(t) {
    var e;
    if (void 0 === t.host) {
      if (void 0 !== t.ssl)
        throw new Q(G.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
      this.host = "firestore.googleapis.com", this.ssl = true;
    } else
      this.host = t.host, this.ssl = null === (e = t.ssl) || void 0 === e || e;
    if (this.credentials = t.credentials, this.ignoreUndefinedProperties = !!t.ignoreUndefinedProperties, void 0 === t.cacheSizeBytes)
      this.cacheSizeBytes = 41943040;
    else {
      if (-1 !== t.cacheSizeBytes && t.cacheSizeBytes < 1048576)
        throw new Q(G.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = t.cacheSizeBytes;
    }
    this.experimentalForceLongPolling = !!t.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!t.experimentalAutoDetectLongPolling, this.useFetchStreams = !!t.useFetchStreams, ma("experimentalForceLongPolling", t.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t.experimentalAutoDetectLongPolling);
  }
  isEqual(t) {
    return this.host === t.host && this.ssl === t.ssl && this.credentials === t.credentials && this.cacheSizeBytes === t.cacheSizeBytes && this.experimentalForceLongPolling === t.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === t.ignoreUndefinedProperties && this.useFetchStreams === t.useFetchStreams;
  }
};
var Aa = class {
  constructor(t, e, n) {
    this._authCredentials = e, this._appCheckCredentials = n, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new Ea({}), this._settingsFrozen = false, t instanceof re ? this._databaseId = t : (this._app = t, this._databaseId = function(t2) {
      if (!Object.prototype.hasOwnProperty.apply(t2.options, ["projectId"]))
        throw new Q(G.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
      return new re(t2.options.projectId);
    }(t));
  }
  get app() {
    if (!this._app)
      throw new Q(G.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return void 0 !== this._terminateTask;
  }
  _setSettings(t) {
    if (this._settingsFrozen)
      throw new Q(G.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new Ea(t), void 0 !== t.credentials && (this._authCredentials = function(t2) {
      if (!t2)
        return new z();
      switch (t2.type) {
        case "gapi":
          const e = t2.client;
          return U(!("object" != typeof e || null === e || !e.auth || !e.auth.getAuthHeaderValueForFirstParty)), new X(e, t2.sessionIndex || "0", t2.iamToken || null);
        case "provider":
          return t2.client;
        default:
          throw new Q(G.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type");
      }
    }(t.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return this._settingsFrozen = true, this._settings;
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
  }
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  _terminate() {
    return function(t) {
      const e = _a.get(t);
      e && (M("ComponentProvider", "Removing Datastore"), _a.delete(t), e.terminate());
    }(this), Promise.resolve();
  }
};
function Ra(t, e, n, s = {}) {
  var i;
  const r = (t = Ia(t, Aa))._getSettings();
  if ("firestore.googleapis.com" !== r.host && r.host !== e && $("Host has been set in both settings() and useEmulator(), emulator host will be used"), t._setSettings(Object.assign(Object.assign({}, r), {
    host: `${e}:${n}`,
    ssl: false
  })), s.mockUserToken) {
    let e2, n2;
    if ("string" == typeof s.mockUserToken)
      e2 = s.mockUserToken, n2 = C.MOCK_USER;
    else {
      e2 = createMockUserToken(s.mockUserToken, null === (i = t._app) || void 0 === i ? void 0 : i.options.projectId);
      const r2 = s.mockUserToken.sub || s.mockUserToken.user_id;
      if (!r2)
        throw new Q(G.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
      n2 = new C(r2);
    }
    t._authCredentials = new H(new W(e2, n2));
  }
}
var ba = class {
  constructor(t, e, n) {
    this.converter = e, this._key = n, this.type = "document", this.firestore = t;
  }
  get _path() {
    return this._key.path;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get path() {
    return this._key.path.canonicalString();
  }
  get parent() {
    return new va(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(t) {
    return new ba(this.firestore, t, this._key);
  }
};
var Pa = class {
  constructor(t, e, n) {
    this.converter = e, this._query = n, this.type = "query", this.firestore = t;
  }
  withConverter(t) {
    return new Pa(this.firestore, t, this._query);
  }
};
var va = class extends Pa {
  constructor(t, e, n) {
    super(t, e, rn(n)), this._path = n, this.type = "collection";
  }
  get id() {
    return this._query.path.lastSegment();
  }
  get path() {
    return this._query.path.canonicalString();
  }
  get parent() {
    const t = this._path.popLast();
    return t.isEmpty() ? null : new ba(this.firestore, null, new dt(t));
  }
  withConverter(t) {
    return new va(this.firestore, t, this._path);
  }
};
function Va(t, e, ...n) {
  if (t = getModularInstance(t), wa("collection", "path", e), t instanceof Aa) {
    const s = ht.fromString(e, ...n);
    return ya(s), new va(t, null, s);
  }
  {
    if (!(t instanceof ba || t instanceof va))
      throw new Q(G.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t._path.child(ht.fromString(e, ...n));
    return ya(s), new va(t.firestore, null, s);
  }
}
function Sa(t, e) {
  if (t = Ia(t, Aa), wa("collectionGroup", "collection id", e), e.indexOf("/") >= 0)
    throw new Q(G.INVALID_ARGUMENT, `Invalid collection ID '${e}' passed to function collectionGroup(). Collection IDs must not contain '/'.`);
  return new Pa(t, null, function(t2) {
    return new nn(ht.emptyPath(), t2);
  }(e));
}
function Da(t, e, ...n) {
  if (t = getModularInstance(t), 1 === arguments.length && (e = st.I()), wa("doc", "path", e), t instanceof Aa) {
    const s = ht.fromString(e, ...n);
    return ga(s), new ba(t, null, new dt(s));
  }
  {
    if (!(t instanceof ba || t instanceof va))
      throw new Q(G.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t._path.child(ht.fromString(e, ...n));
    return ga(s), new ba(t.firestore, t instanceof va ? t.converter : null, new dt(s));
  }
}
function Ca(t, e) {
  return t = getModularInstance(t), e = getModularInstance(e), (t instanceof ba || t instanceof va) && (e instanceof ba || e instanceof va) && (t.firestore === e.firestore && t.path === e.path && t.converter === e.converter);
}
function xa(t, e) {
  return t = getModularInstance(t), e = getModularInstance(e), t instanceof Pa && e instanceof Pa && (t.firestore === e.firestore && dn(t._query, e._query) && t.converter === e.converter);
}
var Na = class {
  constructor() {
    this.Oc = Promise.resolve(), this.Mc = [], this.Fc = false, this.$c = [], this.Bc = null, this.Lc = false, this.Uc = false, this.qc = [], this.So = new su(this, "async_queue_retry"), this.Kc = () => {
      const t2 = eu();
      t2 && M("AsyncQueue", "Visibility state changed to " + t2.visibilityState), this.So.Eo();
    };
    const t = eu();
    t && "function" == typeof t.addEventListener && t.addEventListener("visibilitychange", this.Kc);
  }
  get isShuttingDown() {
    return this.Fc;
  }
  enqueueAndForget(t) {
    this.enqueue(t);
  }
  enqueueAndForgetEvenWhileRestricted(t) {
    this.Gc(), this.Qc(t);
  }
  enterRestrictedMode(t) {
    if (!this.Fc) {
      this.Fc = true, this.Uc = t || false;
      const e = eu();
      e && "function" == typeof e.removeEventListener && e.removeEventListener("visibilitychange", this.Kc);
    }
  }
  enqueue(t) {
    if (this.Gc(), this.Fc)
      return new Promise(() => {
      });
    const e = new j();
    return this.Qc(() => this.Fc && this.Uc ? Promise.resolve() : (t().then(e.resolve, e.reject), e.promise)).then(() => e.promise);
  }
  enqueueRetryable(t) {
    this.enqueueAndForget(() => (this.Mc.push(t), this.jc()));
  }
  async jc() {
    if (0 !== this.Mc.length) {
      try {
        await this.Mc[0](), this.Mc.shift(), this.So.reset();
      } catch (t) {
        if (!Ct(t))
          throw t;
        M("AsyncQueue", "Operation failed with retryable error: " + t);
      }
      this.Mc.length > 0 && this.So.Io(() => this.jc());
    }
  }
  Qc(t) {
    const e = this.Oc.then(() => (this.Lc = true, t().catch((t2) => {
      this.Bc = t2, this.Lc = false;
      const e2 = function(t3) {
        let e3 = t3.message || "";
        t3.stack && (e3 = t3.stack.includes(t3.message) ? t3.stack : t3.message + "\n" + t3.stack);
        return e3;
      }(t2);
      throw F("INTERNAL UNHANDLED ERROR: ", e2), t2;
    }).then((t2) => (this.Lc = false, t2))));
    return this.Oc = e, e;
  }
  enqueueAfterDelay(t, e, n) {
    this.Gc(), this.qc.indexOf(t) > -1 && (e = 0);
    const s = $u.createAndSchedule(this, t, e, n, (t2) => this.Wc(t2));
    return this.$c.push(s), s;
  }
  Gc() {
    this.Bc && L();
  }
  verifyOperationInProgress() {
  }
  async zc() {
    let t;
    do {
      t = this.Oc, await t;
    } while (t !== this.Oc);
  }
  Hc(t) {
    for (const e of this.$c)
      if (e.timerId === t)
        return true;
    return false;
  }
  Jc(t) {
    return this.zc().then(() => {
      this.$c.sort((t2, e) => t2.targetTimeMs - e.targetTimeMs);
      for (const e of this.$c)
        if (e.skipDelay(), "all" !== t && e.timerId === t)
          break;
      return this.zc();
    });
  }
  Yc(t) {
    this.qc.push(t);
  }
  Wc(t) {
    const e = this.$c.indexOf(t);
    this.$c.splice(e, 1);
  }
};
function ka(t) {
  return function(t2, e) {
    if ("object" != typeof t2 || null === t2)
      return false;
    const n = t2;
    for (const t3 of e)
      if (t3 in n && "function" == typeof n[t3])
        return true;
    return false;
  }(t, ["next", "error", "complete"]);
}
var Oa = class {
  constructor() {
    this._progressObserver = {}, this._taskCompletionResolver = new j(), this._lastProgress = {
      taskState: "Running",
      totalBytes: 0,
      totalDocuments: 0,
      bytesLoaded: 0,
      documentsLoaded: 0
    };
  }
  onProgress(t, e, n) {
    this._progressObserver = {
      next: t,
      error: e,
      complete: n
    };
  }
  catch(t) {
    return this._taskCompletionResolver.promise.catch(t);
  }
  then(t, e) {
    return this._taskCompletionResolver.promise.then(t, e);
  }
  _completeWith(t) {
    this._updateProgress(t), this._progressObserver.complete && this._progressObserver.complete(), this._taskCompletionResolver.resolve(t);
  }
  _failWith(t) {
    this._lastProgress.taskState = "Error", this._progressObserver.next && this._progressObserver.next(this._lastProgress), this._progressObserver.error && this._progressObserver.error(t), this._taskCompletionResolver.reject(t);
  }
  _updateProgress(t) {
    this._lastProgress = t, this._progressObserver.next && this._progressObserver.next(t);
  }
};
var Ma = -1;
var Fa = class extends Aa {
  constructor(t, e, n) {
    super(t, e, n), this.type = "firestore", this._queue = new Na(), this._persistenceKey = "name" in t ? t.name : "[DEFAULT]";
  }
  _terminate() {
    return this._firestoreClient || Ua(this), this._firestoreClient.terminate();
  }
};
function $a(t, e) {
  const n = _getProvider(t, "firestore");
  if (n.isInitialized()) {
    const t2 = n.getImmediate(), s = n.getOptions();
    if (deepEqual(s, e))
      return t2;
    throw new Q(G.FAILED_PRECONDITION, "initializeFirestore() has already been called with different options. To avoid this error, call initializeFirestore() with the same options as when it was originally called, or call getFirestore() to return the already initialized instance.");
  }
  if (void 0 !== e.cacheSizeBytes && -1 !== e.cacheSizeBytes && e.cacheSizeBytes < 1048576)
    throw new Q(G.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
  return n.initialize({
    options: e
  });
}
function Ba(e = getApp()) {
  return _getProvider(e, "firestore").getImmediate();
}
function La(t) {
  return t._firestoreClient || Ua(t), t._firestoreClient.verifyNotTerminated(), t._firestoreClient;
}
function Ua(t) {
  var e;
  const n = t._freezeSettings(), s = function(t2, e2, n2, s2) {
    return new ie(t2, e2, n2, s2.host, s2.ssl, s2.experimentalForceLongPolling, s2.experimentalAutoDetectLongPolling, s2.useFetchStreams);
  }(t._databaseId, (null === (e = t._app) || void 0 === e ? void 0 : e.options.appId) || "", t._persistenceKey, n);
  t._firestoreClient = new zc(t._authCredentials, t._appCheckCredentials, t._queue, s);
}
function qa(t, e) {
  Xa(t = Ia(t, Fa));
  const n = La(t), s = t._freezeSettings(), i = new qc();
  return Ga(n, i, new Lc(i, s.cacheSizeBytes, null == e ? void 0 : e.forceOwnership));
}
function Ka(t) {
  Xa(t = Ia(t, Fa));
  const e = La(t), n = t._freezeSettings(), s = new qc();
  return Ga(e, s, new Uc(s, n.cacheSizeBytes));
}
function Ga(t, e, n) {
  const s = new j();
  return t.asyncQueue.enqueue(async () => {
    try {
      await Hc(t, n), await Jc(t, e), s.resolve();
    } catch (t2) {
      const e2 = t2;
      if (!function(t3) {
        if ("FirebaseError" === t3.name)
          return t3.code === G.FAILED_PRECONDITION || t3.code === G.UNIMPLEMENTED;
        if ("undefined" != typeof DOMException && t3 instanceof DOMException)
          return 22 === t3.code || 20 === t3.code || 11 === t3.code;
        return true;
      }(e2))
        throw e2;
      console.warn("Error enabling offline persistence. Falling back to persistence disabled: " + e2), s.reject(e2);
    }
  }).then(() => s.promise);
}
function Qa(t) {
  if (t._initialized && !t._terminated)
    throw new Q(G.FAILED_PRECONDITION, "Persistence can only be cleared before a Firestore instance is initialized or after it is terminated.");
  const e = new j();
  return t._queue.enqueueAndForgetEvenWhileRestricted(async () => {
    try {
      await async function(t2) {
        if (!Vt.V())
          return Promise.resolve();
        const e2 = t2 + "main";
        await Vt.delete(e2);
      }(Io(t._databaseId, t._persistenceKey)), e.resolve();
    } catch (t2) {
      e.reject(t2);
    }
  }), e.promise;
}
function ja(t) {
  return function(t2) {
    const e = new j();
    return t2.asyncQueue.enqueueAndForget(async () => mc(await na(t2), e)), e.promise;
  }(La(t = Ia(t, Fa)));
}
function Wa(t) {
  return ia(La(t = Ia(t, Fa)));
}
function za(t) {
  return ra(La(t = Ia(t, Fa)));
}
function Ha(t) {
  return _removeServiceInstance(t.app, "firestore"), t._delete();
}
function Ja(t, e) {
  const n = La(t = Ia(t, Fa)), s = new Oa();
  return fa(n, t._databaseId, e, s), s;
}
function Ya(t, e) {
  return da(La(t = Ia(t, Fa)), e).then((e2) => e2 ? new Pa(t, null, e2.query) : null);
}
function Xa(t) {
  if (t._initialized || t._terminated)
    throw new Q(G.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.");
}
var Za = class {
  constructor(...t) {
    for (let e = 0; e < t.length; ++e)
      if (0 === t[e].length)
        throw new Q(G.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
    this._internalPath = new ft(t);
  }
  isEqual(t) {
    return this._internalPath.isEqual(t._internalPath);
  }
};
function th() {
  return new Za("__name__");
}
var eh = class {
  constructor(t) {
    this._byteString = t;
  }
  static fromBase64String(t) {
    try {
      return new eh(Jt.fromBase64String(t));
    } catch (t2) {
      throw new Q(G.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + t2);
    }
  }
  static fromUint8Array(t) {
    return new eh(Jt.fromUint8Array(t));
  }
  toBase64() {
    return this._byteString.toBase64();
  }
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  isEqual(t) {
    return this._byteString.isEqual(t._byteString);
  }
};
var nh = class {
  constructor(t) {
    this._methodName = t;
  }
};
var sh = class {
  constructor(t, e) {
    if (!isFinite(t) || t < -90 || t > 90)
      throw new Q(G.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + t);
    if (!isFinite(e) || e < -180 || e > 180)
      throw new Q(G.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + e);
    this._lat = t, this._long = e;
  }
  get latitude() {
    return this._lat;
  }
  get longitude() {
    return this._long;
  }
  isEqual(t) {
    return this._lat === t._lat && this._long === t._long;
  }
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long
    };
  }
  _compareTo(t) {
    return it(this._lat, t._lat) || it(this._long, t._long);
  }
};
var ih = /^__.*__$/;
var rh = class {
  constructor(t, e, n) {
    this.data = t, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t, e) {
    return null !== this.fieldMask ? new Wn(t, this.data, this.fieldMask, e, this.fieldTransforms) : new jn(t, this.data, e, this.fieldTransforms);
  }
};
var oh = class {
  constructor(t, e, n) {
    this.data = t, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t, e) {
    return new Wn(t, this.data, this.fieldMask, e, this.fieldTransforms);
  }
};
function uh(t) {
  switch (t) {
    case 0:
    case 2:
    case 1:
      return true;
    case 3:
    case 4:
      return false;
    default:
      throw L();
  }
}
var ch = class {
  constructor(t, e, n, s, i, r) {
    this.settings = t, this.databaseId = e, this.wt = n, this.ignoreUndefinedProperties = s, void 0 === i && this.Xc(), this.fieldTransforms = i || [], this.fieldMask = r || [];
  }
  get path() {
    return this.settings.path;
  }
  get Zc() {
    return this.settings.Zc;
  }
  ta(t) {
    return new ch(Object.assign(Object.assign({}, this.settings), t), this.databaseId, this.wt, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  ea(t) {
    var e;
    const n = null === (e = this.path) || void 0 === e ? void 0 : e.child(t), s = this.ta({
      path: n,
      na: false
    });
    return s.sa(t), s;
  }
  ia(t) {
    var e;
    const n = null === (e = this.path) || void 0 === e ? void 0 : e.child(t), s = this.ta({
      path: n,
      na: false
    });
    return s.Xc(), s;
  }
  ra(t) {
    return this.ta({
      path: void 0,
      na: true
    });
  }
  oa(t) {
    return Vh(t, this.settings.methodName, this.settings.ua || false, this.path, this.settings.ca);
  }
  contains(t) {
    return void 0 !== this.fieldMask.find((e) => t.isPrefixOf(e)) || void 0 !== this.fieldTransforms.find((e) => t.isPrefixOf(e.field));
  }
  Xc() {
    if (this.path)
      for (let t = 0; t < this.path.length; t++)
        this.sa(this.path.get(t));
  }
  sa(t) {
    if (0 === t.length)
      throw this.oa("Document fields must not be empty");
    if (uh(this.Zc) && ih.test(t))
      throw this.oa('Document fields cannot begin and end with "__"');
  }
};
var ah = class {
  constructor(t, e, n) {
    this.databaseId = t, this.ignoreUndefinedProperties = e, this.wt = n || nu(t);
  }
  aa(t, e, n, s = false) {
    return new ch({
      Zc: t,
      methodName: e,
      ca: n,
      path: ft.emptyPath(),
      na: false,
      ua: s
    }, this.databaseId, this.wt, this.ignoreUndefinedProperties);
  }
};
function hh(t) {
  const e = t._freezeSettings(), n = nu(t._databaseId);
  return new ah(t._databaseId, !!e.ignoreUndefinedProperties, n);
}
function lh(t, e, n, s, i, r = {}) {
  const o = t.aa(r.merge || r.mergeFields ? 2 : 0, e, n, i);
  Rh("Data must be an object, but it was:", o, s);
  const u = Eh(s, o);
  let c, a;
  if (r.merge)
    c = new zt(o.fieldMask), a = o.fieldTransforms;
  else if (r.mergeFields) {
    const t2 = [];
    for (const s2 of r.mergeFields) {
      const i2 = bh(e, s2, n);
      if (!o.contains(i2))
        throw new Q(G.INVALID_ARGUMENT, `Field '${i2}' is specified in your field mask but missing from your input data.`);
      Sh(t2, i2) || t2.push(i2);
    }
    c = new zt(t2), a = o.fieldTransforms.filter((t3) => c.covers(t3.field));
  } else
    c = null, a = o.fieldTransforms;
  return new rh(new De(u), c, a);
}
var fh = class extends nh {
  _toFieldTransform(t) {
    if (2 !== t.Zc)
      throw 1 === t.Zc ? t.oa(`${this._methodName}() can only appear at the top level of your update data`) : t.oa(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
    return t.fieldMask.push(t.path), null;
  }
  isEqual(t) {
    return t instanceof fh;
  }
};
function dh(t, e, n) {
  return new ch({
    Zc: 3,
    ca: e.settings.ca,
    methodName: t._methodName,
    na: n
  }, e.databaseId, e.wt, e.ignoreUndefinedProperties);
}
var _h = class extends nh {
  _toFieldTransform(t) {
    return new On(t.path, new vn());
  }
  isEqual(t) {
    return t instanceof _h;
  }
};
var wh = class extends nh {
  constructor(t, e) {
    super(t), this.ha = e;
  }
  _toFieldTransform(t) {
    const e = dh(this, t, true), n = this.ha.map((t2) => Th(t2, e)), s = new Vn(n);
    return new On(t.path, s);
  }
  isEqual(t) {
    return this === t;
  }
};
var mh = class extends nh {
  constructor(t, e) {
    super(t), this.ha = e;
  }
  _toFieldTransform(t) {
    const e = dh(this, t, true), n = this.ha.map((t2) => Th(t2, e)), s = new Dn(n);
    return new On(t.path, s);
  }
  isEqual(t) {
    return this === t;
  }
};
var gh = class extends nh {
  constructor(t, e) {
    super(t), this.la = e;
  }
  _toFieldTransform(t) {
    const e = new xn(t.wt, En(t.wt, this.la));
    return new On(t.path, e);
  }
  isEqual(t) {
    return this === t;
  }
};
function yh(t, e, n, s) {
  const i = t.aa(1, e, n);
  Rh("Data must be an object, but it was:", i, s);
  const r = [], o = De.empty();
  Lt(s, (t2, s2) => {
    const u2 = vh(e, t2, n);
    s2 = getModularInstance(s2);
    const c = i.ia(u2);
    if (s2 instanceof fh)
      r.push(u2);
    else {
      const t3 = Th(s2, c);
      null != t3 && (r.push(u2), o.set(u2, t3));
    }
  });
  const u = new zt(r);
  return new oh(o, u, i.fieldTransforms);
}
function ph(t, e, n, s, i, r) {
  const o = t.aa(1, e, n), u = [bh(e, s, n)], c = [i];
  if (r.length % 2 != 0)
    throw new Q(G.INVALID_ARGUMENT, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`);
  for (let t2 = 0; t2 < r.length; t2 += 2)
    u.push(bh(e, r[t2])), c.push(r[t2 + 1]);
  const a = [], h = De.empty();
  for (let t2 = u.length - 1; t2 >= 0; --t2)
    if (!Sh(a, u[t2])) {
      const e2 = u[t2];
      let n2 = c[t2];
      n2 = getModularInstance(n2);
      const s2 = o.ia(e2);
      if (n2 instanceof fh)
        a.push(e2);
      else {
        const t3 = Th(n2, s2);
        null != t3 && (a.push(e2), h.set(e2, t3));
      }
    }
  const l = new zt(a);
  return new oh(h, l, o.fieldTransforms);
}
function Ih(t, e, n, s = false) {
  return Th(n, t.aa(s ? 4 : 3, e));
}
function Th(t, e) {
  if (Ah(t = getModularInstance(t)))
    return Rh("Unsupported field value:", e, t), Eh(t, e);
  if (t instanceof nh)
    return function(t2, e2) {
      if (!uh(e2.Zc))
        throw e2.oa(`${t2._methodName}() can only be used with update() and set()`);
      if (!e2.path)
        throw e2.oa(`${t2._methodName}() is not currently supported inside arrays`);
      const n = t2._toFieldTransform(e2);
      n && e2.fieldTransforms.push(n);
    }(t, e), null;
  if (void 0 === t && e.ignoreUndefinedProperties)
    return null;
  if (e.path && e.fieldMask.push(e.path), t instanceof Array) {
    if (e.settings.na && 4 !== e.Zc)
      throw e.oa("Nested arrays are not supported");
    return function(t2, e2) {
      const n = [];
      let s = 0;
      for (const i of t2) {
        let t3 = Th(i, e2.ra(s));
        null == t3 && (t3 = {
          nullValue: "NULL_VALUE"
        }), n.push(t3), s++;
      }
      return {
        arrayValue: {
          values: n
        }
      };
    }(t, e);
  }
  return function(t2, e2) {
    if (null === (t2 = getModularInstance(t2)))
      return {
        nullValue: "NULL_VALUE"
      };
    if ("number" == typeof t2)
      return En(e2.wt, t2);
    if ("boolean" == typeof t2)
      return {
        booleanValue: t2
      };
    if ("string" == typeof t2)
      return {
        stringValue: t2
      };
    if (t2 instanceof Date) {
      const n = ut.fromDate(t2);
      return {
        timestampValue: Ds(e2.wt, n)
      };
    }
    if (t2 instanceof ut) {
      const n = new ut(t2.seconds, 1e3 * Math.floor(t2.nanoseconds / 1e3));
      return {
        timestampValue: Ds(e2.wt, n)
      };
    }
    if (t2 instanceof sh)
      return {
        geoPointValue: {
          latitude: t2.latitude,
          longitude: t2.longitude
        }
      };
    if (t2 instanceof eh)
      return {
        bytesValue: Cs(e2.wt, t2._byteString)
      };
    if (t2 instanceof ba) {
      const n = e2.databaseId, s = t2.firestore._databaseId;
      if (!s.isEqual(n))
        throw e2.oa(`Document reference is for database ${s.projectId}/${s.database} but should be for database ${n.projectId}/${n.database}`);
      return {
        referenceValue: ks(t2.firestore._databaseId || e2.databaseId, t2._key.path)
      };
    }
    throw e2.oa(`Unsupported field value: ${pa(t2)}`);
  }(t, e);
}
function Eh(t, e) {
  const n = {};
  return Ut(t) ? e.path && e.path.length > 0 && e.fieldMask.push(e.path) : Lt(t, (t2, s) => {
    const i = Th(s, e.ea(t2));
    null != i && (n[t2] = i);
  }), {
    mapValue: {
      fields: n
    }
  };
}
function Ah(t) {
  return !("object" != typeof t || null === t || t instanceof Array || t instanceof Date || t instanceof ut || t instanceof sh || t instanceof eh || t instanceof ba || t instanceof nh);
}
function Rh(t, e, n) {
  if (!Ah(n) || !function(t2) {
    return "object" == typeof t2 && null !== t2 && (Object.getPrototypeOf(t2) === Object.prototype || null === Object.getPrototypeOf(t2));
  }(n)) {
    const s = pa(n);
    throw "an object" === s ? e.oa(t + " a custom object") : e.oa(t + " " + s);
  }
}
function bh(t, e, n) {
  if ((e = getModularInstance(e)) instanceof Za)
    return e._internalPath;
  if ("string" == typeof e)
    return vh(t, e);
  throw Vh("Field path arguments must be of type string or ", t, false, void 0, n);
}
var Ph = new RegExp("[~\\*/\\[\\]]");
function vh(t, e, n) {
  if (e.search(Ph) >= 0)
    throw Vh(`Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`, t, false, void 0, n);
  try {
    return new Za(...e.split("."))._internalPath;
  } catch (s) {
    throw Vh(`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, t, false, void 0, n);
  }
}
function Vh(t, e, n, s, i) {
  const r = s && !s.isEmpty(), o = void 0 !== i;
  let u = `Function ${e}() called with invalid data`;
  n && (u += " (via `toFirestore()`)"), u += ". ";
  let c = "";
  return (r || o) && (c += " (found", r && (c += ` in field ${s}`), o && (c += ` in document ${i}`), c += ")"), new Q(G.INVALID_ARGUMENT, u + t + c);
}
function Sh(t, e) {
  return t.some((t2) => t2.isEqual(e));
}
var Dh = class {
  constructor(t, e, n, s, i) {
    this._firestore = t, this._userDataWriter = e, this._key = n, this._document = s, this._converter = i;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get ref() {
    return new ba(this._firestore, this._converter, this._key);
  }
  exists() {
    return null !== this._document;
  }
  data() {
    if (this._document) {
      if (this._converter) {
        const t = new Ch(this._firestore, this._userDataWriter, this._key, this._document, null);
        return this._converter.fromFirestore(t);
      }
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  get(t) {
    if (this._document) {
      const e = this._document.data.field(xh("DocumentSnapshot.get", t));
      if (null !== e)
        return this._userDataWriter.convertValue(e);
    }
  }
};
var Ch = class extends Dh {
  data() {
    return super.data();
  }
};
function xh(t, e) {
  return "string" == typeof e ? vh(t, e) : e instanceof Za ? e._internalPath : e._delegate._internalPath;
}
var Nh = class {
  constructor(t, e) {
    this.hasPendingWrites = t, this.fromCache = e;
  }
  isEqual(t) {
    return this.hasPendingWrites === t.hasPendingWrites && this.fromCache === t.fromCache;
  }
};
var kh = class extends Dh {
  constructor(t, e, n, s, i, r) {
    super(t, e, n, s, r), this._firestore = t, this._firestoreImpl = t, this.metadata = i;
  }
  exists() {
    return super.exists();
  }
  data(t = {}) {
    if (this._document) {
      if (this._converter) {
        const e = new Oh(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
        return this._converter.fromFirestore(e, t);
      }
      return this._userDataWriter.convertValue(this._document.data.value, t.serverTimestamps);
    }
  }
  get(t, e = {}) {
    if (this._document) {
      const n = this._document.data.field(xh("DocumentSnapshot.get", t));
      if (null !== n)
        return this._userDataWriter.convertValue(n, e.serverTimestamps);
    }
  }
};
var Oh = class extends kh {
  data(t = {}) {
    return super.data(t);
  }
};
var Mh = class {
  constructor(t, e, n, s) {
    this._firestore = t, this._userDataWriter = e, this._snapshot = s, this.metadata = new Nh(s.hasPendingWrites, s.fromCache), this.query = n;
  }
  get docs() {
    const t = [];
    return this.forEach((e) => t.push(e)), t;
  }
  get size() {
    return this._snapshot.docs.size;
  }
  get empty() {
    return 0 === this.size;
  }
  forEach(t, e) {
    this._snapshot.docs.forEach((n) => {
      t.call(e, new Oh(this._firestore, this._userDataWriter, n.key, n, new Nh(this._snapshot.mutatedKeys.has(n.key), this._snapshot.fromCache), this.query.converter));
    });
  }
  docChanges(t = {}) {
    const e = !!t.includeMetadataChanges;
    if (e && this._snapshot.excludesMetadataChanges)
      throw new Q(G.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
    return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === e || (this._cachedChanges = function(t2, e2) {
      if (t2._snapshot.oldDocs.isEmpty()) {
        let e3 = 0;
        return t2._snapshot.docChanges.map((n) => ({
          type: "added",
          doc: new Oh(t2._firestore, t2._userDataWriter, n.doc.key, n.doc, new Nh(t2._snapshot.mutatedKeys.has(n.doc.key), t2._snapshot.fromCache), t2.query.converter),
          oldIndex: -1,
          newIndex: e3++
        }));
      }
      {
        let n = t2._snapshot.oldDocs;
        return t2._snapshot.docChanges.filter((t3) => e2 || 3 !== t3.type).map((e3) => {
          const s = new Oh(t2._firestore, t2._userDataWriter, e3.doc.key, e3.doc, new Nh(t2._snapshot.mutatedKeys.has(e3.doc.key), t2._snapshot.fromCache), t2.query.converter);
          let i = -1, r = -1;
          return 0 !== e3.type && (i = n.indexOf(e3.doc.key), n = n.delete(e3.doc.key)), 1 !== e3.type && (n = n.add(e3.doc), r = n.indexOf(e3.doc.key)), {
            type: Fh(e3.type),
            doc: s,
            oldIndex: i,
            newIndex: r
          };
        });
      }
    }(this, e), this._cachedChangesIncludeMetadataChanges = e), this._cachedChanges;
  }
};
function Fh(t) {
  switch (t) {
    case 0:
      return "added";
    case 2:
    case 3:
      return "modified";
    case 1:
      return "removed";
    default:
      return L();
  }
}
function $h(t, e) {
  return t instanceof kh && e instanceof kh ? t._firestore === e._firestore && t._key.isEqual(e._key) && (null === t._document ? null === e._document : t._document.isEqual(e._document)) && t._converter === e._converter : t instanceof Mh && e instanceof Mh && (t._firestore === e._firestore && xa(t.query, e.query) && t.metadata.isEqual(e.metadata) && t._snapshot.isEqual(e._snapshot));
}
function Bh(t) {
  if ("L" === t.limitType && 0 === t.explicitOrderBy.length)
    throw new Q(G.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
}
var Lh = class {
};
function Uh(t, ...e) {
  for (const n of e)
    t = n._apply(t);
  return t;
}
var qh = class extends Lh {
  constructor(t, e, n) {
    super(), this.fa = t, this.da = e, this._a = n, this.type = "where";
  }
  _apply(t) {
    const e = hh(t.firestore), n = function(t2, e2, n2, s, i, r, o) {
      let u;
      if (i.isKeyField()) {
        if ("array-contains" === r || "array-contains-any" === r)
          throw new Q(G.INVALID_ARGUMENT, `Invalid Query. You can't perform '${r}' queries on documentId().`);
        if ("in" === r || "not-in" === r) {
          sl(o, r);
          const e3 = [];
          for (const n3 of o)
            e3.push(nl(s, t2, n3));
          u = {
            arrayValue: {
              values: e3
            }
          };
        } else
          u = nl(s, t2, o);
      } else
        "in" !== r && "not-in" !== r && "array-contains-any" !== r || sl(o, r), u = Ih(n2, e2, o, "in" === r || "not-in" === r);
      const c = qe.create(i, r, u);
      return function(t3, e3) {
        if (e3.ht()) {
          const n4 = cn(t3);
          if (null !== n4 && !n4.isEqual(e3.field))
            throw new Q(G.INVALID_ARGUMENT, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${n4.toString()}' and '${e3.field.toString()}'`);
          const s2 = un(t3);
          null !== s2 && il(t3, e3.field, s2);
        }
        const n3 = function(t4, e4) {
          for (const n4 of t4.filters)
            if (e4.indexOf(n4.op) >= 0)
              return n4.op;
          return null;
        }(t3, function(t4) {
          switch (t4) {
            case "!=":
              return ["!=", "not-in"];
            case "array-contains":
              return ["array-contains", "array-contains-any", "not-in"];
            case "in":
              return ["array-contains-any", "in", "not-in"];
            case "array-contains-any":
              return ["array-contains", "array-contains-any", "in", "not-in"];
            case "not-in":
              return ["array-contains", "array-contains-any", "in", "not-in", "!="];
            default:
              return [];
          }
        }(e3.op));
        if (null !== n3)
          throw n3 === e3.op ? new Q(G.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${e3.op.toString()}' filter.`) : new Q(G.INVALID_ARGUMENT, `Invalid query. You cannot use '${e3.op.toString()}' filters with '${n3.toString()}' filters.`);
      }(t2, c), c;
    }(t._query, "where", e, t.firestore._databaseId, this.fa, this.da, this._a);
    return new Pa(t.firestore, t.converter, function(t2, e2) {
      const n2 = t2.filters.concat([e2]);
      return new nn(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), n2, t2.limit, t2.limitType, t2.startAt, t2.endAt);
    }(t._query, n));
  }
};
function Kh(t, e, n) {
  const s = e, i = xh("where", t);
  return new qh(i, s, n);
}
var Gh = class extends Lh {
  constructor(t, e) {
    super(), this.fa = t, this.wa = e, this.type = "orderBy";
  }
  _apply(t) {
    const e = function(t2, e2, n) {
      if (null !== t2.startAt)
        throw new Q(G.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
      if (null !== t2.endAt)
        throw new Q(G.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
      const s = new Xe(e2, n);
      return function(t3, e3) {
        if (null === un(t3)) {
          const n2 = cn(t3);
          null !== n2 && il(t3, n2, e3.field);
        }
      }(t2, s), s;
    }(t._query, this.fa, this.wa);
    return new Pa(t.firestore, t.converter, function(t2, e2) {
      const n = t2.explicitOrderBy.concat([e2]);
      return new nn(t2.path, t2.collectionGroup, n, t2.filters.slice(), t2.limit, t2.limitType, t2.startAt, t2.endAt);
    }(t._query, e));
  }
};
function Qh(t, e = "asc") {
  const n = e, s = xh("orderBy", t);
  return new Gh(s, n);
}
var jh = class extends Lh {
  constructor(t, e, n) {
    super(), this.type = t, this.ma = e, this.ga = n;
  }
  _apply(t) {
    return new Pa(t.firestore, t.converter, fn(t._query, this.ma, this.ga));
  }
};
function Wh(t) {
  return Ta("limit", t), new jh("limit", t, "F");
}
function zh(t) {
  return Ta("limitToLast", t), new jh("limitToLast", t, "L");
}
var Hh = class extends Lh {
  constructor(t, e, n) {
    super(), this.type = t, this.ya = e, this.pa = n;
  }
  _apply(t) {
    const e = el(t, this.type, this.ya, this.pa);
    return new Pa(t.firestore, t.converter, function(t2, e2) {
      return new nn(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), t2.filters.slice(), t2.limit, t2.limitType, e2, t2.endAt);
    }(t._query, e));
  }
};
function Jh(...t) {
  return new Hh("startAt", t, true);
}
function Yh(...t) {
  return new Hh("startAfter", t, false);
}
var Xh = class extends Lh {
  constructor(t, e, n) {
    super(), this.type = t, this.ya = e, this.pa = n;
  }
  _apply(t) {
    const e = el(t, this.type, this.ya, this.pa);
    return new Pa(t.firestore, t.converter, function(t2, e2) {
      return new nn(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), t2.filters.slice(), t2.limit, t2.limitType, t2.startAt, e2);
    }(t._query, e));
  }
};
function Zh(...t) {
  return new Xh("endBefore", t, false);
}
function tl(...t) {
  return new Xh("endAt", t, true);
}
function el(t, e, n, s) {
  if (n[0] = getModularInstance(n[0]), n[0] instanceof Dh)
    return function(t2, e2, n2, s2, i) {
      if (!s2)
        throw new Q(G.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ${n2}().`);
      const r = [];
      for (const n3 of hn(t2))
        if (n3.field.isKeyField())
          r.push(ye(e2, s2.key));
        else {
          const t3 = s2.data.field(n3.field);
          if (ee(t3))
            throw new Q(G.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + n3.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
          if (null === t3) {
            const t4 = n3.field.canonicalString();
            throw new Q(G.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a document for which the field '${t4}' (used as the orderBy) does not exist.`);
          }
          r.push(t3);
        }
      return new Ye(r, i);
    }(t._query, t.firestore._databaseId, e, n[0]._document, s);
  {
    const i = hh(t.firestore);
    return function(t2, e2, n2, s2, i2, r) {
      const o = t2.explicitOrderBy;
      if (i2.length > o.length)
        throw new Q(G.INVALID_ARGUMENT, `Too many arguments provided to ${s2}(). The number of arguments must be less than or equal to the number of orderBy() clauses`);
      const u = [];
      for (let r2 = 0; r2 < i2.length; r2++) {
        const c = i2[r2];
        if (o[r2].field.isKeyField()) {
          if ("string" != typeof c)
            throw new Q(G.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ${s2}(), but got a ${typeof c}`);
          if (!an(t2) && -1 !== c.indexOf("/"))
            throw new Q(G.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by documentId(), the value passed to ${s2}() must be a plain document ID, but '${c}' contains a slash.`);
          const n3 = t2.path.child(ht.fromString(c));
          if (!dt.isDocumentKey(n3))
            throw new Q(G.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by documentId(), the value passed to ${s2}() must result in a valid document path, but '${n3}' is not because it contains an odd number of segments.`);
          const i3 = new dt(n3);
          u.push(ye(e2, i3));
        } else {
          const t3 = Ih(n2, s2, c);
          u.push(t3);
        }
      }
      return new Ye(u, r);
    }(t._query, t.firestore._databaseId, i, e, n, s);
  }
}
function nl(t, e, n) {
  if ("string" == typeof (n = getModularInstance(n))) {
    if ("" === n)
      throw new Q(G.INVALID_ARGUMENT, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!an(e) && -1 !== n.indexOf("/"))
      throw new Q(G.INVALID_ARGUMENT, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`);
    const s = e.path.child(ht.fromString(n));
    if (!dt.isDocumentKey(s))
      throw new Q(G.INVALID_ARGUMENT, `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${s}' is not because it has an odd number of segments (${s.length}).`);
    return ye(t, new dt(s));
  }
  if (n instanceof ba)
    return ye(t, n._key);
  throw new Q(G.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${pa(n)}.`);
}
function sl(t, e) {
  if (!Array.isArray(t) || 0 === t.length)
    throw new Q(G.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`);
  if (t.length > 10)
    throw new Q(G.INVALID_ARGUMENT, `Invalid Query. '${e.toString()}' filters support a maximum of 10 elements in the value array.`);
}
function il(t, e, n) {
  if (!n.isEqual(e))
    throw new Q(G.INVALID_ARGUMENT, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e.toString()}' and so you must also use '${e.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${n.toString()}' instead.`);
}
var rl = {
  maxAttempts: 5
};
var ol = class {
  convertValue(t, e = "none") {
    switch (le(t)) {
      case 0:
        return null;
      case 1:
        return t.booleanValue;
      case 2:
        return Zt(t.integerValue || t.doubleValue);
      case 3:
        return this.convertTimestamp(t.timestampValue);
      case 4:
        return this.convertServerTimestamp(t, e);
      case 5:
        return t.stringValue;
      case 6:
        return this.convertBytes(te(t.bytesValue));
      case 7:
        return this.convertReference(t.referenceValue);
      case 8:
        return this.convertGeoPoint(t.geoPointValue);
      case 9:
        return this.convertArray(t.arrayValue, e);
      case 10:
        return this.convertObject(t.mapValue, e);
      default:
        throw L();
    }
  }
  convertObject(t, e) {
    const n = {};
    return Lt(t.fields, (t2, s) => {
      n[t2] = this.convertValue(s, e);
    }), n;
  }
  convertGeoPoint(t) {
    return new sh(Zt(t.latitude), Zt(t.longitude));
  }
  convertArray(t, e) {
    return (t.values || []).map((t2) => this.convertValue(t2, e));
  }
  convertServerTimestamp(t, e) {
    switch (e) {
      case "previous":
        const n = ne(t);
        return null == n ? null : this.convertValue(n, e);
      case "estimate":
        return this.convertTimestamp(se(t));
      default:
        return null;
    }
  }
  convertTimestamp(t) {
    const e = Xt(t);
    return new ut(e.seconds, e.nanos);
  }
  convertDocumentKey(t, e) {
    const n = ht.fromString(t);
    U(ui(n));
    const s = new re(n.get(1), n.get(3)), i = new dt(n.popFirst(5));
    return s.isEqual(e) || F(`Document ${i} contains a document reference within a different database (${s.projectId}/${s.database}) which is not supported. It will be treated as a reference in the current database (${e.projectId}/${e.database}) instead.`), i;
  }
};
function ul(t, e, n) {
  let s;
  return s = t ? n && (n.merge || n.mergeFields) ? t.toFirestore(e, n) : t.toFirestore(e) : e, s;
}
var cl = class extends ol {
  constructor(t) {
    super(), this.firestore = t;
  }
  convertBytes(t) {
    return new eh(t);
  }
  convertReference(t) {
    const e = this.convertDocumentKey(t, this.firestore._databaseId);
    return new ba(this.firestore, null, e);
  }
};
var al = class {
  constructor(t, e) {
    this._firestore = t, this._commitHandler = e, this._mutations = [], this._committed = false, this._dataReader = hh(t);
  }
  set(t, e, n) {
    this._verifyNotCommitted();
    const s = hl(t, this._firestore), i = ul(s.converter, e, n), r = lh(this._dataReader, "WriteBatch.set", s._key, i, null !== s.converter, n);
    return this._mutations.push(r.toMutation(s._key, $n.none())), this;
  }
  update(t, e, n, ...s) {
    this._verifyNotCommitted();
    const i = hl(t, this._firestore);
    let r;
    return r = "string" == typeof (e = getModularInstance(e)) || e instanceof Za ? ph(this._dataReader, "WriteBatch.update", i._key, e, n, s) : yh(this._dataReader, "WriteBatch.update", i._key, e), this._mutations.push(r.toMutation(i._key, $n.exists(true))), this;
  }
  delete(t) {
    this._verifyNotCommitted();
    const e = hl(t, this._firestore);
    return this._mutations = this._mutations.concat(new Yn(e._key, $n.none())), this;
  }
  commit() {
    return this._verifyNotCommitted(), this._committed = true, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();
  }
  _verifyNotCommitted() {
    if (this._committed)
      throw new Q(G.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.");
  }
};
function hl(t, e) {
  if ((t = getModularInstance(t)).firestore !== e)
    throw new Q(G.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
  return t;
}
function ll(t) {
  t = Ia(t, ba);
  const e = Ia(t.firestore, Fa);
  return ua(La(e), t._key).then((n) => bl(e, t, n));
}
var fl = class extends ol {
  constructor(t) {
    super(), this.firestore = t;
  }
  convertBytes(t) {
    return new eh(t);
  }
  convertReference(t) {
    const e = this.convertDocumentKey(t, this.firestore._databaseId);
    return new ba(this.firestore, null, e);
  }
};
function dl(t) {
  t = Ia(t, ba);
  const e = Ia(t.firestore, Fa), n = La(e), s = new fl(e);
  return oa(n, t._key).then((n2) => new kh(e, s, t._key, n2, new Nh(null !== n2 && n2.hasLocalMutations, true), t.converter));
}
function _l(t) {
  t = Ia(t, ba);
  const e = Ia(t.firestore, Fa);
  return ua(La(e), t._key, {
    source: "server"
  }).then((n) => bl(e, t, n));
}
function wl(t) {
  t = Ia(t, Pa);
  const e = Ia(t.firestore, Fa), n = La(e), s = new fl(e);
  return Bh(t._query), aa(n, t._query).then((n2) => new Mh(e, s, t, n2));
}
function ml(t) {
  t = Ia(t, Pa);
  const e = Ia(t.firestore, Fa), n = La(e), s = new fl(e);
  return ca(n, t._query).then((n2) => new Mh(e, s, t, n2));
}
function gl(t) {
  t = Ia(t, Pa);
  const e = Ia(t.firestore, Fa), n = La(e), s = new fl(e);
  return aa(n, t._query, {
    source: "server"
  }).then((n2) => new Mh(e, s, t, n2));
}
function yl(t, e, n) {
  t = Ia(t, ba);
  const s = Ia(t.firestore, Fa), i = ul(t.converter, e, n);
  return Rl(s, [lh(hh(s), "setDoc", t._key, i, null !== t.converter, n).toMutation(t._key, $n.none())]);
}
function pl(t, e, n, ...s) {
  t = Ia(t, ba);
  const i = Ia(t.firestore, Fa), r = hh(i);
  let o;
  o = "string" == typeof (e = getModularInstance(e)) || e instanceof Za ? ph(r, "updateDoc", t._key, e, n, s) : yh(r, "updateDoc", t._key, e);
  return Rl(i, [o.toMutation(t._key, $n.exists(true))]);
}
function Il(t) {
  return Rl(Ia(t.firestore, Fa), [new Yn(t._key, $n.none())]);
}
function Tl(t, e) {
  const n = Ia(t.firestore, Fa), s = Da(t), i = ul(t.converter, e);
  return Rl(n, [lh(hh(t.firestore), "addDoc", s._key, i, null !== t.converter, {}).toMutation(s._key, $n.exists(false))]).then(() => s);
}
function El(t, ...e) {
  var n, s, i;
  t = getModularInstance(t);
  let r = {
    includeMetadataChanges: false
  }, o = 0;
  "object" != typeof e[o] || ka(e[o]) || (r = e[o], o++);
  const u = {
    includeMetadataChanges: r.includeMetadataChanges
  };
  if (ka(e[o])) {
    const t2 = e[o];
    e[o] = null === (n = t2.next) || void 0 === n ? void 0 : n.bind(t2), e[o + 1] = null === (s = t2.error) || void 0 === s ? void 0 : s.bind(t2), e[o + 2] = null === (i = t2.complete) || void 0 === i ? void 0 : i.bind(t2);
  }
  let c, a, h;
  if (t instanceof ba)
    a = Ia(t.firestore, Fa), h = rn(t._key.path), c = {
      next: (n2) => {
        e[o] && e[o](bl(a, t, n2));
      },
      error: e[o + 1],
      complete: e[o + 2]
    };
  else {
    const n2 = Ia(t, Pa);
    a = Ia(n2.firestore, Fa), h = n2._query;
    const s2 = new fl(a);
    c = {
      next: (t2) => {
        e[o] && e[o](new Mh(a, s2, n2, t2));
      },
      error: e[o + 1],
      complete: e[o + 2]
    }, Bh(t._query);
  }
  return function(t2, e2, n2, s2) {
    const i2 = new Gc(s2), r2 = new Ju(e2, i2, n2);
    return t2.asyncQueue.enqueueAndForget(async () => Qu(await sa(t2), r2)), () => {
      i2.Tc(), t2.asyncQueue.enqueueAndForget(async () => ju(await sa(t2), r2));
    };
  }(La(a), h, u, c);
}
function Al(t, e) {
  return ha(La(t = Ia(t, Fa)), ka(e) ? e : {
    next: e
  });
}
function Rl(t, e) {
  return function(t2, e2) {
    const n = new j();
    return t2.asyncQueue.enqueueAndForget(async () => hc(await na(t2), e2, n)), n.promise;
  }(La(t), e);
}
function bl(t, e, n) {
  const s = n.docs.get(e._key), i = new fl(t);
  return new kh(t, i, e._key, s, new Nh(n.hasPendingWrites, n.fromCache), e.converter);
}
var Pl = class extends class {
  constructor(t, e) {
    this._firestore = t, this._transaction = e, this._dataReader = hh(t);
  }
  get(t) {
    const e = hl(t, this._firestore), n = new cl(this._firestore);
    return this._transaction.lookup([e._key]).then((t2) => {
      if (!t2 || 1 !== t2.length)
        return L();
      const s = t2[0];
      if (s.isFoundDocument())
        return new Dh(this._firestore, n, s.key, s, e.converter);
      if (s.isNoDocument())
        return new Dh(this._firestore, n, e._key, null, e.converter);
      throw L();
    });
  }
  set(t, e, n) {
    const s = hl(t, this._firestore), i = ul(s.converter, e, n), r = lh(this._dataReader, "Transaction.set", s._key, i, null !== s.converter, n);
    return this._transaction.set(s._key, r), this;
  }
  update(t, e, n, ...s) {
    const i = hl(t, this._firestore);
    let r;
    return r = "string" == typeof (e = getModularInstance(e)) || e instanceof Za ? ph(this._dataReader, "Transaction.update", i._key, e, n, s) : yh(this._dataReader, "Transaction.update", i._key, e), this._transaction.update(i._key, r), this;
  }
  delete(t) {
    const e = hl(t, this._firestore);
    return this._transaction.delete(e._key), this;
  }
} {
  constructor(t, e) {
    super(t, e), this._firestore = t;
  }
  get(t) {
    const e = hl(t, this._firestore), n = new fl(this._firestore);
    return super.get(t).then((t2) => new kh(this._firestore, n, e._key, t2._document, new Nh(false, false), e.converter));
  }
};
function vl(t, e, n) {
  t = Ia(t, Fa);
  const s = Object.assign(Object.assign({}, rl), n);
  !function(t2) {
    if (t2.maxAttempts < 1)
      throw new Q(G.INVALID_ARGUMENT, "Max attempts must be at least 1");
  }(s);
  return la(La(t), (n2) => e(new Pl(t, n2)), s);
}
function Vl() {
  return new fh("deleteField");
}
function Sl() {
  return new _h("serverTimestamp");
}
function Dl(...t) {
  return new wh("arrayUnion", t);
}
function Cl(...t) {
  return new mh("arrayRemove", t);
}
function xl(t) {
  return new gh("increment", t);
}
function Nl(t) {
  return La(t = Ia(t, Fa)), new al(t, (e) => Rl(t, e));
}
function kl(t, e) {
  La(t = Ia(t, Fa));
  const n = "string" == typeof e ? function(t2) {
    var e2;
    try {
      return JSON.parse(t2);
    } catch (t3) {
      throw new Q(G.INVALID_ARGUMENT, "Failed to parse JSON:" + (null === (e2 = t3) || void 0 === e2 ? void 0 : e2.message));
    }
  }(e) : e, s = [];
  if (Array.isArray(n.indexes))
    for (const t2 of n.indexes) {
      const e2 = Ol(t2, "collectionGroup"), n2 = [];
      if (Array.isArray(t2.fields))
        for (const e3 of t2.fields) {
          const t3 = vh("setIndexConfiguration", Ol(e3, "fieldPath"));
          "CONTAINS" === e3.arrayConfig ? n2.push(new gt(t3, 2)) : "ASCENDING" === e3.order ? n2.push(new gt(t3, 0)) : "DESCENDING" === e3.order && n2.push(new gt(t3, 1));
        }
      s.push(new _t(_t.UNKNOWN_ID, e2, n2, yt.empty()));
    }
  return Promise.resolve();
}
function Ol(t, e) {
  if ("string" != typeof t[e])
    throw new Q(G.INVALID_ARGUMENT, "Missing string value for: " + e);
  return t[e];
}
!function(t, e = true) {
  !function(t2) {
    x = t2;
  }(SDK_VERSION), _registerComponent(new Component("firestore", (t2, { options: n }) => {
    const s = t2.getProvider("app").getImmediate(), i = new Fa(s, new J(t2.getProvider("auth-internal")), new tt(t2.getProvider("app-check-internal")));
    return n = Object.assign({
      useFetchStreams: e
    }, n), i._setSettings(n), i;
  }, "PUBLIC")), registerVersion(D, "3.4.12", t), registerVersion(D, "3.4.12", "esm2017");
}();
export {
  ol as AbstractUserDataWriter,
  eh as Bytes,
  Ma as CACHE_SIZE_UNLIMITED,
  va as CollectionReference,
  ba as DocumentReference,
  kh as DocumentSnapshot,
  Za as FieldPath,
  nh as FieldValue,
  Fa as Firestore,
  Q as FirestoreError,
  sh as GeoPoint,
  Oa as LoadBundleTask,
  Pa as Query,
  Lh as QueryConstraint,
  Oh as QueryDocumentSnapshot,
  Mh as QuerySnapshot,
  Nh as SnapshotMetadata,
  ut as Timestamp,
  Pl as Transaction,
  al as WriteBatch,
  re as _DatabaseId,
  dt as _DocumentKey,
  et as _EmptyAppCheckTokenProvider,
  z as _EmptyAuthCredentialsProvider,
  ft as _FieldPath,
  Ia as _cast,
  q as _debugAssert,
  Ht as _isBase64Available,
  $ as _logWarn,
  kl as _setIndexConfiguration,
  ma as _validateIsNotUsedTogether,
  Tl as addDoc,
  Cl as arrayRemove,
  Dl as arrayUnion,
  Qa as clearIndexedDbPersistence,
  Va as collection,
  Sa as collectionGroup,
  Ra as connectFirestoreEmulator,
  Il as deleteDoc,
  Vl as deleteField,
  za as disableNetwork,
  Da as doc,
  th as documentId,
  qa as enableIndexedDbPersistence,
  Ka as enableMultiTabIndexedDbPersistence,
  Wa as enableNetwork,
  tl as endAt,
  Zh as endBefore,
  La as ensureFirestoreConfigured,
  Rl as executeWrite,
  ll as getDoc,
  dl as getDocFromCache,
  _l as getDocFromServer,
  wl as getDocs,
  ml as getDocsFromCache,
  gl as getDocsFromServer,
  Ba as getFirestore,
  xl as increment,
  $a as initializeFirestore,
  Wh as limit,
  zh as limitToLast,
  Ja as loadBundle,
  Ya as namedQuery,
  El as onSnapshot,
  Al as onSnapshotsInSync,
  Qh as orderBy,
  Uh as query,
  xa as queryEqual,
  Ca as refEqual,
  vl as runTransaction,
  Sl as serverTimestamp,
  yl as setDoc,
  O as setLogLevel,
  $h as snapshotEqual,
  Yh as startAfter,
  Jh as startAt,
  Ha as terminate,
  pl as updateDoc,
  ja as waitForPendingWrites,
  Kh as where,
  Nl as writeBatch
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
* @license
* Copyright 2017 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* @license
* Copyright 2020 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
//# sourceMappingURL=firebase_firestore.js.map
